{"meta":{"title":"TT","subtitle":"DaChui","description":"多搞学习就好了","author":"DaChui","url":"https://dahammer666.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-01-29T04:58:56.000Z","updated":"2022-01-29T03:28:32.892Z","comments":false,"path":"about/index.html","permalink":"https://dahammer666.github.io/about/index.html","excerpt":"","text":"TT“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我座右铭：钱难赚，屎难吃"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://dahammer666.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://dahammer666.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://dahammer666.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://dahammer666.github.io/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://dahammer666.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://dahammer666.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T03:48:51.191Z","updated":"2022-01-29T03:48:51.191Z","comments":false,"path":"List/gallery/index.html","permalink":"https://dahammer666.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片 TT 關於head的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://dahammer666.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-01-28T06:56:56.575Z","comments":false,"path":"List/music/index.html","permalink":"https://dahammer666.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://dahammer666.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T14:56:13.000Z","updated":"2022-01-29T03:43:19.826Z","comments":false,"path":"List/gallery/head/index.html","permalink":"https://dahammer666.github.io/List/gallery/head/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://dahammer666.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2022-02-15T09:35:11.000Z","updated":"2022-02-15T09:39:23.978Z","comments":true,"path":"posts/managermodel/","link":"","permalink":"https://dahammer666.github.io/posts/managermodel/","excerpt":"","text":"设计模式七大原则单一职责原则 降低类复杂度，一个类只负责一项职责。 提高类的可读性、可维护性 只要逻辑足够简单，类中的方法数量足够少，可以违反单一职责原则。 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上 依赖倒转原则 核心是面向接口编程 高层模块不应该依赖低层模块，二者都应该依赖其抽象 注意事项： 低模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好。 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里式替换原则 里式替换原则 所有引用基类的地方能够透明地使用其子类的对象 在使用继承时，遵循里式替换原则，在子类中尽量不要重写父类的方法 继承实际让两个类耦合性增强了，可通过聚合、组合、依赖解决问题 -&gt; 通用做法是：原来的父类和子类都继承了一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等 开闭原则 最基础、重要的设计原则 开：对功能的扩展开放（对提供方）；关：修改关闭（使用方） ocp: 尽量通过扩展软件实体的行为，不是通过修改已有代码 -&gt; 将父类做成抽象类，并提供一个抽象方法，让子类去继承实现。如此我们有新的种类时，只需要让新的种类继承父类，实现抽象方法即可，使用方的代码就不需要关闭。满足开闭原则 迪米特法则 最少知道原则，即一个类对自己依赖的类知道的越少越好，即降低耦合度；对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。 直接‘朋友’：每个对象都会有与其他对象有耦合关系，耦合方式很多：依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数和方法的返回值中的类为直接朋友；而出现在局部变量中的类不是直接朋友，也就是说，陌生的对象/类 不要以局部变量的形式出现在类的内部。 注意事项：迪米特法则核心是降低类之间的耦合。 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则核心思想 找出应用中需要修改的地方，把它们独立出来，跟不需要修改的代码隔离。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计 UML图 uml基本详情 是一种用于软件系统分析和设计的语言工具 uml图 用例图 静态结构图：类图、对象图、包图、组件图、部署图 动态行为图：交互图（时序图与协作图）、状态图、活动图 说明： 类图是描述类与类（对象）的静态关系，是uml图中最核心的 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。 类与类之间的关系 依赖 -&gt; 主要在类中用到了对方，他们之间就存在依赖 依赖的构成： 类的成员属性 方法的返回类型 接收的参数类型 方法中使用到 泛化：实际上就是继承关系，是依赖关系的特立。 -&gt;如果A类继承了B类，我们就能说是A和B存在泛化关系 实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例； 关联关系 关联关系实际上就是类与类之间的关系，他是依赖关系的特例。 关联具有导航性，即双向关系或者单向关系（单向一对一关系、双向一对一关系） 关系具有多重性（一对一，多对多） 聚合关系 表示整体和部分的关系，整体与部门可以分开。聚合关系是关联关系的特例；所以它具有关联的导航性（B聚合A）与多重性（多个属性聚合了A）。 组合关系 组合关系也是整体与部分的关系，但是整体与部分不能分开。 聚合和组合区别： 聚合中整体与部分能看；组合中整体与部分不能分开 public class Person{ private IDCard card;//聚合 private Head head = new Head();//组合 } public class IDCard{} public class Head{} -&gt; 如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了 ./设计模式分类 ./设计模式分为三种类型，共23种 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式、 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）。 ./设计模式介绍： 模式不是代码，是某类问题的通用解决方案。 本质上是提高软件的维护性、通用性和扩展性，并降低软件的复杂度。 单例模式-&gt; 采用方法，对某个类只能存在一个对象实例，并该类只提供一个取得其对象实例的方法（静态方法）。 单例模式八种写法 *饿汉式（静态常量）** *饿汉式（静态代码块）** 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程不安全，同步代码块） *双重检查** *静态内部类** *枚举** 饿汉式（静态常量）-&gt;应用实例： 构造器私有化 （防止其他对象/类 创建对象(new)） 类的内部创建对象 向外暴露一个静态的公共方法 getInstance 代码实现 优缺点说明： 优点：这种写法简单，在类装载的时候就完成实例化。避免了线程同步问题。 缺点：在类装载时就完成实例化，没有达到Lazy Loading（懒加载）的效果。例如：如果从未用过这个实例的话，就会造成内存的浪费。 这种方式基于classloder机制避免了多线程的同步问题，不过,instance在类装载时候就实例化了，在单例模式中大多数都是在调用getInstance方法，但是导致类装载的原因有很多种，不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化Instance就没有达到lazy loading的效果 饿汉式（静态常量）这种单例模式可用，但是可能造成内存浪费。 package com.atiguigu1.singleton; public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); System.out.println(\"instance.hasCode=\" + instance.hashCode()); System.out.println(\"instance2.hasCode=\" + instance2.hashCode()); } } class Singleton{ //1、构造器私有化，外部能New private Singleton(){ } //2、本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供一个公有的静态方法，返回实例对象 public static getInstance(){ return instance; } } 饿汉式（静态代码块）优缺点说明： 这种方式和上面饿汉式（静态常量）的方式类似，只不过将实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化的实例。优缺点和上面的一样的。 饿汉式（静态代码块）这种 单例模式可用，但是也是可能造成内存浪费。 class Singleton{ private Singleton() { } private final static Singleton instance; //在静态代码块中，创建单例对象 static { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 懒汉式（线程不安全）优缺点说明： 起到了Lazy Loading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入方法中的if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式。 结论：在实际开发中，不使用懒汉式。 //懒汉式（线程不安全） class Singleton { private static Singleton instance; private Singleton() { } //提供一个静态的共有方法，当使用该方法的时候，才去创建instance public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式（线程安全，同步方法）优缺点说明： -&gt;在静态getInstance()方法前面加 synchronized 解决了线程不安全问题 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法我们需求是只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低了。 //懒汉式（线程安全，同步方法） class Singleton { private static Singleton instance; private Singleton() { } //提供了一个静态的共有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式（线程不安全，同步代码块）-&gt; 这种港式，本事想对第四种{ 懒汉式（线程安全，同步方法）}实现方式的改进，因为同步方法效率态度，改为同步方法里面的产生实例化的代码块。 但是这种同步并不能起到线程同步的作用。跟第三种实现方式遇到的情形一致，假如一个线程进入了if(singleton == null)判断语句块中，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便回产生多个实例。不能保证线程安全。 class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } 双重检查 //双重检查 class Singleton { private static volatile Singleton instance; private Singleton() { } //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题 //同时保证了效率，推荐使用 public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { instance = new Singleton(); } } return instance; } } 优缺点说明： Double-Check概念是多线程开发中常用到的，代码中，我们进行了两次if(singleton == null)检查，可以保证线程安全。 实例化代码只用了一次，后面再次访问时，判断if(singleton == null),直接return实例化对象；延迟加载；效率较高 实际开发中，推荐使用双重检查做单例设计模式（推荐使用） 静态内部类//静态内部类 class Singleton{ private static volatile Singleton instance; //构造器私有化 private Singleton() { } //写一个静态内部类，该类中有一个静态属性Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点说明： 采用了类装载的机制来保证初始化实例时只有一个线程 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程无法进入。 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高（推荐使用） 枚举public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } enum Singleton { INSTANCE; public void sayOK(){ System.out.println(\"yyds\"); } } 优缺点说明： 借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。（推荐使用） 单例模式注意事项和细节说明 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须记住使用相应的获取对象的方法，而不是使用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等） 工厂模式 工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护。 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式) 设计模式的依赖抽象原则（不要依赖具体类） 注意： 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。（变量不要直接持有具体类的引用） 不要让类继承具体类，而是继承抽象类或者是实现interface（接口） 不要覆盖基类中已经实现的方法 Pizza项目需求： 披萨种类（GreekPizza、CheesePizza） 披萨的制作过程：prepare、bake、cut、box 完成披萨订单功能 传统方式 //Pizza实体 public abstract class Pizza { protected String name; //不同的Pizza不同的制作方法，做成一个抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \"bake\"); } public void cut() { System.out.println(name + \"cutting\"); } public void box() { System.out.println(name + \"boxing\"); } public void setName(String name) { this.name = name; } } //CheesePizza public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(\" 给制作奶酪披萨 准备原材料 \"); } } //OrderPizza pizza制作过程 public class OrderPizza { // 构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" greek披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" cheese披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } else { break; } //输出pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } //getType方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //pizza订单 public class PizzaStore { public static void main(String[] args) { new OrderPizza(); } } 传统方式的优缺点 优点是好理解，简单易操作 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者可能少修改代码。 例如，如果我们在上面功能还要再加新的Pizza种类，我们要修改如下 新增（扩展开放）： 修改（修改关闭）：-&gt;如果增加一个pizza类，主要是订购pizza的代码都要修改 简单工厂模式进行修改 把创建pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类即可，其它有创建到Pizza对象的代码就不需要修改了 简单工厂模式 基本介绍 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。 定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 实例代码 /** * 新增加pizza种类 简单工厂创建用来实例化对象的代码 */ public class SimpleFactory { //更改orderType 返回对应的Pizza 对象 简单工厂模式1 public Pizza createPizza(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } //简单工厂模式 也叫 静态工厂模式 简单工厂模式2 public static Pizza createPizza2(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式2\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } } --------- /** * 简单工厂模式1 */ public class OrderPizza2 { //定义一个简单工厂对象 SimpleFactory simpleFactory; Pizza pizza = null; //构造器 public OrderPizza2(SimpleFactory simpleFactory) { setFactory(simpleFactory); } public void setFactory(SimpleFactory simpleFactory) { //用户输入 String orderType = \"\"; //设置简单工厂对象 this.simpleFactory = simpleFactory; do { orderType = getType(); pizza = this.simpleFactory.createPizza(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购披萨失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * 简单工厂模式2 */ public class OrderPizza3 { Pizza pizza = null; String orderType = \"\"; //构造器 public OrderPizza3() { do { orderType = getType(); pizza = SimpleFactory.createPizza2(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\" 订购披萨失败 \"); break; } }while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * main方法 */ public class PizzaStore { public static void main(String[] args) { //常规方式 // new OrderPizza(); //简单工厂模式1 // new OrderPizza2(new SimpleFactory()); //简单工厂模式2 new OrderPizza3(); } } 工厂方法模式 工厂方法模式介绍 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 BJCheessPizza，BJPepperPizza，LDCheessPizza，LDPepperPizza /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } --- public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } ---- public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 工厂模式 */ public abstract class OrderPizza { //定义一个抽象方法，createPizza , 让各个工厂子类自己实现 abstract Pizza createPizza(String orderType); //构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); //抽象方法，由工厂子类完成 pizza = createPizza(orderType); //输出pizza制作过程 if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } --- public class BJOrderPizza extends OrderPizza{ @Override Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //main public class PizzaStore { public static void main(String[] args) { new BJOrderPizza(); } } 抽象工厂模式 基本介绍 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（进一步的抽象）。 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成工厂簇。更利于代码的维护和扩展。 /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } //实现抽象类1 public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } //实现抽象类2 public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 一个抽象工厂模式的抽象层(接口) */ public interface AbsFactory { //让下面的工厂子类来 具体实现 public Pizza createPizza(String orderType); } //实现抽象工厂 public class BJFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\"); Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //封装方法 public class OrderPizza { AbsFactory factory; // 构造器 public OrderPizza(AbsFactory factory) { setFactory(factory); } private void setFactory(AbsFactory factory) { Pizza pizza = null; String orderType = \"\"; this.factory = factory; do { orderType = getType(); // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类 pizza = factory.createPizza(orderType); if (pizza != null) { // 订购ok pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //main方法 public class PizzaStore { public static void main(String[] args) { new OrderPizza(new BJFactory()); } } 原型模式题型：克隆sheep 现在有一只羊tom，姓名为:tom，年龄为:1，颜色为:白色，请编写程序创建和tom羊属性完全相同的10只羊。 传统方式public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\"; } } ------ public class Client { public static void main(String[] args) { //传统的方法 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); //.... System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); //... } } 传统格式的优缺点 优点是比较好理解，简单易操作。 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率低。 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不灵活。 改进：java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的Java类必须实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力-》原型模式 原型模式基本介绍 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建的细节。 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即，对象.clone() -&gt;原型结构图说明 Prototype：原型类，声明一个克隆自己的接口。 ConcretePrototype：具体的原型类，实现一个克隆自己的操作 Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样） public class Sheep implements Cloneable{ private String name; private int age; private String color; private String address = \"蒙古羊\"; public Sheep friend; //是对象, 克隆是会如何处理 public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\"; } @Override protected Object clone(){ Sheep sheep = null; try { sheep = (Sheep) super.clone(); } catch (CloneNotSupportedException e) { // e.printStackTrace(); System.out.println(e.getMessage()); } return sheep; } } ||||| public class Client { public static void main(String[] args) { System.out.println(\"原型模式完成对象的创建\"); Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 2, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); //克隆 Sheep sheep3 = (Sheep)sheep.clone(); //克隆 Sheep sheep4 = (Sheep)sheep.clone(); //克隆 Sheep sheep5 = (Sheep)sheep.clone(); //克隆 System.out.println(\"sheep2 =\" + sheep2); System.out.println(\"sheep2 =\" + sheep3); System.out.println(\"sheep2 =\" + sheep4); System.out.println(\"sheep2 =\" + sheep5); System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode()); System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode()); System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode()); System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode()); } } 浅拷贝和深拷贝浅拷贝： 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值赋值一份给新的对象。 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数值、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 克隆羊是浅拷贝。 浅拷贝是使用默认的clone()方法实现 sheep =(Sheep)super.clone 深拷贝： 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝。 深拷贝实现方式1：重写clone方法来实现深拷贝 深拷贝实现方式2：通过对象序列化实现深拷贝 原型模式的注意事项 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码。 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。 public class DeepCloneableTarget implements Serializable, Cloneable { private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; //构造器 public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } //因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } ||||| public class DeepProtoType implements Serializable, Cloneable { public String name; //String 属性 public DeepCloneableTarget deepCloneableTarget;// 引用类型 public DeepProtoType() { super(); } //深拷贝 - 方式 1 使用clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; //这里完成对基本数据类型(属性)和String的克隆 deep = super.clone(); //对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType) deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone(); return deepProtoType; } //深拷贝 - 方式2 通过对象的序列化实现 (推荐) public Object deepClone() { //创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //序列化. bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //当前这个对象以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType copyObj = (DeepProtoType) ois.readObject(); return copyObj; } catch (Exception e) { e.printStackTrace(); return null; }finally { //关闭流 try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (Exception e2) { System.out.println(e2.getMessage()); } } } } |||||||| public class Client { public static void main(String[] args) throws CloneNotSupportedException { DeepProtoType p = new DeepProtoType(); p.name = \"宋江\"; p.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\"); //方式1 完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.clone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p2.name=\" + p2.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode()); //方式2 完成深拷贝 DeepProtoType p3 = (DeepProtoType) p.deepClone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p3.name=\" + p3.name + \"p3.deepCloneableTarget=\" + p3.deepCloneableTarget.hashCode()); } } 建造者模式项目盖房需求： 需要建房子：打桩、砌墙、封顶 有普通房、高楼、别墅各种房子，但是要求不要相同 传统方式 分析 传统方式有点比较好理解，简单易操作 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，这种设计方案，把产品（即：房子）和创建产品的过程（即：建造房子流程）封装在一起，耦合性增强 解决方案：将产品和产品建造过程解耦 =&gt;建造者模式 public abstract class AbstractHouse { //打地基 public abstract void buildBasic(); //砌墙 public abstract void buildWalls(); //封顶 public abstract void roofed(); public void build() { buildBasic(); buildWalls(); roofed(); } } ----------- public class CommonHouse extends AbstractHouse{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙 \"); } @Override public void roofed() { System.out.println(\" 普通房子封顶 \"); } } ------------- public class Client { public static void main(String[] args) { CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); } } 建造者模式基本介绍 建造者模式，又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不用表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder(抽象建造者) ：创建一个Product对象的各个部件指定的接口/抽象类。 ConcreteBulder(具体建造者) : 继承/实现接口，构建和搭配各个部件。 Director(指挥者) ： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离客户与对象的生产过程。二是：负责控制产品对象的生产过程 建造者模式的注意事项： 客户端(Client)不必知道产品内容组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则” 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类实现这种变化，导致系统变得很庞大，这时候需要考虑是否选择建造者模式 抽象工厂模式和建造者模式区别 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 //产品-&gt;Product public class House { private String basic; private String wall; private String roofed; public String getBasic() { return basic; } public void setBasic(String basic) { this.basic = basic; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } // 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); //将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造房子好， 将产品(房子) 返回 public House buildHouse() { return house; } } //继承抽象 public class CommonHouse extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基5米 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙10cm \"); } @Override public void roofed() { System.out.println(\" 普通房子屋顶 \"); } } public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 高楼的打地基100米 \"); } @Override public void buildWalls() { System.out.println(\" 高楼的砌墙20cm \"); } @Override public void roofed() { System.out.println(\" 高楼的透明屋顶 \"); } } //指挥者，这里去指定制作流程，返回产品 public class HouseDirector { HouseBuilder houseBuilder = null; //构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //通过setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } //client public class Client { public static void main(String[] args) { //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); System.out.println(\"-------------\"); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品(高楼) houseDirector.constructHouse(); } } 适配器模式基本介绍 适配器模式将某个类的接口 转换成客户端期望的另一个借口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(wrapper) 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 工作原理 适配器模式：将一个类的接口转换成另一种接口。让原本接口不兼容的类可以兼容 从用户的角度看不到被适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户受到反馈结果，感觉只是和目标接口交互，如图 适配器模式的注意事项 三种命名方式，是根据【被适配器】src是以怎样的形式给【适配器】Adapter（在Adapter里的形式）来命名的 类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现 Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作 类适配器模式基本介绍 先有Adapter类（适配器），通过继承被适配者(src类)，实现目标类(dst类)接口，完成src &gt; dst 的适配 应用实例： 充电器本身相当于适配器(Adapter)，插口220V交流电相当于src(即被适配者)，我们的目标(dst)即转换成5v直流电，能够给电器充电 类适配器注意事项 Java是单继承机制，所以类适配器需要继承src类这点算是一个缺点，因为这要求dst必须是接口，有一定的局限性。 src类的方法在Adapter中都会暴露出来，也增加了使用的成本。 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 //被适配的类 public class Voltage220V { //输出220V的电压 public int output220v() { int src =220; System.out.println(\"电压=\" + src + \"伏\"); return src; } } //适配接口 public interface IVoltage5V { public int output5V(); } //适配器类 public class VoltageAdapter extends Voltage220V implements IVoltage5V{ @Override public int output5V() { //获取到220V电压 int srcV = output220v(); int dstV = srcV / 44;//转成 5v return dstV; } } public class Phone { //充电 public void charging(IVoltage5V iVoltage5V) { if (iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V, 可以充电~~\"); } else if (iVoltage5V.output5V() &gt; 5) { System.out.println(\"电压大于5V, 不能充电~~\"); } } } //main public class Client { public static void main(String[] args) { System.out.println(\" === 类适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } 对象适配器模式 基本介绍 基本思路和类的适配器模式相同，只是将适配器(Adapter类)作修改，不是继承（被适配器）src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现适配接口(dst类接口)，完成src-&gt;dst的适配 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。 对象适配器模式是适配器模式常用的一种 应用实例： 充电器问题，只需要修改适配器即可 //适配器类 public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; // 关联关系-聚合 //通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) { this.voltage220V = voltage220v; } @Override public int output5V() { int dst = 0; if(null != voltage220V) { int src = voltage220V.output220V();//获取220V 电压 System.out.println(\"使用对象适配器，进行适配~~\"); dst = src / 44; System.out.println(\"适配完成，输出的电压为=\" + dst); } return dst; } } public class Client { public static void main(String[] args) { System.out.println(\" === 对象适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); } } 对象适配器模式注意事项 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合同复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须接口。 使用成本更低、更灵活。 接口适配器模式 适配器模式或缺省适配器模式 当不需要全部实现接口提供的方法时，可先设计一个抽象实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该对象类的子类可有选择地覆盖父类的某些方法来实现需求。 适用于一个接口不想使用其所有的方法的情况、 应用实例 Android中的属性动画ValueAnimator类可以通过addListener（AnimatorListener listener）方法添加监听器，常规写法如下 有时候不想实现Animator.AnimatorListener接口的全部方法，我们只想监听onAnimationStart，我们会如下写： AnimatorListenerAdapter类，就是一个接口适配器，代码如下，它空实现了Animator.AnimatorListener类（src）的所有方法 AnimatorListener是一个接口 程序里的匿名内部类就是Listener具体实现类 案例说明 public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } //在AbsAdapter 我们将 Interface4 的方法进行默认实现 public class AbsAdapter implements Interface4{ //默认实现 @Override public void m1() { } @Override public void m2() { } @Override public void m3() { } @Override public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter(){ //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(\"使用了m1的方法\"); } }; absAdapter.m1(); } } 桥接模式应用实例 对不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网、打电话等） 传统方式 问题分析： 扩展性问题（类爆炸）：如果再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本，所以用桥接模式 桥接模式 基本介绍 桥接模式(Bridge模式)：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。 是一种结构型模设计模式 Bridge模式基于类的最小设计原则，通过使用封装、聚合以及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。 桥接模式注意事项 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计维度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。 桥接模式的其他应用场景 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 常见的应用场景： -JDBC驱动程序 -银行转账系统 转账分类：网上转账，柜台转账、AMT转账 转账用户类型：普通用户，银卡用户，金卡用户.. -消息管理 消息类型：即时消息，延时消息 消息分类：手机短信，邮件消息，QQ消息 //接口 public interface Brand { void open(); void close(); void call(); } public class XiaoMi implements Brand { @Override public void open() { System.out.println(\" 小米手机开机 \"); } @Override public void close() { System.out.println(\" 小米手机关机 \"); } @Override public void call() { System.out.println(\" 小米手机打电话 \"); } } public abstract class Phone { //组合品牌 private Brand brand; //构造器 public Phone(Brand brand) { this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { brand.close(); } protected void call() { brand.call(); } } //折叠式手机类，继承 抽象类 Phone public class FoldedPhone extends Phone{ //构造器 public FoldedPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 折叠样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 折叠样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 折叠样式手机 \"); } } public class UpRightPhone extends Phone{ //构造器 public UpRightPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 直立样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 直立样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 直立样式手机 \"); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"=======================\"); Phone phone2 = new UpRightPhone(new XiaoMi()); phone2.open(); phone2.call(); phone2.close(); } } 装饰者模式订单项目 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(没事咖啡)、Decaf（无因咖啡） 调料：Milk、Soy（豆浆）、Chocolate 要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。 传统方式 方案1 Drink是一个抽象类，表示饮料。 des就是对咖啡的描述，比如咖啡的名字 cost()方法就是计算费用，Drink类中做成一个抽象方法 Decaf就是单品咖啡，继承Drink，并实现cost Espress&amp;&amp;Milk就是单品咖啡+调料，这个组合很多 问题：这种设计会导致有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸。 方案2 方案2可以控制类的数量，不至于造成很多的类 在增加或者删除调料种类时，代码的维护量很大 考虑到用户可以添加多份调料时，可以将hasMilk 返回一个对应int 考虑用装饰者模式 装饰者模式 装饰者模式定义 装饰者模式：动态的将新功能附加到对象上，在对象功能扩展方面，它比继承更加有弹性，装饰者模式也体现了开闭原则(OCP) 这里提到的动态地将新功能附加到对象和ocp原则，在后面的应用实例上面会以代码的形式体现 装饰者模式原理 装饰者模式设计咖啡 public abstract class Drink { public String des;//描述 private float price =0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } //计算费用的抽象方法 //子类来实现 public abstract float cost(); } public class Coffee extends Drink{ @Override public float cost() { return super.getPrice(); } } public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\" shortblack \"); setPrice(4.0f); } } public class DeCaf extends Coffee{ public DeCaf() { setDes(\" 无因咖啡 \"); setPrice(1.0f); } } public class Espresso extends Coffee{ public Espresso() { setDes(\" 意大利咖啡 \"); setPrice(6.0f); } } public class LongBlack extends Coffee{ public LongBlack() { setDes(\" longblack \"); setPrice(5.0f); } } public class Decorator extends Drink{ private Drink obj; public Decorator(Drink obj) { //组合 this.obj = obj; } @Override public float cost() { // getPrice 自己价格 return super.getPrice() + obj.cost() ; } @Override public String getDes() { // obj.getDes() 输出被装饰者的信息 return des + \" \" + getPrice() + \" &amp;&amp; \" + obj.getDes(); } } //具体的Decorator， 这里就是调味品 public class Chocolate extends Decorator{ public Chocolate(Drink obj) { super(obj); setDes(\" 巧克力 \"); setPrice(3.0f); // 调味品 的价格 } } public class Milk extends Decorator{ public Milk(Drink obj) { super(obj); setDes(\" 牛奶 \"); setPrice(2.0f); } } public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); setDes(\" 豆浆 \"); setPrice(1.5f); } } public class CoffeeBar { public static void main(String[] args) { // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用1=\" + order.cost()); System.out.println(\"描述=\" + order.getDes()); // 2. order 加入一份牛奶 order = new Milk(order); System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入一份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入2份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes()); System.out.println(\"===========================\"); Drink order2 = new DeCaf(); System.out.println(\"order2 无因咖啡 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes()); order2 = new Milk(order2); System.out.println(\"order2 无因咖啡 加入一份牛奶 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes()); } } 组合模式 学校院系展示需求 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，如图： 传统方式 传统方式解决学院院系展示存在的问题分析 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现管理的操作，比如学院、系的添加，删除，遍历等。 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承关系，而是一种树形结构，可以更好的实现管理操作。 =&gt;组合模式 组合模式 基本介绍 组合模式（Composite Pattern），又叫部分整理模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 这种类型的./设计模式属于结构型模式。 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象 组合模式原理类图 对原理机构图的说明（即：组合模式的角色以及职责） Component：这是组合中对象生命接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component 子部件，Component可以是抽象类或者接口 Leaf：在组合中表示叶子节点，叶子节点没有子节点。 Composite：非叶子节点，用于存储子部件，在Component接口实现子部件的相关操作，比如增加（add）,删除。 组合模式解决学校院系展示的应用实例 应用实例要求： 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。 思路分析图解（类图） 代码实现","categories":[],"tags":[]},{"title":"shopFM","slug":"shopFM","date":"2022-02-14T14:48:55.000Z","updated":"2022-02-14T15:29:54.078Z","comments":true,"path":"posts/shopfm/","link":"","permalink":"https://dahammer666.github.io/posts/shopfm/","excerpt":"","text":"一、项目介绍1.1 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.2 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.2.1 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、数据库设计 4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、设计及实现—用户管理 6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息 14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper） 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现微信支付 为商家提供代理收款服务 1.微信支付业务-商户需要注册微信支付业务 商户编号：3454563 商户账号：23435 商户编号appID： werselfjldsjhtoieiurt0 商户密钥：sdfsdlkfjdslkjfFGFGDSRTG89 2. 微信支付业务-商户注册微信支付业务 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1导入微信支付Maven依赖 wxpay的maven依赖生成 &lt;!-- https://mvnrepository.com/artifact/com.github.wxpay/wxpay-sdk --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类： 创建一类，实现WxPayConfig接口 重写三分方法，分别设置AppID\\商户ID\\商户密钥 package com.qfedu.fmmall.config; import com.github.wxpay.sdk.WXPayConfig; import java.io.InputStream; public class MyPayConfig implements WXPayConfig { //商户账号 @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } //商户appID @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } //商户的密钥 @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.2和微信的接口进行相关的参数设置和获取微信支付链接2.21创建自己的url,PayController类：package com.qfedu.fmmall.controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/pay\") public class PayController { @PostMapping(\"/success\") public void success(){ } } 2.22添加订单快照成功生成支付链接必须设置的配置参数： // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPay; import com.qfedu.fmmall.config.MyPayConfig; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultStatus; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @CrossOrigin @RequestMapping(\"/order\") @Api(value = \"提供订单相关的接口\",tags = \"订单管理\") public class OrderController { @Autowired private OrderService orderService; @PostMapping(\"/add/{cids}\") public ResultVO add(@PathVariable(\"cids\") List&lt;Integer&gt; cids, @RequestBody Orders orders){ ResultVO resultVO=null; // 测试用的OrderId try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, orders); String orderId=orderInfo.get(\"orderId\"); // 订单快照创建成功，申请支付链接 HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;(); // 设置当前订单信息 data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId);//使用当前用户订单编号作为当前支付交易的交易编号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\", orders.getActualAmount()+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\");//交易类型 // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); WXPay wxPay=new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); // 把微信支付平台生成的链接获取到 orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO=new ResultVO(ResultStatus.OK,\"提交订单成功！\",orderInfo); System.out.println(resp); // code_url -&gt; weixin://wxpay/bizpayurl?pr=Iv5Fsq6zz } catch (SQLException e) { resultVO= new ResultVO(ResultStatus.NO,\"下单失败\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } }","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2022-02-14T13:21:33.000Z","updated":"2022-02-15T09:12:43.166Z","comments":true,"path":"posts/computermanage/","link":"","permalink":"https://dahammer666.github.io/posts/computermanage/","excerpt":"","text":"一、计算机系统体系结构术语体系结构的三种用法 指令集体系结构（ISA） ​ 描述了程序员看到的计算机的抽象视图，并且定义了汇编语言和编程模型。之所以说它是抽象的，是因为它并没有考虑计算机的实现。 微体系结构（具体实现） ​ 描述了一种指令集体系结构的实现方式。微体系结构关注计算机的内部设计。 系统体系结构 ​ 关注包括处理器、存储器、总线和外设在内的整个系统。 计算机系统体系结构所涉及的内容 1.1 什么是计算机体系结构 计算机系统包括读取并执行程序的中央处理单元（Central processing unit,CPU），保存程序和数据的存储器，以及输入输出子系统，这些子系统会使CPU与显示器、打印机等外部设备之间的通信变得更加容易。 计算机中实际执行程序的部分叫做CPU，或者更简单地被称作处理器。微处理器则是在单个硅片上实现的CPU。围绕着微处理器构建的计算机被称作微机。 尽管CPU是计算机的核心，计算机的性能既取决于CPU，也取决于其他子系统的性能。如果不能高效进行数据传输，仅仅提高CPU的性能是毫无意义的。 简单通用计算机结构 1.1.1 简单通用计算机结构 信息（即程序和数据）保存在存储器中，为了实现不同的目标，计算机会使用不同类型的存储器，如Cache、主存、辅存等多个存储层次，大多数处理器都在CPU内集成了片上Cache。 Cache是存放常用数据的高速、专用存储器。主存中存放了大量的工作数据。辅存是指磁盘和CD-ROM，能够存储海量数据。 组成计算机的各个子系统通过总线连接在一起，数据通过总线从计算机中的一个位置传递到另一个位置。 可编程计算机接收两种类型的输入：要处理的数据，以及要如何处理输入数据的程序。程序不过是计算机所执行的完成给定任务的操作序列。 数字计算机的结构，可以被分为两部分：中央处理单元和存储器系统。CPU读程序并完成程序指定的操作。存储器系统保存两类信息：程序，程序处理或产生的数据。 寄存器是CPU内部用来存放数据的存储单元。 时钟提供了脉冲流，所有内部操作都在时钟脉冲的触发下进行。时钟频率是决定计算机速度的一个因素。 1.1.2 程序执行的过程 描述了程序的执行过程： 从存储器中读出一条Z=X+Y的指令，将其发送给解释单元，解释单元产生控制信号，驱动这条指令的执行。假定这个程序的功能是从存储器读出两个数据（X和Y），将它们相加，然后写回存储器。 要执行这个程序，CPU必须首先从存储器中取出一条指令，在CPU分析或解码这条指令后，从存储器中读出这条指令所需的所有数据。第一条指令，LOAD X，从存储器中读出变量X的值，并将它暂存在寄存器中。第二条指令，LOAD Y，从存储器中读出变量Y的值，并保存在另一个寄存器中。第三条指令，Z=X+Y，将两个寄存器的内容相加，并将结果保存在第三个寄存器中。第四条指令，STORE Z，将加法的结果写回存储单元Z。 1.1.3 计算机指令 尽管计算机能够执行上百种不同指令，但下面的**6条基本指令(汇编语言)**可以将所有计算机指令进行分类： MOV A, B 将B的值复制到ALOAD A, B 将存储单元B的值复制到寄存器A中STORE A, B 将寄存器B的值复制到存储单元A中ADD A, B A与B相加，结果保存到A中TEST A 测试A的值是否为0BEQ Z 若最后一次测试结果为TRUE，执行地址Z处的代码 ， 否则继续执行 1.2 体系结构和组成1.2.1 计算机体系结构 计算机体系结构含有结构（structure）的意思，描述了一些与计算机组成方式有关的内容。之所以定义计算机体系结构，是因为不同的用户会从完全不同的角度看待计算机。计算机体系结构通常被认为是程序员视角中的计算机。程序员所看到的是计算机的抽象视图，计算机的实际硬件和实现都被隐藏起来了。这个抽象视图现在通常被称作指令集体系结构（instruction setarchitecture，ISA）。 1.2.2 计算机组成 计算机组成表示其体系结构的具体实现。计算机组成是计算机体系结构的实例化（即将抽象变为具体） 本书用术语“体系结构”代表计算机的抽象指令集体系结构（它的指令集），用术语“组成”代表计算机的实际硬件实现。 1.2.3 寄存器 寄存器是用来存放一个单位的数据或字数据的存储单元。寄存器通常用它所保存数据的位数来描述，典型的有8位、16位、32位和64位。 寄存器与存储器中的字存储单元没有本质区别。二者的实际差别在于，寄存器位于CPU内，它的访问速度远远快于访问CPU外的存储器。 1.2.4 机器码&amp;汇编语言&amp;高级语言 计算机上执行的代码表示为二进制0和1组成的串，被称作机器码。每种计算机都只能执行一种特定的机器码。 人类可读的机器码（如ADD R0,R1）叫作汇编语言。 能够在类型完全不同的计算机上运行，与底层计算机体系结构几乎没有关系的代码叫做高级语言（如C或Java等）。在执行之前，高级语言程序必须先被编译为计算机的本地机器码。 1.2.5 时钟 绝大多数数字电子电路都带有一个时钟，用以生成连续的间隔固定的电脉冲流。之所以被称作时钟，是因为可用这些电脉冲来计时或确定计算机内所有事件的顺序。如，处理器可能会在每一个时钟脉冲到来时执行一条新指令。 1.2.6 RISC和CISCRISC（精简指令集计算机）体系结构（ARM） 设计策略：是使用少量的指令完成最少的简单操作 缺点：程序设计更难，复杂指令需要用简单指令模拟 应用：ARM处理器 CISC（复杂指令集计算机）体系结构 设计策略：是使用大量的指令，包括复杂指令 优点：程序设计更容易，因为每个简单的或复杂的任务都有一条对应的指令。程序员不需要写一大堆的指令去完成复杂的任务 缺点：指令集的复杂性使得CPU和控制单元电路非常复杂 应用：英特尔公司开发的奔腾系列CPU 1.3 计算机的发展 机械计算机 -&gt; 机电式计算机 -&gt; 早期的电子计算机 -&gt; 微机和PC革命 1.3.1 摩尔定律和进步的历程 摩尔定律 ​ 是卡沃-米德于1975年根据戈登-摩尔所观察到集成电路的集成度每18个月翻一番，摩尔定律是一个经验性的观察结果。 1.3.2 乱序执行 程序中的指令必须一条接一条按照在程序中的出现的顺序执行。 有时可以通过改变指令的执行顺序提高计算机的速度。图中，指令（4）和（5）可以在任何时候执行，但指令（3）必须在指令（1）和（2）结束后执行。 1.3.3 存储技术发展 覆盖着电容的旋转的磁鼓 -&gt; 阴极射线管 -&gt;铁氧体磁芯存储器 -&gt;磁盘 -&gt; 光存储器（DVD等） 1.3.4 多媒体计算机多媒体处理（处理和存储音频/视频数据）需要很大的存储容量以及完成大量简单重复操作的实时处理声音样本的图像像素的能力。 1.4 存储程序计算机1.4.1 最大游程问题描述 ​ 十进制数串23277366664792221，其中有一些值相同的数字连续出现（如连续的2个7,4个6和3个2），我们的问题十分简单：找出最大游程，即同一个数字连续出现的最大次数。 ​ 为了简化问题，假设数串长度大于3。我们将设计一个计算机来处理图中的数串，它每次读一个数，并计算最大游程。 解决方法： ​ 从数串的左边开始逐个检查数字，在任何一个位置，都会得到两个结果之一：要么这个数与前一个相同，序列还在增长；要么这个数与上一个不同，前一个序列结束，一个新的序列开始。 对于一个数字系统，当一个特定事件（如时钟脉冲）发生时，它将从一个状态转换为另外一个状态。 图中有两个状态，分别是“在同一序列中”和“不在同一序列中”，每当从数串中读出一个新元素，都会发生状态转换。 一、如图，列出一个接一个读入数串的数字后系统状态的转换情况，状态的改变会发生在序列的第二个数字或结束序列的那个数字上。 二、如表，将这些数字组织成更容易理解的形式。最上面一行是每个数字在数串S中的位置或地址，下一行是串S中这个数字的值。第三行第一个元素是？，因为上一个元素的值是未知的。第四行统计数串中每个元素所在序列的长度,数字本身长度为1，如果相同则+1 统计数串中最大序列长度 为了方便，通过下面的符号名说明问题： i 串的当前位置 New_Digit 刚从数串中读出的数字的值 Current_Run_Value 当前序列数值 Current_Run_Length 当前序列长度 Max_Run 目前为止的最大序列长度 | 使用伪代码描述问题的操作： 读出串的第一个数字，将其称为New_Digit 将Current_Run_Value的值置为New_Digit 将Current_Run_Length的值置为1 将Max_Run的值置为1 REPEAT 读出序列中下一个数字（即read New_Digit） IF 它的值与Current_Run_Value相同 THEN Current_Run_Length = Current_Run_Length + 1 ELSE { Current_Run_Length = 1 Current_Run_Value = New_Digit } IF Current_Run_Length &gt; Max_Run THEN Max_Run = Current_Run_Length UNTIL 读出了最后一个数字 1.4.2 存储器 如图，描述了程序怎样找出保存在一个假象存储器中的数串的最大序列长度。必须强调的是，这个程序是概念上的而不是实际的。该图叫作存储器映射，展示了信息在存储器中的存放位置，存储器中的每个位置要么保存指令，要么保存数据元素。 1.4.3 寄存器传输语言 由于使用文字描述计算机的操作很不方便，使用RTL可以更加容易地定义计算机内发生的操作。 区分存储单元的地址和它的内容非常重要。在RTL语言中，用方括号[ ]表示存储单元的内容，如 [15] = Max_Run 含义是：地址为15的存储单元保存了变量Max_Run的值 左箭头符号表示数据传送操作，如 [15]&lt;–[15] + 1 含义是：将地址为15的存储单元的值加1，并将结果写回地址为15的存储单元考虑下面3个RTL表达式：[20] = 5[20]&lt;–6[20]&lt;–[6] 1.4.4 存储系统 如图，描述了存储系统的组成 处理器将一个放在地址总线上的地址以及一个用于选择读操作或写操作（也被称为读或写周期）的控制信号发送给存储器。 在读周期中，存储器将数据放在数据总线上供CPU读取。 写周期中，放在数据总线上的数据被写入存储器。 信息进入或离开存储器的位置叫作端口。 1.4.5 存储程序的概念 下面的伪代码描述了存储程序计算机的基本操作： 存储程序计算机 程序计数器指向存储器中的第一条指令 REPEAT 从程序计数器所指的存储单元中读出指令 修改程序计数器，使之指向下一条指令 将从存储器中取出的指令解码 执行指令 FOREVEREnd 从存储器中取出每条指令都需要进行一次访存操作（即读存储器）。可以用下面的伪代码描述“执行指令”这一动作： ​ 执行指令​ IF 指令需要使用数据​ THEN 从存储器中读这个数​ END_IF​ 完成指令定义的操作​ IF 指令要将数据写回存储器​ THEN 将数据写回存储器​ END_IF​ End 上面的动作序列用C语言描述： 执行一条指令需要至少两次访存，第一次访存是读取指令，第二次访存要 么从存储器读出指令需要的数据，要么将它之前的指令产生的或修改过的 数据写回存储器。 1.4.6 指令格式 存储程序计算机的一种直观合理的指令格式可以用下面的形式表示： Operation表示要执行的指令的动作Address1、Address2和Address3分别是3个操作数在存储器中的位置。在这条指令中，操作数为数据的地址，而不是数据本身。 ADD P,Q,R是一条典型的三操作数指令，P、Q、R是三个存储单元地址的符号名。这个三操作数指令格式用RTL表示为： 如图，描述了一条指令的执行过程，一共需要4次访存（即一次取指令，两次取两个源操作数，一次保存结果） 如图，描述了指令的4个字段与CPU、存储器以及指令的执行方式之间的关系： 1.4.7 两地址指令 有些计算机实现了两地址指令，其格式为： Address2为源操作数，Address1既是源操作数也是目的操作数。 指令ADD P,Q的RTL定义为： 两地址指令会破坏它的一个操作数，也就是说，会用结果替换源操作数P，本书大部分章节约定两地址指令格式为： 在实际计算机中，一般不允许同一条指令中使用两个存储地址，大多数计算机都规定一个地址是存储器地址，另一个地址是寄存器。 1.4.8 单地址指令有些计算机实现单地址指令，其格式为： 指令中只提供了一个操作数地址，而指令却需要至少两个地址，处理器不得不使用一个不需要显示地址的第二操作数，第二个操作数来自CPU内一个叫累加器（accumulator）的寄存器。 如图，描述了一条单操作数指令执行过程中的信息流，操作结果将一直保存在寄存器中，直到另一条指令将它送入存储器。实现P = Q + R： 1.4.9 计算机分类可以按照计算机的指令处理数据的方式对计算机分类 存储器-存储器型：一条指令能够从存储器中读出源操作数，对数据完成某个操作，并将结果保存在存储器中 寄存器-存储器型：能够处理两个数据，其中一个位于存储器中，另一个位于寄存器中，结果要么被写回存储器，要么被写回寄存器，如Intel IA32 CPU体系结构 寄存器-寄存器型：只能对寄存器中的内容进行操作，这些计算机必须通过LOAD指令将数据读入寄存器并使用STORE指令将数据从寄存器送回存储器。由于LOAD 和STORE操作是仅有的存储器访问指令，这些计算机也被称为load/store 型计算机，如ARM和MIPS CPU体系结构 1.6 计算机系统概览1.6.1存储层次由于CPU与存储器的性能之间的差距不断加大，通过在使用数据之前将它们从存储器中取出来消除相对慢速的存储器的影响，以降低延迟。 如图，描述了经典的存储层次图，展示了计算机中存储部件的类型、速度以及在PC机中的典型容量： 寄存器：存放处理器的工作数据 Cache：缓存常用数据的快速存储器 (内存)DRAM：存放工作数据 硬盘：保存程序和数据， 注意，硬盘的容量是寄存器 的4000万倍，但速度却比寄存器 慢2000万倍！ 1.6.2 Cache高速缓存 经常被用到的数据保存在Cache中，Cache的访问时间比主存短得多。Cache保存主存中经常使用的数据的副本。Cache系统与计算机的地址总线和数据总线相连，监听CPU与存储器之间的事务。 只要Cache注意到CPU发出的地址与它保存的某个数据元素地址相同，就把这个数据发送个CPU，而不会去主存中取数据。 一级缓存（集成在CPU中）&amp;二级缓存&amp;三级缓存 1.6.3 DRAM 存放正在执行的程序的主存，是由一种叫作动态随机访问存储器（Dynamic Random Access Memory,DRAM）的易失性半导体存储器构成的立即存取存储器。 1.6.4 总线 总线将计算机的两个或多个功能单元连接在一起并允许它们相互交换数据。总线还将计算机与外设连接在一起。 如图，描述了一个没有总线的假象系统的结构，节点之间的互连复杂并且凌乱，若要添加一个新单元，必须在新单元与它所连接的每个单元之间增加一条新连接： | 如图，展示了通过公共总线将所有单元连接在一起的好处，此时只有一条高速数据通路，每个单元通过一个接口与这条通路相连： || ———————————————————— || || 缺点：每次只有唯一一个设备能够与其它设备通信，因为这里只有一条信息通路。如果两个设备同时请求使用总线，它们不得不去竞争总线的控制权。用术语仲裁来描述多个设备竞争同一资源的过程。 | 总线术语 宽度 一般用并行数据通路的数量来定义总线的宽度。一条64位宽的总线一次能传送64位（8个字节）信息。 带宽 总线带宽是衡量信息在总线上的传输速率的一项指标。带宽的单位要么是B/s，要么b/s。在保持数据传输率不变的情况下增加总线宽度，可以提高带宽。 延迟 延迟是从发出数据传输请求到实际数据传输的时间间隔。总线延迟通常包括传输开始之前进行总线仲裁的时间。 多总线系统 | 现代计算机中有多条总线，包括片内总线、功能单元间（如CPU和存储器间）的总线以及总线间的总线，如图描述了一个多总线系统： （1）多总线运行并发操作（2）总线可能具有完全不同的特点和操作速度 || ———————————————————— || |","categories":[],"tags":[]},{"title":"Jwt","slug":"Jwt","date":"2022-02-04T08:53:53.000Z","updated":"2022-02-04T09:05:34.753Z","comments":true,"path":"posts/jwt/","link":"","permalink":"https://dahammer666.github.io/posts/jwt/","excerpt":"","text":"六、设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } }","categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"}],"tags":[]},{"title":"Test","slug":"Test","date":"2022-01-29T07:03:58.000Z","updated":"2022-01-29T14:12:36.958Z","comments":true,"path":"posts/784dd132/","link":"","permalink":"https://dahammer666.github.io/posts/784dd132/","excerpt":"","text":"1 2","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2022-01-29T04:02:19.000Z","updated":"2022-01-29T14:24:08.165Z","comments":true,"path":"posts/c0add594/","link":"","permalink":"https://dahammer666.github.io/posts/c0add594/","excerpt":"","text":"一、VUE简介 项目结构经历的三个阶段 后端MVC：它是单体结构，流程控制是由后端控制器来完成的 前端MVC：前后端分离开发，后端只负责接收响应请求 MVVM：前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据的数据设置“VM”，HTML从vm中取值。 M model 数据模型，指的是从后端接口返回的数据 (前端发送请求，后端接收数据) V view 视图（HTML） VM ViewModel（js） 视图模型，数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据。 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据{{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str1(){ } str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为`@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换 十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[],"tags":[]},{"title":"测试博客","slug":"测试博客","date":"2022-01-27T09:55:34.000Z","updated":"2022-02-04T09:02:00.036Z","comments":true,"path":"posts/d9407122/","link":"","permalink":"https://dahammer666.github.io/posts/d9407122/","excerpt":"","text":"TT title: 博客与博主comments: truetoc: truecover: https://s4.ax1x.com/2022/01/28/7x30g0.pngcategories: 生活tags: 想法abbrlink: 1date: 2021-5-27 21:00:00 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true 安装插件: npm install https://github.com/CodeFalling/hexo-asset-image -- save 运行hexo n \"XXXXXX\", 生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。 添加图片: 在想添加的位置写入![](图片名字.图片格式),例如![](1.png)。图片的路径和你写入的路径一致。 hexo-abbrlink导致图片不能显示 在安装了hexo-abbrlink后博客图片无法正常显示（用的是hexo-asset-image） 之前_config.yml中配置如下 permalink: archives/:abbrlink.html 在hexo g后时观察到，文章中的连接被重定向的位置，与图片在public中的文件位置不相符解决：根据参考重写_config.yml permalink: posts/:abbrlink/ 删除文件命令行 rm -rf xxx （xxx - 文件名）","categories":[{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}],"categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"},{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}