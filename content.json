{"meta":{"title":"TT","subtitle":"DaChui","description":"多搞学习就好了","author":"DaChui","url":"https://dahammer666.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-01-29T04:58:56.000Z","updated":"2022-01-29T03:28:32.892Z","comments":false,"path":"about/index.html","permalink":"https://dahammer666.github.io/about/index.html","excerpt":"","text":"TT“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我座右铭：钱难赚，屎难吃"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://dahammer666.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://dahammer666.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://dahammer666.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://dahammer666.github.io/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://dahammer666.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://dahammer666.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T03:48:51.191Z","updated":"2022-01-29T03:48:51.191Z","comments":false,"path":"List/gallery/index.html","permalink":"https://dahammer666.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片 TT 關於head的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://dahammer666.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-01-28T06:56:56.575Z","comments":false,"path":"List/music/index.html","permalink":"https://dahammer666.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://dahammer666.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T14:56:13.000Z","updated":"2022-01-29T03:43:19.826Z","comments":false,"path":"List/gallery/head/index.html","permalink":"https://dahammer666.github.io/List/gallery/head/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://dahammer666.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"javaBase","slug":"javaBase","date":"2022-02-17T08:03:11.000Z","updated":"2022-02-21T10:34:10.448Z","comments":true,"path":"posts/javabase/","link":"","permalink":"https://dahammer666.github.io/posts/javabase/","excerpt":"","text":"一、javaBase1.1 Java特性 简单性 面向对象 可移植性（跨平台） 高性能 分布式 动态性（反射） 多线程 安全性（安全） 健壮性 1.2 Java三大版本 Java SE: 标准版（桌面程序） Java ME: 嵌入式开发（手机、小家电） Java EE: E企业级开发（web端，服务器开发） 1.3 JDK、JRE、JVM是什么？ jdk:在jre之上扩充一些开发工具，让我们开发者使用的 jre:运行时环境，只要安装了jre，就可以运行我们的java程序了、一般我们只需要下载安装jadk即可，因为jdk包含了jre。 jvm:java虚拟机，把它当做一种规范，可以用软件来实现，也可以用硬件来实现。它就相当于在所有的操作系统上模拟了一个小小的cpu，去处理我们java相关的东西。java的跨平台核心是使用了java虚拟机，在不同的操作系统上安装jvm。 Java是大小写敏感的语言 1.4 Java程序的运行机制编译型 ​ 把整个程序编译 解释性 ​ 给出命令，执行语句（网页js,便解释，边执行） java属于上面两种类型，先编译，再解释 二、java基础语法2.1 注释注释并不会被执行，是写给我们写代码的人看的 单行注释 //单行注释 多行注释 /* 多行注释 */ 文档注释 /** * @Description Hello World * @Autor: Dahammer */ 2.2 标识符Java 所有的组成部分都需要名字。类名、变量名、以及方法名都被成为标识符。所有的标识符都应该以A-Z或者a-z、美元符号$、下划线_开始 2.3 数据类型强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义才能使用。 弱类型语言： JS 强类型语言安全，但是速度慢！ java是一种强类型语言，要求十分严格。 基本数据类型 整数型：byte(1字节)、short(2字节)、int(4字节)、long(8字节)long类型要在后面加上L，（可以省略，超出int的范围时需要加L） 浮点型：float(4字节)、double(8字节)float类型 要在数字后面加f 字符型：char（2字节） 布尔型：boolean（1位）是非对错 引用数据类型 除了基本数据类型之外的，都叫引用类型。 类 接口 数组 枚举 2.4 什么是字节 位(bit): 是计算机内部数据，存储的最小单位.11001100是一哥八位二进制 字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示；1B（byte字节）=8bit(位) 字符：是指计算机中使用的字母、数字和符号 常见的单位换算 1bit 表示 1位 1byte 表示一哥字节 1B = 8bit 1024b = 1kb 1024M = 1G 1024G = 1TB 2.5 进制问题 进制说明 二进制： 0b 十进制：默认 八进制：0逢八进1 十六进制：0X逢十六进1 银行业务用什么表示？用BigDecimal类 数学工具类 不能使用浮点数。 float:浮点数是有限的射入误差，大约接近但不等于 double: 最好完全使用浮点数进行比较 public static void main(String[] args){ int i1 =10; int i2 = 010; int i3 = 0x10; System.out.println(i1); //10 System.out.println(i2); //8 System.out.println(i3); //16 float f = 0.1f //0.1 double d = 1.0/10; //0.1 System.out.println( f == d); //false } 字符扩展 char c1 = 'a'; char c2 = '中'; System.out.println(c1); System.out.println((int)c1);//97 强制转换 System.out.println(c2); System.out.println((int)c2); //20013 所有的字符本质还是数学 编码问题 Unicode表： (97 = a, 65 =A)编码占了两个字节 转义字符 \\t制表符 \\n换行 2.6 类型转换 通过查看byte包装类型得到：byte 最大值信息 public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。 低—–&gt;高 byte、short、char、int、float、long、double 运算中，不同类型的数据先转换为同一类型，然后进行运算。（小数优先级高于整数） 强制类型转换 高到低 int i =128; double d = i; System.out.println(i); //128 System.out.println(d); //128.0 总结： 不能对布尔类型进行转换。 不能把对象类型转换为不相干的类型 在吧高容量转换为低容量的时候，需要强制转换。 转换的时候可能存在内存溢出，或者精度问题。 2.7 变量Java是一门强类型语言，每一个变量必须声明其类型。 Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。 格式： ​ 数据类型 变量名 值; 作用域： ​ 局部变量：类中方法内：局部变量必须声明和赋值 ​ 成员变量：类中方法外：示例变量从属于对象，如果不自行初始化，这个类型的默认值：0.0.0/布尔值默认是：false、除了基本类型，其余的默认是null ​ 2.8 常量常量：初始化后不能变动的值 final 数据类型 常量名 = 常量值 final double PI = 3.14; 修饰符不存在先后顺序。 2.9运算符 算数运算符：+ 、-、*、/、++、– 赋值运算符：= 关系运算符：==、！=、&lt;、&gt;、&lt;=、&gt;=、instanceof 逻辑运算符：&amp;&amp; || ! 位运算符：&amp; 、|、 ^、 &gt;&gt;、 &lt;&lt;、 &gt;&gt;&gt; 条件运算符：? 扩展赋值运算符：+=、-+、*=、/= 一元运算符 自增 ++ int a = 3; int b = a++; //++在后，先赋值，后+1 int c = ++a; //++在前，先+1，再赋值 System.out.println(a); //5 System.out.println(b); //3 System.out.println(c); //5 //自减 -- 逻辑运算符 与 and &amp;&amp; 或 or 非 取反 位运算 /* A = 0011 1100 B = 0000 1101 ------------------------------------------------------- 拿上面的数字跟下面的去比较 A&amp;B 如果两个都是1，才为1 = 0000 1100 A|B 如果对应为都是0，结果为0，否则是1 = 0011 1101 A^B 如果如果两个相同，则为0，否则为1 = 0011 0001 ~B 取反，如果是1则为0，如果是0则为1 = 1111 0010 */ 面试题：2 * 8 = 怎么计算最快？ /* 2*8=16 2*2*2*2 效率极高 0000 0000 0 0000 0001 1 0000 0010 2 0000 0011 3 0000 0100 4 0000 1000 8 0001 0000 16 &lt;&lt; 左移 把数字 * 2 &gt;&gt; 右移 把数字 / 2 */ System.out.println(2&lt;&lt;3);//16 面试题： int a = 10; int b = 20; System.out.println(\"\"+a+b);//1020 System.out.println(a+b+\"\");//30 三元运算符 x ? y : z 如果x == ture,则结果为y，否则为z String flag = score &lt; 60 ? \"不及格\" : \"及格\"; System.out.println(flag);//及格 2.10 包机制为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。 包语句的语法格式为： package pgk1[.pck2[.pck3]]; package 必须放在类中所有语句的最上面（第一行代码） 导包 import pgk1[.pck2[.pck3]].(classname | *); 三、java流程控制3.1 Scanner 类通过scanner 类的next() 与nextLine()方法获取输入的字符串，在读取我们一般需要使用hashNext() 与 hasNextLine() 判断是否还有输入的数据 Scanner sc = new Scanner(System.in); public static void main(String[] args) { //从键盘接收数据 Scanner sc = new Scanner(System.in); System.out.println(\"使用next方式接收：\"); //判断是否还有输入 if (sc.hasNext()){ //next() 只读取第一个字符串 //String str = sc.next(); //nextLine() 获取一行数据 String str = sc.nextLine(); System.out.println(\"用户输入是：\"+str); } sc.close(); } next(): 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next（）方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next（）方法不能得到有空格的不能得到有空格的字符串 nextLine() 以Enter为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符 可以获得空白。 3.2 顺序结构Java的基本结构就是顺序结构，除非特别指明，否则按照顺序一句一句执行。 语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由于若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。 3.3 选择结构​ 我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用if语句来表示。 语法 if(布尔表达式){ //如果布尔表达式为true，则进入if语句块了，执行里面代码 } if(布尔表达式){ //如果布尔表达式为true，则进入if语句块，执行里面代码 }else{ //如果布尔表达式为false，则进入else语句块，执行里面代码 } if(布尔表达式1){ //如何布尔表达式1为true }else if(布尔表达式2){ //如何布尔表达式2为true }else if(布尔表达式3){ //如何布尔表达式3为true }else{ //如果以上的表达式都不满足，则执行这里 } 3.4 switch 多选择语句switch case 语句判断一个变量和与一系列值中某个值相等，每个值称为一个分支，switch语句中的变量类型可以是： byte、short、int、或者是char 从 Java SE 7开始 switch 开始支持字符串 String 类型了 同时case 标签必须为字符串常量或字面量 case 穿透现象 swtich(expression){ case value: //语句 break;//可选 case value: //语句 break;//可选 default://可选 //语句 } 3.5 循环结构 while循环 while(布尔表达式){ //循环内容 } 只要布尔表达式为true，循环就会一直执行下去 大多数情况是会让循环停止下拉，我们需要一个让表达式失效的方式来结束循环 少部分情况需要循环一直执行，比如服务器的请求响应监听等 do..while循环 do..while 循环至少会让循环体里的语句执行一遍 while 先判断后执行 do..while x先执行后判断 for循环 for循环的执行次数在执行前就确定了 for(初始值；布尔表达式;迭代){ ​ //代码语句 } 打印99乘法 for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;= i;j++){ System.out.print(i+\"*\"+j+\"=\"+i*j+\"\\t\"); } System.out.println(); } break、continue ​ break 用于强行退出循环，不执行中循环体中剩余代码。 continue 用于终止某次循环过程，即跳过循环体尚未执行的语句，继续下一次循环 四、Java方法 java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序集合 方法包含于类或对象中 方法在程序中被创建，在其他类中被调用 设计方法的时候要保证方法的原子性，就是一个方法只完成一个功能 4.1 方法的定义：Java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法。 修饰符：修饰符，这个是可选的，告诉编译器如何调用该方法，定义该方法的访问类型 返回值类型： ​ 方法可能会有返回值，return Value Type是方法返回值的数据类型。 ​ 有些方法可能没有返回值。在这种情况下，return Value Type 是关键字void 方法名：是方法的实际名称 参数类型： 参数像一个占位符。当方法 被调用时，传值给参数这个值被称为实参或者变量 参数列表是指方法的参数类型、顺序、参数个数 参数是可选的，方法可以不包含任何参数 方法体：方法体包含具体的语句，定义该方法的功能 格式 对象名.方法名([参数]) 了解：值传递、引用传递 4.2 方法重载​ 重载就是在一个类中，有相同的函数名称，但是形参不同的函数 方法重载的规则： 方法名称必须相同 参数列表必须不同 参数个数、参数类型、参数位置排列不同等 返回值类型可以相同也可以不相同 注意：仅仅返回值类型不同不足以成为方法的重载 public int max() { return 1; } public int max(int a) { return 1; } public void max(int j, int d) { } 实现理论： ​ 方法名称相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，编译器报错. 4.3 可变参数jdk1.5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) ​ 一个方法中只能传递一个可变参数，它必须是方法的font color = blue &gt;最后一个参数。任何普通参数必须在它之前声明。 public static int max(int x,int ... a) { int[] a1 = a;//可变参数返回数组 return -1; } 4.4 递归A方法调用B方法，很容易理解 递归就是：A方法调用A方法，就是自己调用自己 递归结构包含两个部分： 递归头：什么时候不调用自身方法，如果没有头，将陷入死循环 递归体：什么时候调用自身方法 什么是阶乘？ 阶乘就是值从1乘以2乘以3乘以4一直乘到所要求的数 例如所要求的的数就是4，则阶乘式是1 * 2 * 3 * 4，得到的积是24,24就是4的阶乘。 求阶乘 public static void main(String[] args) { //求4的阶乘 System.out.println(f(4)); } public static int f(int n){ if (n == 1){ return 1; } return n * f(n-1); } 使用栈的机制 五、数组5.1 数组的定义 数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 其中，每一个数据称作一个数组元素，每一个数组元素通过一个下标来访问他们。 数组下标从0开始 5.2 数组声明和创建在类型后面加[] 或者在数组后面加[] dataType 数组名[] = new dataType[数组长度] dataType[] 数组名 = new dataType[数组长度] int[] nums = new int[10]; nums[0] = 1; nums[1] = 2; nums[2] = 3; nums[3] = 4; nums[4] = 5; nums[5] = 6; nums[6] = 7; nums[7] = 8; nums[8] = 9; nums[9] = 10; 获取数组长度 System.out.println(\"数组长度是：\"+nums.length); 数组长度是：10 5.3 Java内存分析堆 ​ 存储new 出来的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈 ​ 存放基本变量类型（会包括这个基本类型的具有数值） ​ 引用类型变量（会存放这个引用在堆里面的具体地址） 方法区 ​ 可以被所有线程共享 ​ 包含了所有的class和static变量 5.4 三种初始化 静态初始化 -创建+赋值 int[] a = {1,2,3}; 动态初始化 -包含默认初始化 int[] a = new int[3]; a[0] = 1; 动态初始化包含：数组的默认初始化 ​ 数组是引用类型。它的元素相当于类的实例变量，因此数组已经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化、 5.5 数组的四个基本特点 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的 其元素必须是相同类型，不允许出现混合类型。 数组的元素可以是任意数据类型，包括基本类型和引用类型、 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中，因此数组无论保存原始类型还是其他对象类型，数组对象本身在堆中 ArrayIndexOutOfBoundsException：数组下标越界异常！ 总结： 1. 数组是相同数据类型的有序集合 1. 数组也是对象。数组元素相当于对象的成员变量 1. 数组长度是确定的，不可改变 5.6 求数组最大值public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; int max = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] &gt; max){ max = nums[i]; } } System.out.println(\"数组的最大值是：\"+max); } 5.7 打印数组public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; for (int i : nums){ System.out.print(i+\" \"); } System.out.println(); System.out.println(\"===================\"); for (int i = 0;i&lt;nums.length;i++){ System.out.print(nums[i]+\" \"); } } 5.8 反转数组public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; for (int i = nums.length - 1; i &gt;= 0; i--) { System.out.print(nums[i] + \" \"); } } 5.9 多维数组多维数组可以看成是数组的数组。比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组 int[][] arr = new int[3][2]; 定义了一个3行2列的数组 5.10 Arrays 类 数组的工具类java.utils.Arrays 由于数组对象本身没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用 Arrays 类中的方法都是static修饰的静态动作，在使用的时候可以直接使用类名，进行调用。 具备以下常用功能 给数组赋值：通过fill方法 给数组排序：通过sort方法，按升序 比较数组：通过equals方法比较数组中元素值是否相等 查找数组元素：通过binarySearch 方法对排序号的数组进行二分查找法操作 Arrays.toString实现 public static String toString(int[] a) { if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) { b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); } } 5.11 冒泡排序​ 冒泡排序无疑是最出名的排序算法之一，总共有八大排序！ ​ 冒泡排序、两层循环、外层冒泡轮数、里层依次比较。","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2022-02-15T09:35:11.000Z","updated":"2022-02-15T09:39:23.978Z","comments":true,"path":"posts/managermodel/","link":"","permalink":"https://dahammer666.github.io/posts/managermodel/","excerpt":"","text":"设计模式七大原则单一职责原则 降低类复杂度，一个类只负责一项职责。 提高类的可读性、可维护性 只要逻辑足够简单，类中的方法数量足够少，可以违反单一职责原则。 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上 依赖倒转原则 核心是面向接口编程 高层模块不应该依赖低层模块，二者都应该依赖其抽象 注意事项： 低模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好。 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里式替换原则 里式替换原则 所有引用基类的地方能够透明地使用其子类的对象 在使用继承时，遵循里式替换原则，在子类中尽量不要重写父类的方法 继承实际让两个类耦合性增强了，可通过聚合、组合、依赖解决问题 -&gt; 通用做法是：原来的父类和子类都继承了一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等 开闭原则 最基础、重要的设计原则 开：对功能的扩展开放（对提供方）；关：修改关闭（使用方） ocp: 尽量通过扩展软件实体的行为，不是通过修改已有代码 -&gt; 将父类做成抽象类，并提供一个抽象方法，让子类去继承实现。如此我们有新的种类时，只需要让新的种类继承父类，实现抽象方法即可，使用方的代码就不需要关闭。满足开闭原则 迪米特法则 最少知道原则，即一个类对自己依赖的类知道的越少越好，即降低耦合度；对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。 直接‘朋友’：每个对象都会有与其他对象有耦合关系，耦合方式很多：依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数和方法的返回值中的类为直接朋友；而出现在局部变量中的类不是直接朋友，也就是说，陌生的对象/类 不要以局部变量的形式出现在类的内部。 注意事项：迪米特法则核心是降低类之间的耦合。 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则核心思想 找出应用中需要修改的地方，把它们独立出来，跟不需要修改的代码隔离。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计 UML图 uml基本详情 是一种用于软件系统分析和设计的语言工具 uml图 用例图 静态结构图：类图、对象图、包图、组件图、部署图 动态行为图：交互图（时序图与协作图）、状态图、活动图 说明： 类图是描述类与类（对象）的静态关系，是uml图中最核心的 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。 类与类之间的关系 依赖 -&gt; 主要在类中用到了对方，他们之间就存在依赖 依赖的构成： 类的成员属性 方法的返回类型 接收的参数类型 方法中使用到 泛化：实际上就是继承关系，是依赖关系的特立。 -&gt;如果A类继承了B类，我们就能说是A和B存在泛化关系 实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例； 关联关系 关联关系实际上就是类与类之间的关系，他是依赖关系的特例。 关联具有导航性，即双向关系或者单向关系（单向一对一关系、双向一对一关系） 关系具有多重性（一对一，多对多） 聚合关系 表示整体和部分的关系，整体与部门可以分开。聚合关系是关联关系的特例；所以它具有关联的导航性（B聚合A）与多重性（多个属性聚合了A）。 组合关系 组合关系也是整体与部分的关系，但是整体与部分不能分开。 聚合和组合区别： 聚合中整体与部分能看；组合中整体与部分不能分开 public class Person{ private IDCard card;//聚合 private Head head = new Head();//组合 } public class IDCard{} public class Head{} -&gt; 如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了 ./设计模式分类 ./设计模式分为三种类型，共23种 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式、 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）。 ./设计模式介绍： 模式不是代码，是某类问题的通用解决方案。 本质上是提高软件的维护性、通用性和扩展性，并降低软件的复杂度。 单例模式-&gt; 采用方法，对某个类只能存在一个对象实例，并该类只提供一个取得其对象实例的方法（静态方法）。 单例模式八种写法 *饿汉式（静态常量）** *饿汉式（静态代码块）** 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程不安全，同步代码块） *双重检查** *静态内部类** *枚举** 饿汉式（静态常量）-&gt;应用实例： 构造器私有化 （防止其他对象/类 创建对象(new)） 类的内部创建对象 向外暴露一个静态的公共方法 getInstance 代码实现 优缺点说明： 优点：这种写法简单，在类装载的时候就完成实例化。避免了线程同步问题。 缺点：在类装载时就完成实例化，没有达到Lazy Loading（懒加载）的效果。例如：如果从未用过这个实例的话，就会造成内存的浪费。 这种方式基于classloder机制避免了多线程的同步问题，不过,instance在类装载时候就实例化了，在单例模式中大多数都是在调用getInstance方法，但是导致类装载的原因有很多种，不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化Instance就没有达到lazy loading的效果 饿汉式（静态常量）这种单例模式可用，但是可能造成内存浪费。 package com.atiguigu1.singleton; public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); System.out.println(\"instance.hasCode=\" + instance.hashCode()); System.out.println(\"instance2.hasCode=\" + instance2.hashCode()); } } class Singleton{ //1、构造器私有化，外部能New private Singleton(){ } //2、本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供一个公有的静态方法，返回实例对象 public static getInstance(){ return instance; } } 饿汉式（静态代码块）优缺点说明： 这种方式和上面饿汉式（静态常量）的方式类似，只不过将实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化的实例。优缺点和上面的一样的。 饿汉式（静态代码块）这种 单例模式可用，但是也是可能造成内存浪费。 class Singleton{ private Singleton() { } private final static Singleton instance; //在静态代码块中，创建单例对象 static { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 懒汉式（线程不安全）优缺点说明： 起到了Lazy Loading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入方法中的if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式。 结论：在实际开发中，不使用懒汉式。 //懒汉式（线程不安全） class Singleton { private static Singleton instance; private Singleton() { } //提供一个静态的共有方法，当使用该方法的时候，才去创建instance public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式（线程安全，同步方法）优缺点说明： -&gt;在静态getInstance()方法前面加 synchronized 解决了线程不安全问题 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法我们需求是只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低了。 //懒汉式（线程安全，同步方法） class Singleton { private static Singleton instance; private Singleton() { } //提供了一个静态的共有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式（线程不安全，同步代码块）-&gt; 这种港式，本事想对第四种{ 懒汉式（线程安全，同步方法）}实现方式的改进，因为同步方法效率态度，改为同步方法里面的产生实例化的代码块。 但是这种同步并不能起到线程同步的作用。跟第三种实现方式遇到的情形一致，假如一个线程进入了if(singleton == null)判断语句块中，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便回产生多个实例。不能保证线程安全。 class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } 双重检查 //双重检查 class Singleton { private static volatile Singleton instance; private Singleton() { } //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题 //同时保证了效率，推荐使用 public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { instance = new Singleton(); } } return instance; } } 优缺点说明： Double-Check概念是多线程开发中常用到的，代码中，我们进行了两次if(singleton == null)检查，可以保证线程安全。 实例化代码只用了一次，后面再次访问时，判断if(singleton == null),直接return实例化对象；延迟加载；效率较高 实际开发中，推荐使用双重检查做单例设计模式（推荐使用） 静态内部类//静态内部类 class Singleton{ private static volatile Singleton instance; //构造器私有化 private Singleton() { } //写一个静态内部类，该类中有一个静态属性Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点说明： 采用了类装载的机制来保证初始化实例时只有一个线程 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程无法进入。 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高（推荐使用） 枚举public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } enum Singleton { INSTANCE; public void sayOK(){ System.out.println(\"yyds\"); } } 优缺点说明： 借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。（推荐使用） 单例模式注意事项和细节说明 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须记住使用相应的获取对象的方法，而不是使用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等） 工厂模式 工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护。 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式) 设计模式的依赖抽象原则（不要依赖具体类） 注意： 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。（变量不要直接持有具体类的引用） 不要让类继承具体类，而是继承抽象类或者是实现interface（接口） 不要覆盖基类中已经实现的方法 Pizza项目需求： 披萨种类（GreekPizza、CheesePizza） 披萨的制作过程：prepare、bake、cut、box 完成披萨订单功能 传统方式 //Pizza实体 public abstract class Pizza { protected String name; //不同的Pizza不同的制作方法，做成一个抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \"bake\"); } public void cut() { System.out.println(name + \"cutting\"); } public void box() { System.out.println(name + \"boxing\"); } public void setName(String name) { this.name = name; } } //CheesePizza public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(\" 给制作奶酪披萨 准备原材料 \"); } } //OrderPizza pizza制作过程 public class OrderPizza { // 构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" greek披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" cheese披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } else { break; } //输出pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } //getType方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //pizza订单 public class PizzaStore { public static void main(String[] args) { new OrderPizza(); } } 传统方式的优缺点 优点是好理解，简单易操作 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者可能少修改代码。 例如，如果我们在上面功能还要再加新的Pizza种类，我们要修改如下 新增（扩展开放）： 修改（修改关闭）：-&gt;如果增加一个pizza类，主要是订购pizza的代码都要修改 简单工厂模式进行修改 把创建pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类即可，其它有创建到Pizza对象的代码就不需要修改了 简单工厂模式 基本介绍 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。 定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 实例代码 /** * 新增加pizza种类 简单工厂创建用来实例化对象的代码 */ public class SimpleFactory { //更改orderType 返回对应的Pizza 对象 简单工厂模式1 public Pizza createPizza(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } //简单工厂模式 也叫 静态工厂模式 简单工厂模式2 public static Pizza createPizza2(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式2\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } } --------- /** * 简单工厂模式1 */ public class OrderPizza2 { //定义一个简单工厂对象 SimpleFactory simpleFactory; Pizza pizza = null; //构造器 public OrderPizza2(SimpleFactory simpleFactory) { setFactory(simpleFactory); } public void setFactory(SimpleFactory simpleFactory) { //用户输入 String orderType = \"\"; //设置简单工厂对象 this.simpleFactory = simpleFactory; do { orderType = getType(); pizza = this.simpleFactory.createPizza(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购披萨失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * 简单工厂模式2 */ public class OrderPizza3 { Pizza pizza = null; String orderType = \"\"; //构造器 public OrderPizza3() { do { orderType = getType(); pizza = SimpleFactory.createPizza2(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\" 订购披萨失败 \"); break; } }while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * main方法 */ public class PizzaStore { public static void main(String[] args) { //常规方式 // new OrderPizza(); //简单工厂模式1 // new OrderPizza2(new SimpleFactory()); //简单工厂模式2 new OrderPizza3(); } } 工厂方法模式 工厂方法模式介绍 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 BJCheessPizza，BJPepperPizza，LDCheessPizza，LDPepperPizza /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } --- public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } ---- public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 工厂模式 */ public abstract class OrderPizza { //定义一个抽象方法，createPizza , 让各个工厂子类自己实现 abstract Pizza createPizza(String orderType); //构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); //抽象方法，由工厂子类完成 pizza = createPizza(orderType); //输出pizza制作过程 if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } --- public class BJOrderPizza extends OrderPizza{ @Override Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //main public class PizzaStore { public static void main(String[] args) { new BJOrderPizza(); } } 抽象工厂模式 基本介绍 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（进一步的抽象）。 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成工厂簇。更利于代码的维护和扩展。 /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } //实现抽象类1 public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } //实现抽象类2 public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 一个抽象工厂模式的抽象层(接口) */ public interface AbsFactory { //让下面的工厂子类来 具体实现 public Pizza createPizza(String orderType); } //实现抽象工厂 public class BJFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\"); Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //封装方法 public class OrderPizza { AbsFactory factory; // 构造器 public OrderPizza(AbsFactory factory) { setFactory(factory); } private void setFactory(AbsFactory factory) { Pizza pizza = null; String orderType = \"\"; this.factory = factory; do { orderType = getType(); // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类 pizza = factory.createPizza(orderType); if (pizza != null) { // 订购ok pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //main方法 public class PizzaStore { public static void main(String[] args) { new OrderPizza(new BJFactory()); } } 原型模式题型：克隆sheep 现在有一只羊tom，姓名为:tom，年龄为:1，颜色为:白色，请编写程序创建和tom羊属性完全相同的10只羊。 传统方式public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\"; } } ------ public class Client { public static void main(String[] args) { //传统的方法 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); //.... System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); //... } } 传统格式的优缺点 优点是比较好理解，简单易操作。 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率低。 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不灵活。 改进：java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的Java类必须实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力-》原型模式 原型模式基本介绍 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建的细节。 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即，对象.clone() -&gt;原型结构图说明 Prototype：原型类，声明一个克隆自己的接口。 ConcretePrototype：具体的原型类，实现一个克隆自己的操作 Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样） public class Sheep implements Cloneable{ private String name; private int age; private String color; private String address = \"蒙古羊\"; public Sheep friend; //是对象, 克隆是会如何处理 public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\"; } @Override protected Object clone(){ Sheep sheep = null; try { sheep = (Sheep) super.clone(); } catch (CloneNotSupportedException e) { // e.printStackTrace(); System.out.println(e.getMessage()); } return sheep; } } ||||| public class Client { public static void main(String[] args) { System.out.println(\"原型模式完成对象的创建\"); Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 2, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); //克隆 Sheep sheep3 = (Sheep)sheep.clone(); //克隆 Sheep sheep4 = (Sheep)sheep.clone(); //克隆 Sheep sheep5 = (Sheep)sheep.clone(); //克隆 System.out.println(\"sheep2 =\" + sheep2); System.out.println(\"sheep2 =\" + sheep3); System.out.println(\"sheep2 =\" + sheep4); System.out.println(\"sheep2 =\" + sheep5); System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode()); System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode()); System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode()); System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode()); } } 浅拷贝和深拷贝浅拷贝： 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值赋值一份给新的对象。 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数值、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 克隆羊是浅拷贝。 浅拷贝是使用默认的clone()方法实现 sheep =(Sheep)super.clone 深拷贝： 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝。 深拷贝实现方式1：重写clone方法来实现深拷贝 深拷贝实现方式2：通过对象序列化实现深拷贝 原型模式的注意事项 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码。 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。 public class DeepCloneableTarget implements Serializable, Cloneable { private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; //构造器 public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } //因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } ||||| public class DeepProtoType implements Serializable, Cloneable { public String name; //String 属性 public DeepCloneableTarget deepCloneableTarget;// 引用类型 public DeepProtoType() { super(); } //深拷贝 - 方式 1 使用clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; //这里完成对基本数据类型(属性)和String的克隆 deep = super.clone(); //对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType) deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone(); return deepProtoType; } //深拷贝 - 方式2 通过对象的序列化实现 (推荐) public Object deepClone() { //创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //序列化. bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //当前这个对象以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType copyObj = (DeepProtoType) ois.readObject(); return copyObj; } catch (Exception e) { e.printStackTrace(); return null; }finally { //关闭流 try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (Exception e2) { System.out.println(e2.getMessage()); } } } } |||||||| public class Client { public static void main(String[] args) throws CloneNotSupportedException { DeepProtoType p = new DeepProtoType(); p.name = \"宋江\"; p.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\"); //方式1 完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.clone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p2.name=\" + p2.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode()); //方式2 完成深拷贝 DeepProtoType p3 = (DeepProtoType) p.deepClone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p3.name=\" + p3.name + \"p3.deepCloneableTarget=\" + p3.deepCloneableTarget.hashCode()); } } 建造者模式项目盖房需求： 需要建房子：打桩、砌墙、封顶 有普通房、高楼、别墅各种房子，但是要求不要相同 传统方式 分析 传统方式有点比较好理解，简单易操作 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，这种设计方案，把产品（即：房子）和创建产品的过程（即：建造房子流程）封装在一起，耦合性增强 解决方案：将产品和产品建造过程解耦 =&gt;建造者模式 public abstract class AbstractHouse { //打地基 public abstract void buildBasic(); //砌墙 public abstract void buildWalls(); //封顶 public abstract void roofed(); public void build() { buildBasic(); buildWalls(); roofed(); } } ----------- public class CommonHouse extends AbstractHouse{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙 \"); } @Override public void roofed() { System.out.println(\" 普通房子封顶 \"); } } ------------- public class Client { public static void main(String[] args) { CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); } } 建造者模式基本介绍 建造者模式，又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不用表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder(抽象建造者) ：创建一个Product对象的各个部件指定的接口/抽象类。 ConcreteBulder(具体建造者) : 继承/实现接口，构建和搭配各个部件。 Director(指挥者) ： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离客户与对象的生产过程。二是：负责控制产品对象的生产过程 建造者模式的注意事项： 客户端(Client)不必知道产品内容组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则” 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类实现这种变化，导致系统变得很庞大，这时候需要考虑是否选择建造者模式 抽象工厂模式和建造者模式区别 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 //产品-&gt;Product public class House { private String basic; private String wall; private String roofed; public String getBasic() { return basic; } public void setBasic(String basic) { this.basic = basic; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } // 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); //将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造房子好， 将产品(房子) 返回 public House buildHouse() { return house; } } //继承抽象 public class CommonHouse extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基5米 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙10cm \"); } @Override public void roofed() { System.out.println(\" 普通房子屋顶 \"); } } public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 高楼的打地基100米 \"); } @Override public void buildWalls() { System.out.println(\" 高楼的砌墙20cm \"); } @Override public void roofed() { System.out.println(\" 高楼的透明屋顶 \"); } } //指挥者，这里去指定制作流程，返回产品 public class HouseDirector { HouseBuilder houseBuilder = null; //构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //通过setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } //client public class Client { public static void main(String[] args) { //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); System.out.println(\"-------------\"); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品(高楼) houseDirector.constructHouse(); } } 适配器模式基本介绍 适配器模式将某个类的接口 转换成客户端期望的另一个借口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(wrapper) 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 工作原理 适配器模式：将一个类的接口转换成另一种接口。让原本接口不兼容的类可以兼容 从用户的角度看不到被适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户受到反馈结果，感觉只是和目标接口交互，如图 适配器模式的注意事项 三种命名方式，是根据【被适配器】src是以怎样的形式给【适配器】Adapter（在Adapter里的形式）来命名的 类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现 Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作 类适配器模式基本介绍 先有Adapter类（适配器），通过继承被适配者(src类)，实现目标类(dst类)接口，完成src &gt; dst 的适配 应用实例： 充电器本身相当于适配器(Adapter)，插口220V交流电相当于src(即被适配者)，我们的目标(dst)即转换成5v直流电，能够给电器充电 类适配器注意事项 Java是单继承机制，所以类适配器需要继承src类这点算是一个缺点，因为这要求dst必须是接口，有一定的局限性。 src类的方法在Adapter中都会暴露出来，也增加了使用的成本。 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 //被适配的类 public class Voltage220V { //输出220V的电压 public int output220v() { int src =220; System.out.println(\"电压=\" + src + \"伏\"); return src; } } //适配接口 public interface IVoltage5V { public int output5V(); } //适配器类 public class VoltageAdapter extends Voltage220V implements IVoltage5V{ @Override public int output5V() { //获取到220V电压 int srcV = output220v(); int dstV = srcV / 44;//转成 5v return dstV; } } public class Phone { //充电 public void charging(IVoltage5V iVoltage5V) { if (iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V, 可以充电~~\"); } else if (iVoltage5V.output5V() &gt; 5) { System.out.println(\"电压大于5V, 不能充电~~\"); } } } //main public class Client { public static void main(String[] args) { System.out.println(\" === 类适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } 对象适配器模式 基本介绍 基本思路和类的适配器模式相同，只是将适配器(Adapter类)作修改，不是继承（被适配器）src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现适配接口(dst类接口)，完成src-&gt;dst的适配 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。 对象适配器模式是适配器模式常用的一种 应用实例： 充电器问题，只需要修改适配器即可 //适配器类 public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; // 关联关系-聚合 //通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) { this.voltage220V = voltage220v; } @Override public int output5V() { int dst = 0; if(null != voltage220V) { int src = voltage220V.output220V();//获取220V 电压 System.out.println(\"使用对象适配器，进行适配~~\"); dst = src / 44; System.out.println(\"适配完成，输出的电压为=\" + dst); } return dst; } } public class Client { public static void main(String[] args) { System.out.println(\" === 对象适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); } } 对象适配器模式注意事项 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合同复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须接口。 使用成本更低、更灵活。 接口适配器模式 适配器模式或缺省适配器模式 当不需要全部实现接口提供的方法时，可先设计一个抽象实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该对象类的子类可有选择地覆盖父类的某些方法来实现需求。 适用于一个接口不想使用其所有的方法的情况、 应用实例 Android中的属性动画ValueAnimator类可以通过addListener（AnimatorListener listener）方法添加监听器，常规写法如下 有时候不想实现Animator.AnimatorListener接口的全部方法，我们只想监听onAnimationStart，我们会如下写： AnimatorListenerAdapter类，就是一个接口适配器，代码如下，它空实现了Animator.AnimatorListener类（src）的所有方法 AnimatorListener是一个接口 程序里的匿名内部类就是Listener具体实现类 案例说明 public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } //在AbsAdapter 我们将 Interface4 的方法进行默认实现 public class AbsAdapter implements Interface4{ //默认实现 @Override public void m1() { } @Override public void m2() { } @Override public void m3() { } @Override public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter(){ //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(\"使用了m1的方法\"); } }; absAdapter.m1(); } } 桥接模式应用实例 对不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网、打电话等） 传统方式 问题分析： 扩展性问题（类爆炸）：如果再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本，所以用桥接模式 桥接模式 基本介绍 桥接模式(Bridge模式)：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。 是一种结构型模设计模式 Bridge模式基于类的最小设计原则，通过使用封装、聚合以及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。 桥接模式注意事项 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计维度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。 桥接模式的其他应用场景 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 常见的应用场景： -JDBC驱动程序 -银行转账系统 转账分类：网上转账，柜台转账、AMT转账 转账用户类型：普通用户，银卡用户，金卡用户.. -消息管理 消息类型：即时消息，延时消息 消息分类：手机短信，邮件消息，QQ消息 //接口 public interface Brand { void open(); void close(); void call(); } public class XiaoMi implements Brand { @Override public void open() { System.out.println(\" 小米手机开机 \"); } @Override public void close() { System.out.println(\" 小米手机关机 \"); } @Override public void call() { System.out.println(\" 小米手机打电话 \"); } } public abstract class Phone { //组合品牌 private Brand brand; //构造器 public Phone(Brand brand) { this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { brand.close(); } protected void call() { brand.call(); } } //折叠式手机类，继承 抽象类 Phone public class FoldedPhone extends Phone{ //构造器 public FoldedPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 折叠样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 折叠样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 折叠样式手机 \"); } } public class UpRightPhone extends Phone{ //构造器 public UpRightPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 直立样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 直立样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 直立样式手机 \"); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"=======================\"); Phone phone2 = new UpRightPhone(new XiaoMi()); phone2.open(); phone2.call(); phone2.close(); } } 装饰者模式订单项目 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(没事咖啡)、Decaf（无因咖啡） 调料：Milk、Soy（豆浆）、Chocolate 要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。 传统方式 方案1 Drink是一个抽象类，表示饮料。 des就是对咖啡的描述，比如咖啡的名字 cost()方法就是计算费用，Drink类中做成一个抽象方法 Decaf就是单品咖啡，继承Drink，并实现cost Espress&amp;&amp;Milk就是单品咖啡+调料，这个组合很多 问题：这种设计会导致有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸。 方案2 方案2可以控制类的数量，不至于造成很多的类 在增加或者删除调料种类时，代码的维护量很大 考虑到用户可以添加多份调料时，可以将hasMilk 返回一个对应int 考虑用装饰者模式 装饰者模式 装饰者模式定义 装饰者模式：动态的将新功能附加到对象上，在对象功能扩展方面，它比继承更加有弹性，装饰者模式也体现了开闭原则(OCP) 这里提到的动态地将新功能附加到对象和ocp原则，在后面的应用实例上面会以代码的形式体现 装饰者模式原理 装饰者模式设计咖啡 public abstract class Drink { public String des;//描述 private float price =0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } //计算费用的抽象方法 //子类来实现 public abstract float cost(); } public class Coffee extends Drink{ @Override public float cost() { return super.getPrice(); } } public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\" shortblack \"); setPrice(4.0f); } } public class DeCaf extends Coffee{ public DeCaf() { setDes(\" 无因咖啡 \"); setPrice(1.0f); } } public class Espresso extends Coffee{ public Espresso() { setDes(\" 意大利咖啡 \"); setPrice(6.0f); } } public class LongBlack extends Coffee{ public LongBlack() { setDes(\" longblack \"); setPrice(5.0f); } } public class Decorator extends Drink{ private Drink obj; public Decorator(Drink obj) { //组合 this.obj = obj; } @Override public float cost() { // getPrice 自己价格 return super.getPrice() + obj.cost() ; } @Override public String getDes() { // obj.getDes() 输出被装饰者的信息 return des + \" \" + getPrice() + \" &amp;&amp; \" + obj.getDes(); } } //具体的Decorator， 这里就是调味品 public class Chocolate extends Decorator{ public Chocolate(Drink obj) { super(obj); setDes(\" 巧克力 \"); setPrice(3.0f); // 调味品 的价格 } } public class Milk extends Decorator{ public Milk(Drink obj) { super(obj); setDes(\" 牛奶 \"); setPrice(2.0f); } } public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); setDes(\" 豆浆 \"); setPrice(1.5f); } } public class CoffeeBar { public static void main(String[] args) { // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用1=\" + order.cost()); System.out.println(\"描述=\" + order.getDes()); // 2. order 加入一份牛奶 order = new Milk(order); System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入一份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入2份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes()); System.out.println(\"===========================\"); Drink order2 = new DeCaf(); System.out.println(\"order2 无因咖啡 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes()); order2 = new Milk(order2); System.out.println(\"order2 无因咖啡 加入一份牛奶 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes()); } } 组合模式 学校院系展示需求 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，如图： 传统方式 传统方式解决学院院系展示存在的问题分析 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现管理的操作，比如学院、系的添加，删除，遍历等。 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承关系，而是一种树形结构，可以更好的实现管理操作。 =&gt;组合模式 组合模式 基本介绍 组合模式（Composite Pattern），又叫部分整理模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 这种类型的./设计模式属于结构型模式。 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象 组合模式原理类图 对原理机构图的说明（即：组合模式的角色以及职责） Component：这是组合中对象生命接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component 子部件，Component可以是抽象类或者接口 Leaf：在组合中表示叶子节点，叶子节点没有子节点。 Composite：非叶子节点，用于存储子部件，在Component接口实现子部件的相关操作，比如增加（add）,删除。 组合模式解决学校院系展示的应用实例 应用实例要求： 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。 思路分析图解（类图） 代码实现","categories":[],"tags":[]},{"title":"shopFM","slug":"shopFM","date":"2022-02-14T14:48:55.000Z","updated":"2022-02-14T15:29:54.078Z","comments":true,"path":"posts/shopfm/","link":"","permalink":"https://dahammer666.github.io/posts/shopfm/","excerpt":"","text":"一、项目介绍1.1 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.2 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.2.1 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、数据库设计 4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、设计及实现—用户管理 6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息 14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper） 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现微信支付 为商家提供代理收款服务 1.微信支付业务-商户需要注册微信支付业务 商户编号：3454563 商户账号：23435 商户编号appID： werselfjldsjhtoieiurt0 商户密钥：sdfsdlkfjdslkjfFGFGDSRTG89 2. 微信支付业务-商户注册微信支付业务 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1导入微信支付Maven依赖 wxpay的maven依赖生成 &lt;!-- https://mvnrepository.com/artifact/com.github.wxpay/wxpay-sdk --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类： 创建一类，实现WxPayConfig接口 重写三分方法，分别设置AppID\\商户ID\\商户密钥 package com.qfedu.fmmall.config; import com.github.wxpay.sdk.WXPayConfig; import java.io.InputStream; public class MyPayConfig implements WXPayConfig { //商户账号 @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } //商户appID @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } //商户的密钥 @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.2和微信的接口进行相关的参数设置和获取微信支付链接2.21创建自己的url,PayController类：package com.qfedu.fmmall.controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/pay\") public class PayController { @PostMapping(\"/success\") public void success(){ } } 2.22添加订单快照成功生成支付链接必须设置的配置参数： // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPay; import com.qfedu.fmmall.config.MyPayConfig; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultStatus; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @CrossOrigin @RequestMapping(\"/order\") @Api(value = \"提供订单相关的接口\",tags = \"订单管理\") public class OrderController { @Autowired private OrderService orderService; @PostMapping(\"/add/{cids}\") public ResultVO add(@PathVariable(\"cids\") List&lt;Integer&gt; cids, @RequestBody Orders orders){ ResultVO resultVO=null; // 测试用的OrderId try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, orders); String orderId=orderInfo.get(\"orderId\"); // 订单快照创建成功，申请支付链接 HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;(); // 设置当前订单信息 data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId);//使用当前用户订单编号作为当前支付交易的交易编号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\", orders.getActualAmount()+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\");//交易类型 // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); WXPay wxPay=new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); // 把微信支付平台生成的链接获取到 orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO=new ResultVO(ResultStatus.OK,\"提交订单成功！\",orderInfo); System.out.println(resp); // code_url -&gt; weixin://wxpay/bizpayurl?pr=Iv5Fsq6zz } catch (SQLException e) { resultVO= new ResultVO(ResultStatus.NO,\"下单失败\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } }","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2022-02-14T13:21:33.000Z","updated":"2022-02-15T16:22:51.997Z","comments":true,"path":"posts/computermanage/","link":"","permalink":"https://dahammer666.github.io/posts/computermanage/","excerpt":"","text":"一、Start一、计算机系统体系结构术语体系结构的三种用法 指令集体系结构（ISA） ​ 描述了程序员看到的计算机的抽象视图，并且定义了汇编语言和编程模型。之所以说它是抽象的，是因为它并没有考虑计算机的实现。 微体系结构（具体实现） ​ 描述了一种指令集体系结构的实现方式。微体系结构关注计算机的内部设计。 系统体系结构 ​ 关注包括处理器、存储器、总线和外设在内的整个系统。 计算机系统体系结构所涉及的内容 1.1 什么是计算机体系结构 计算机系统包括读取并执行程序的中央处理单元（Central processing unit,CPU），保存程序和数据的存储器，以及输入输出子系统，这些子系统会使CPU与显示器、打印机等外部设备之间的通信变得更加容易。 计算机中实际执行程序的部分叫做CPU，或者更简单地被称作处理器。微处理器则是在单个硅片上实现的CPU。围绕着微处理器构建的计算机被称作微机。 尽管CPU是计算机的核心，计算机的性能既取决于CPU，也取决于其他子系统的性能。如果不能高效进行数据传输，仅仅提高CPU的性能是毫无意义的。 简单通用计算机结构 1.1.1 简单通用计算机结构 信息（即程序和数据）保存在存储器中，为了实现不同的目标，计算机会使用不同类型的存储器，如Cache、主存、辅存等多个存储层次，大多数处理器都在CPU内集成了片上Cache。 Cache是存放常用数据的高速、专用存储器。主存中存放了大量的工作数据。辅存是指磁盘和CD-ROM，能够存储海量数据。 组成计算机的各个子系统通过总线连接在一起，数据通过总线从计算机中的一个位置传递到另一个位置。 可编程计算机接收两种类型的输入：要处理的数据，以及要如何处理输入数据的程序。程序不过是计算机所执行的完成给定任务的操作序列。 数字计算机的结构，可以被分为两部分：中央处理单元和存储器系统。CPU读程序并完成程序指定的操作。存储器系统保存两类信息：程序，程序处理或产生的数据。 寄存器是CPU内部用来存放数据的存储单元。 时钟提供了脉冲流，所有内部操作都在时钟脉冲的触发下进行。时钟频率是决定计算机速度的一个因素。 1.1.2 程序执行的过程 描述了程序的执行过程： 从存储器中读出一条Z=X+Y的指令，将其发送给解释单元，解释单元产生控制信号，驱动这条指令的执行。假定这个程序的功能是从存储器读出两个数据（X和Y），将它们相加，然后写回存储器。 要执行这个程序，CPU必须首先从存储器中取出一条指令，在CPU分析或解码这条指令后，从存储器中读出这条指令所需的所有数据。第一条指令，LOAD X，从存储器中读出变量X的值，并将它暂存在寄存器中。第二条指令，LOAD Y，从存储器中读出变量Y的值，并保存在另一个寄存器中。第三条指令，Z=X+Y，将两个寄存器的内容相加，并将结果保存在第三个寄存器中。第四条指令，STORE Z，将加法的结果写回存储单元Z。 1.1.3 计算机指令 尽管计算机能够执行上百种不同指令，但下面的**6条基本指令(汇编语言)**可以将所有计算机指令进行分类： MOV A, B 将B的值复制到ALOAD A, B 将存储单元B的值复制到寄存器A中STORE A, B 将寄存器B的值复制到存储单元A中ADD A, B A与B相加，结果保存到A中TEST A 测试A的值是否为0BEQ Z 若最后一次测试结果为TRUE，执行地址Z处的代码 ， 否则继续执行 1.2 体系结构和组成1.2.1 计算机体系结构 计算机体系结构含有结构（structure）的意思，描述了一些与计算机组成方式有关的内容。之所以定义计算机体系结构，是因为不同的用户会从完全不同的角度看待计算机。计算机体系结构通常被认为是程序员视角中的计算机。程序员所看到的是计算机的抽象视图，计算机的实际硬件和实现都被隐藏起来了。这个抽象视图现在通常被称作指令集体系结构（instruction setarchitecture，ISA）。 1.2.2 计算机组成 计算机组成表示其体系结构的具体实现。计算机组成是计算机体系结构的实例化（即将抽象变为具体） 本书用术语“体系结构”代表计算机的抽象指令集体系结构（它的指令集），用术语“组成”代表计算机的实际硬件实现。 1.2.3 寄存器 寄存器是用来存放一个单位的数据或字数据的存储单元。寄存器通常用它所保存数据的位数来描述，典型的有8位、16位、32位和64位。 寄存器与存储器中的字存储单元没有本质区别。二者的实际差别在于，寄存器位于CPU内，它的访问速度远远快于访问CPU外的存储器。 1.2.4 机器码&amp;汇编语言&amp;高级语言 计算机上执行的代码表示为二进制0和1组成的串，被称作机器码。每种计算机都只能执行一种特定的机器码。 人类可读的机器码（如ADD R0,R1）叫作汇编语言。 能够在类型完全不同的计算机上运行，与底层计算机体系结构几乎没有关系的代码叫做高级语言（如C或Java等）。在执行之前，高级语言程序必须先被编译为计算机的本地机器码。 1.2.5 时钟 绝大多数数字电子电路都带有一个时钟，用以生成连续的间隔固定的电脉冲流。之所以被称作时钟，是因为可用这些电脉冲来计时或确定计算机内所有事件的顺序。如，处理器可能会在每一个时钟脉冲到来时执行一条新指令。 1.2.6 RISC和CISCRISC（精简指令集计算机）体系结构（ARM） 设计策略：是使用少量的指令完成最少的简单操作 缺点：程序设计更难，复杂指令需要用简单指令模拟 应用：ARM处理器 CISC（复杂指令集计算机）体系结构 设计策略：是使用大量的指令，包括复杂指令 优点：程序设计更容易，因为每个简单的或复杂的任务都有一条对应的指令。程序员不需要写一大堆的指令去完成复杂的任务 缺点：指令集的复杂性使得CPU和控制单元电路非常复杂 应用：英特尔公司开发的奔腾系列CPU 1.3 计算机的发展 机械计算机 -&gt; 机电式计算机 -&gt; 早期的电子计算机 -&gt; 微机和PC革命 1.3.1 摩尔定律和进步的历程 摩尔定律 ​ 是卡沃-米德于1975年根据戈登-摩尔所观察到集成电路的集成度每18个月翻一番，摩尔定律是一个经验性的观察结果。 1.3.2 乱序执行 程序中的指令必须一条接一条按照在程序中的出现的顺序执行。 有时可以通过改变指令的执行顺序提高计算机的速度。图中，指令（4）和（5）可以在任何时候执行，但指令（3）必须在指令（1）和（2）结束后执行。 1.3.3 存储技术发展 覆盖着电容的旋转的磁鼓 -&gt; 阴极射线管 -&gt;铁氧体磁芯存储器 -&gt;磁盘 -&gt; 光存储器（DVD等） 1.3.4 多媒体计算机多媒体处理（处理和存储音频/视频数据）需要很大的存储容量以及完成大量简单重复操作的实时处理声音样本的图像像素的能力。 1.4 存储程序计算机1.4.1 最大游程问题描述 ​ 十进制数串23277366664792221，其中有一些值相同的数字连续出现（如连续的2个7,4个6和3个2），我们的问题十分简单：找出最大游程，即同一个数字连续出现的最大次数。 ​ 为了简化问题，假设数串长度大于3。我们将设计一个计算机来处理图中的数串，它每次读一个数，并计算最大游程。 解决方法： ​ 从数串的左边开始逐个检查数字，在任何一个位置，都会得到两个结果之一：要么这个数与前一个相同，序列还在增长；要么这个数与上一个不同，前一个序列结束，一个新的序列开始。 对于一个数字系统，当一个特定事件（如时钟脉冲）发生时，它将从一个状态转换为另外一个状态。 图中有两个状态，分别是“在同一序列中”和“不在同一序列中”，每当从数串中读出一个新元素，都会发生状态转换。 一、如图，列出一个接一个读入数串的数字后系统状态的转换情况，状态的改变会发生在序列的第二个数字或结束序列的那个数字上。 二、如表，将这些数字组织成更容易理解的形式。最上面一行是每个数字在数串S中的位置或地址，下一行是串S中这个数字的值。第三行第一个元素是？，因为上一个元素的值是未知的。第四行统计数串中每个元素所在序列的长度,数字本身长度为1，如果相同则+1 统计数串中最大序列长度 为了方便，通过下面的符号名说明问题： i 串的当前位置 New_Digit 刚从数串中读出的数字的值 Current_Run_Value 当前序列数值 Current_Run_Length 当前序列长度 Max_Run 目前为止的最大序列长度 | 使用伪代码描述问题的操作： 读出串的第一个数字，将其称为New_Digit 将Current_Run_Value的值置为New_Digit 将Current_Run_Length的值置为1 将Max_Run的值置为1 REPEAT 读出序列中下一个数字（即read New_Digit） IF 它的值与Current_Run_Value相同 THEN Current_Run_Length = Current_Run_Length + 1 ELSE { Current_Run_Length = 1 Current_Run_Value = New_Digit } IF Current_Run_Length &gt; Max_Run THEN Max_Run = Current_Run_Length UNTIL 读出了最后一个数字 1.4.2 存储器 如图，描述了程序怎样找出保存在一个假象存储器中的数串的最大序列长度。必须强调的是，这个程序是概念上的而不是实际的。该图叫作存储器映射，展示了信息在存储器中的存放位置，存储器中的每个位置要么保存指令，要么保存数据元素。 1.4.3 寄存器传输语言 由于使用文字描述计算机的操作很不方便，使用RTL可以更加容易地定义计算机内发生的操作。 区分存储单元的地址和它的内容非常重要。在RTL语言中，用方括号[ ]表示存储单元的内容，如 [15] = Max_Run 含义是：地址为15的存储单元保存了变量Max_Run的值 左箭头符号表示数据传送操作，如 [15]&lt;–[15] + 1 含义是：将地址为15的存储单元的值加1，并将结果写回地址为15的存储单元考虑下面3个RTL表达式：[20] = 5[20]&lt;–6[20]&lt;–[6] 1.4.4 存储系统 如图，描述了存储系统的组成 处理器将一个放在地址总线上的地址以及一个用于选择读操作或写操作（也被称为读或写周期）的控制信号发送给存储器。 在读周期中，存储器将数据放在数据总线上供CPU读取。 写周期中，放在数据总线上的数据被写入存储器。 信息进入或离开存储器的位置叫作端口。 1.4.5 存储程序的概念 下面的伪代码描述了存储程序计算机的基本操作： 存储程序计算机 程序计数器指向存储器中的第一条指令 REPEAT 从程序计数器所指的存储单元中读出指令 修改程序计数器，使之指向下一条指令 将从存储器中取出的指令解码 执行指令 FOREVEREnd 从存储器中取出每条指令都需要进行一次访存操作（即读存储器）。可以用下面的伪代码描述“执行指令”这一动作： ​ 执行指令​ IF 指令需要使用数据​ THEN 从存储器中读这个数​ END_IF​ 完成指令定义的操作​ IF 指令要将数据写回存储器​ THEN 将数据写回存储器​ END_IF​ End 上面的动作序列用C语言描述： 执行一条指令需要至少两次访存，第一次访存是读取指令，第二次访存要 么从存储器读出指令需要的数据，要么将它之前的指令产生的或修改过的 数据写回存储器。 1.4.6 指令格式 存储程序计算机的一种直观合理的指令格式可以用下面的形式表示： Operation表示要执行的指令的动作Address1、Address2和Address3分别是3个操作数在存储器中的位置。在这条指令中，操作数为数据的地址，而不是数据本身。 ADD P,Q,R是一条典型的三操作数指令，P、Q、R是三个存储单元地址的符号名。这个三操作数指令格式用RTL表示为： 如图，描述了一条指令的执行过程，一共需要4次访存（即一次取指令，两次取两个源操作数，一次保存结果） 如图，描述了指令的4个字段与CPU、存储器以及指令的执行方式之间的关系： 1.4.7 两地址指令 有些计算机实现了两地址指令，其格式为： Address2为源操作数，Address1既是源操作数也是目的操作数。 指令ADD P,Q的RTL定义为： 两地址指令会破坏它的一个操作数，也就是说，会用结果替换源操作数P，本书大部分章节约定两地址指令格式为： 在实际计算机中，一般不允许同一条指令中使用两个存储地址，大多数计算机都规定一个地址是存储器地址，另一个地址是寄存器。 1.4.8 单地址指令有些计算机实现单地址指令，其格式为： 指令中只提供了一个操作数地址，而指令却需要至少两个地址，处理器不得不使用一个不需要显示地址的第二操作数，第二个操作数来自CPU内一个叫累加器（accumulator）的寄存器。 如图，描述了一条单操作数指令执行过程中的信息流，操作结果将一直保存在寄存器中，直到另一条指令将它送入存储器。实现P = Q + R： 1.4.9 计算机分类可以按照计算机的指令处理数据的方式对计算机分类 存储器-存储器型：一条指令能够从存储器中读出源操作数，对数据完成某个操作，并将结果保存在存储器中 寄存器-存储器型：能够处理两个数据，其中一个位于存储器中，另一个位于寄存器中，结果要么被写回存储器，要么被写回寄存器，如Intel IA32 CPU体系结构 寄存器-寄存器型：只能对寄存器中的内容进行操作，这些计算机必须通过LOAD指令将数据读入寄存器并使用STORE指令将数据从寄存器送回存储器。由于LOAD 和STORE操作是仅有的存储器访问指令，这些计算机也被称为load/store 型计算机，如ARM和MIPS CPU体系结构 1.6 计算机系统概览1.6.1存储层次由于CPU与存储器的性能之间的差距不断加大，通过在使用数据之前将它们从存储器中取出来消除相对慢速的存储器的影响，以降低延迟。 如图，描述了经典的存储层次图，展示了计算机中存储部件的类型、速度以及在PC机中的典型容量： 寄存器：存放处理器的工作数据 Cache：缓存常用数据的快速存储器 (内存)DRAM：存放工作数据 硬盘：保存程序和数据， 注意，硬盘的容量是寄存器 的4000万倍，但速度却比寄存器 慢2000万倍！ 1.6.2 Cache高速缓存 经常被用到的数据保存在Cache中，Cache的访问时间比主存短得多。Cache保存主存中经常使用的数据的副本。Cache系统与计算机的地址总线和数据总线相连，监听CPU与存储器之间的事务。 只要Cache注意到CPU发出的地址与它保存的某个数据元素地址相同，就把这个数据发送个CPU，而不会去主存中取数据。 一级缓存（集成在CPU中）&amp;二级缓存&amp;三级缓存 1.6.3 DRAM 存放正在执行的程序的主存，是由一种叫作动态随机访问存储器（Dynamic Random Access Memory,DRAM）的易失性半导体存储器构成的立即存取存储器。 1.6.4 总线 总线将计算机的两个或多个功能单元连接在一起并允许它 们相互交换数据。总线还将计算机与外设连接在一起。 如图，描述了一个没有总线的假象系统的结构，节点之间的互连复杂并且凌乱，若要添加一个新单元，必须在新单元与它所连接的每个单元之间增加一条新连接： | 如图，展示了通过公共总线将所有单元连接在一起的好处，此时只有一条高速数据通路，每个单元通过一个接口与这条通路相连： || ———————————————————— || || 缺点：每次只有唯一一个设备能够与其它设备通信，因为这里只有一条信息通路。如果两个设备同时请求使用总线，它们不得不去竞争总线的控制权。用术语仲裁来描述多个设备竞争同一资源的过程。 | 总线术语 宽度 一般用并行数据通路的数量来定义总线的宽度。一条64位宽的总线一次能传送64位（8个字节）信息。 带宽 总线带宽是衡量信息在总线上的传输速率的一项指标。带宽的单位要么是B/s，要么b/s。在保持数据传输率不变的情况下增加总线宽度，可以提高带宽。 延迟 延迟是从发出数据传输请求到实际数据传输的时间间隔。总线延迟通常包括传输开始之前进行总线仲裁的时间。 多总线系统 | 现代计算机中有多条总线，包括片内总线、功能单元间（如CPU和存储器间）的总线以及总线间的总线，如图描述了一个多总线系统： （1）多总线运行并发操作（2）总线可能具有完全不同的特点和操作速度 || ———————————————————— || | 二、计算机算术2.1 数据是什么 数据是各种各样的信息，如数字、文本、计算机程序、音乐、图像、符号等等，实际上，信息可以是能够被计算机存储和处理的任何事物。 2.1.1 位与字节 计算机中存储和处理信息的最小单位是位（Binary digit比特，bit），一个比特的值可以是0或1。 数字计算机将信息以一组或一串比特（称作字）的形式保存在存储器中。如，串01011110表示一个8位的字。 计算机通过高低电压（高低电位）两个电压等级来存储0和1的状态。 计算机通常不会每次只对一个二进制位进行操作，而是对一组二进制位进行操作。8个二进制位为一个字节（byte），一些计算机制造商用术语“字”表示16位的值，长字表示32位的值，还有一些制造商用字表示32位的值，用半字表示16位的值。 2.1.2 位模式| 下图描述了如何用1位、2位、3位和4位得到一个二进制的值序列： || ———————————————————— || || 每当数字增加1位，路径的总数将翻一倍。一个n位的字将得到2n条不同路径或位模式。如，一个8位的字节将得到28=256个可能的值。 为了用二进制数表示任何一个拥有最多n个值的量，应找到一个使不等式n&lt;=2m成立的最小位数m。 | 2.1.2.1 位模式——信息表示 一个n位的二进制可以表示什么信息呢？ 答案是什么也表示不了。因为一个由二进制1和0组成的串没有任何内在含义。需要程序员赋予它何种含义。 一个二进制串可以表示的对象有： 指令字长为32位或更长的计算机用一个字来表示CPU能够完成的操作（8位或16位计算机用多个字表示一条指令）。指令的二进制编码与其功能之间的关系由计算机设计者决定。如，一台计算机上表示“A加B”的二进制序列可能与另一台计算机上的完全不同。 数量一个字或多个字都可以用来表示数量。数可以被表示为多种格式，如有符号、无符号二进制整数、二进制浮点数、整数复数等等。 字符 字符是一个叫作“字母表”的集合中元素。拉丁或罗马字母表中的字母、数字字符（A-Z，a-z，0-9）和*、-、+、？等符号都被分配了二进制值，因此可以在计算机内存储和处理。 下图为ASCII码表（美国信息交换标准码表）： ASCII码表用7位表示一个字符，一共可以表示2^7=128个不同的字符。其中96个字符是可打印字符。其余32个是不可打印字符，用于完成回车、退格、换行等特殊功能。 扩展的ASCII码表：8位的ISO 8859-1拉丁编码。将7位的ISO/ASCII字符集扩展为8位，可以得到两个128个字符的字符集，如果字符的最高位为0,**则其余7位代表128个标准ISO/ASCII字符中的一个，如果字符最高位为1**，其余7位将表示128个新字符中的任意一个。 图像、声音和视觉 数字计算机处理大量表示声音、静态图像和视频的数据。 组成照片的基本单位是像素，每个像素的大小可以是8位（单色）或24位（三基）。 视频作为一串静态图像依次传输，每秒发送60次。 声音通过对波形信号采样。 无损压缩和有损压缩。 2.2 数字 用来计数的数字（即1,2,3,4…）被称作自然数。我们用十进制计数，因为它有0~9共10个符号。并非所有数字都是自然数，还有负数、实数等 现代数字系统中，使用位置记数法表示十进制数，每个数位的值或权取决于它在数字中的位置。 2.2.1 位置记数法 按照位置记数法，一个n位的整数N的形式表示： 用小数点将整数部分和小数部分分开，可以对位置记数法进行扩展，使其能 表示实数。 一个用基数b的位置记数法表示的数的值被定义为： || | 采用位置记数法，一个数的数值等于它各位值的总和，而每一位的值则是该位的数值乘以它在数中的位置所对应的权。 如：十进制数1982 = 1 x 103 + 9 x 102 + 8 x 101 + 2 x 100二进制数10110.11 = 1x24 + 0x23 + 1x22 + 1x21 + 0x20 + 1x2-1 + 1x2-2 注意：十进制位置记数法不能精确表示所有小数，如1/3是0.3333333…33，二进制也是如此，如0.110 不能被精确转换为二进制形式。 2.3 二进制运算| 二进制算术运算规则与十进制基本相同，区别是基数不同。 下面列出了二进制加、减、乘法运算的规则： || ———————————————————— || || 两个位相加可能产生进位或借位，和十进制运算规则相同。 | 下面是4个8位二进制数相加的例子： 当两个二进制数相减时，会从左侧借一位，如： 下面描述了011010012（乘数）与010010012（被乘数）相乘的过程，两个n位 字相乘将产生一个2n位的积： 但是计算机并没有按照这种方式进行计算。 2.4 有符号整数 负数可以用多种不同的方式表示，计算机设计者选择了3种方法：符号及值表示法、二进制补码表示法、移码表示法，每种方法都有各自的优缺点。 2.4.1 符号及值表示法| 一个n位字可以表示从0~2n-1共2n个可能的值。如，一个8位的字可以表示0,1，…，254,255。表示负数的方法是用它的最高位表示符号，通常符号位为0表示正数，符号位为1表示负数。 下面两个8位有符号二进制00001101和10001101的值为： || ———————————————————— || | n位有符号的表示范围为-(2n-1-1) ~ +(2n-1-1)。一个8位有符号数的表示-127（11111111）~ +127（01111111）之间的整数。 有人反对该系统的一个原因是它有两个值都表示0：00000000 = +0 和 10000000 = -0 符号及值表示法没有被用于整数算术运算中，因为它的加、减法运行需要分别用加法器和减法器实现。符号及值表示法用于浮点算术运算中。 2.4.2 二进制补码运算 微处理器用二进制补码系统表示有符号整数，它可以将减法运算转换为对减数的补码的加法运算。 2.4.2.1 补码算术运算 一个数与它的补码之和是一个常数。如，一个一位十进制数与它的补码之和总是9。2的补码是7，因为2+7=9。在n位二进制算术中，数P的补码为Q且P+Q=2n。 在二进制算术中，求一个数的补码的方法是将其各位取反并加1。如：01100101的补码为10011010+1=10011011。 一个n位二进制数N的二进制补码定义为2n-N。如果N=5=00000101（8位二进制数），则N的补码为28-00000101=100000000-00000101=11111011 下面说明了8位二进制数的补码运算过程，将4个数+5、-5、+7、-7转换为补码： 将7与5的补码相加： 结果为9位二进制数100000010。如果忽略最左边一位（进位位），结果为000000102=+2，正是希望得到的结果。 将-7加5： 结果为11111110（进位位为0）。也是希望得到的结果-2，即28-2=100000000-00000010=11111110 n位二进制算术运算Z=X-Y，用X加上Y的补码完成运算：Y的补码为2n-Y，则Z=X+(2n-Y)=2n+(X-Y)。我们得到了需要的结果，X-Y，以及位于最左边的一个并不需要的进位（即2n），而这个进位被丢弃了。 一个数两次求补码得到该数本身。如-5=28-00000101=11111011。即-x=2n-x且-(-x)=2n-(2n-x)=x。 考虑下面加法实例： 2.4.2.2 求补运算 求补运算——为什么是取反加1 一个n位的二进制数N的补码，被定义为2n-N，则 如，8位（n=8）时有： 表达式11111111-N的值很容易计算，对N的第i位ni，若ni=0，则1-0=1，若ni=1，则1-1=0。显然： 所以计算N的补码就是将N的每一位取反加1。 下面的5位二进制数有： 这种求补码的方法的优点在于它很适合硬件实现。 2.4.2.3 补码的特点 1）补码是一个真正的互补系统，因为+X+(-X)=02）补码0被表示为00…0，是唯一的3）补码的最高位为符号位。如果符号位为0，则该数为正，符号位为1，则该数为负4）n位二进制补码数的表示范围为-2n-12n-1-1。对于n=8，补码范围为-1281275）补码加法和减法使用同样的硬件完成，因为补码减法由被减数的补码实现 2.4.2.4 运算溢出 N位二进制补码的表示范围为-2n-1~2n-1-1。 5位有符号二进制补码范围为-16~+15，考虑下面例子： 如果两个负数相加且结果小于-16，会超出5位二进制补码的范围，如： 如果操作数A和B的符号位相同，但结果的符号位与它们不同，则发生溢出。 2.5乘除法简介 除了加减法，计算机还必须实现乘法和除法。这两个操作比加减法复杂得多，所需的完成时间也长得多（或需要更复杂的硬件）。这里仅介绍乘法和除法的基本知识。 2.5.1 移位运算 首先介绍二进制补码的算术移位运算。 进行移位运算时，一个数的所有位都会向左或向右移动一位，如将00101100左移一位，变为01011000，右移一位，变为00010110。有些计算机每次可以移动多位。 二进制补码正数左移一位等价于该数乘2。如，十进制数39的二进制位00100111，左移一位得到01001110，对应于十进制数78。 下图描述了算术移位的过程： a）算术左移：最低位补0，最高位被复制到进位标志中，如11000101左移一位得到10001010b）算术右移：最高位补符号位，所有位右移一位。最低位复制到进位标志中。如00100101右移一位得到00010010。11100101右移一位得到11110010。 二进制数右移一位相当于它除以2。如00001100（即1210）右移一位得到00000110（即610），注意00001101（即1310）右移一位得到00000110（即610），因为移出的最低位被丢弃了。 考虑负数右移，11100010（即-30），右移一位得到11110001（即-15）。 2.5.2 无符号二进制乘法 计算机从乘数的最低位开始，每次检查一位，判断它是否为0，如果乘数的当前位为1则写下被乘数，若该位为0则写下n个0。接下来检查乘数的下一位，这时应从上一位数的左边一位开始写下被乘数或0。被写下的这一组数叫作部分积。得到所有的部分积后，加到一起，得到乘法结果： 乘法结果100000102 = 13010是一个8位二进制数。两个二进制数相乘得到一个2n位的积。 但是计算机并没有实现上面的算法，这种算法要求计算机存储n个部分积，然后将它们同时相加。更好的做法是每得到一个部分积就做一次加法。 下面给出了一个计算两个n位无符号二进制数相乘的算法：步骤a：将计数器的值置为n步骤b：将2n位的部分积寄存器清零步骤c：检查乘数的最右位（即最低位），将被乘数与部分积的最低位n位相加步骤d：将部分积右移一位步骤e：将乘数右移一位（乘数的最右位被丢弃）步骤f：将计数器的值减1，重复步骤c直到n个周期后计数器的值变为0。部分积寄存器的内容就是乘积结果。 2.5.3 快速乘法 通过移位和加法实现的乘法速度很慢，实际的计算机采用了多种方法加快乘法运算的速度。 有些程序员使用移位和加法等速度相对较快的操作避免使用乘法。考虑P乘以10和P乘以9的两个例子： 10P= 2x(2x2xP+P) ，即将P左移2次，加上P，再将和左移一次 9P= 2x2x2xP + P，即将P左移3次，加上P得到结果 乘法运算也可以借助查找表（look-up table）实现，这种方法将两个数相乘所有可能的积都保存在一个只读存储器内。这样只需简单的用X和Y的值找到表中的对应项就可以得到X和Y的乘积。如，两个8位二进制乘法需要一个16位地址、216项的查找表，每项记录一个16位的积。 缺点：太占空间了。 2.5.4 除法 除法是通过被除数不断地减去除数直到结果为0或小于除数来实现的。减去除数的次数称作商，最后一次减法的差称作余数。 被除数/除数 = 商 + 余数/除数 下面描述了575除以25的过程： 将被除数的下一个数字5移到7的后面，并比较除数和75，由于75正好是25的整数倍，因此在商的下一位上写下3： 因为已经处理到被除数的最后一位且75正好是测试的整数倍。除法结束，商为23，余数为0。 考虑用无符号二进制除法完成同样的例子： 被除数的前5位比除数小，因此商的最高位为0并将除数与被除数的前6位比较 ​ 被除数的前6位中有一个除数，减法后得到新的部分被除数为001010（1111），将被除数的下一位移下来 新的部分被除数小于除数，因此商的下一位为0，后续除法过程如下： 除法结果商为10111，余数为0。 2.5.4.1 恢复余数除法 刚刚讨论的除法方法，用计算机实现，需要修改的就是除数与部分被除数的比较方法，计算机减去并检测结果的符号位。如果减法的结果为正，则商1，如果结果为负，则商0并将部分被除数与除数相加，将其恢复为原先的值。 恢复余数除法算法：1）将除数的最高位与被除数的最高位对齐2）从部分被除数中减去除数，得到新的部分被除数3）如果新的部分被除数为负数，则商0并用新的部分被除数加上除数，恢复原先的部分被除数4）如果新的部分被除数为正，则商15）判断除法是否结束，如果除数的最低位与部分被除数的最低位对齐，则除法结束，最后的部分被除数就是余数。否则，执行第6步6）将除数右移一位，从第2步继续执行 下图描述了该算法的流程图： 按照流程图计算 011001112除以10012， 即十进制数103除以9， 结果为商11余4， 下表列出了除法的过程： 2.5.4.2 不恢复余数除法 不恢复余数除法与恢复余数除法基本相同，唯一区别在于取消了恢复余数的操作。 在恢复余数除法中，在部分被除数与除数相加恢复部分被除数之后的一个周期，部分被除数将减去除数的二分之一。每个将除数右移的操作等价于将除数除以2。当前周期恢复部分被除数以及下个周期减去除数一半的操作等价于部分被除数加上除数的一半。即D – D/2 = +D/2，D为除数。 | 下图给出了不恢复余数除法的流程图： 部分被除数减去除数之后，将检测新的部分被除数的符号位。若为负，则商左移1位，商的最低位补0，并将部分被除数加上除数的二分之一。若为正，则商左移1位，商的最低位补1，并将部分被除数减去除数的二分之一。 || ———————————————————— || || 下表列出了不恢复余数除法的过程： || || | 2.6 浮点数 浮点数即实数，实数是所有有理数和无理数的集合。 之所以叫作浮点数，是因为小数点在数中的位置并不是固定的。一个浮点数值分为两部分存储 ：数值以及小数点在数值中的位置。 计算机中的浮点运算的计算结果一般是不确定的，一块芯片上的浮点计算结果也许与另一块芯片上的不同。 科学计数法：来表示很大或很小的数。十进制浮点数可以被表示为：尾数x10指数，如1.2345x1020二进制浮点数可以被表示为：尾数x2指数，如1.0111x25IEEE 754浮点数标准提供3种浮点数表示：32位单精度浮点数、64位双精度浮点数、128位四精度浮点数 1. 规格化浮点数 IEEE 754浮点数的尾数总是规格化的，其范围为1.000…0x2e到1.111…1x2e，e为指数。规格化浮点数的最高位总是1，规格化使尾数的所有位都是有效的，因而尾数精度最高。如： 0.10…x2e规格化为1.10…x2e-1 10.1…2e规格化为1.01…x2e+1 尾数规格化充分利用了可用的最大精度。如，一个8位非规格化的尾数0.0000101只能有4位有效位，而规格化后的8位尾数1.0100011则有8位有效位。 2. 偏置指数 IEEE 754浮点数的尾数被表示为符号及值的形式，即用一个符号位表示它是正数还是负数。它的指数则用偏置方式表示，即给真正的指数加上一个常数。 假定所用的指数为8位，偏置值为127。如果一个数的指数为0，则被保存为0 + 127=127。如果指数为-2，则被保存为-2 + 127 = 125。 实数1010.1111规格化的结果为+1.010111x2^3，指数为+3，将被保存为3+127=130，即13010用二进制表示为10000010。 这种用偏置表示指数的方法优点在于，最小的负指数被表示为0，如果不采用这种方法，0的浮点表示为0.0…0x2最小负指数。采用偏置指数，0就可以用尾数0和指数0表示： 2.6.1 IEEE浮点数 一个32位IEEE 754单精度浮点数可以被表示为下面的二进制串： S EEEEEEEE 1.MMMMMMMMMMMMMMMMMMMMMMM S为符号位，指明这个数是正数还是负数E为8位偏置指数，指出了小数点的位置M为23位尾数 下图描述了32位浮点数的结构： S位为符号位，决定了数的符号，若S=0，则为正数，若S=1，则为负数。指数E将浮点数的尾数扩大或缩小2^E倍，并且偏置值为127。如浮点数+1.11001…0x2^12的指数为12+127=139(10)=10001011(2) 。 IEEE浮点数的尾数总是规格化的，其值范围在1.0000..00~1.1111..11，除非这个浮点数是0，此时尾数为0.000..00。 由于尾数总是规格化的，且最高位总是为1，因此将尾数存入存储器时没有必要保存最高位的1。所以，一个非0的IEEE 754浮点数可被定义为： S：符号位 E：偏置量为B的指数 F：尾数的小数部分（实际的尾数为1.F，有个隐含的1） 浮点数0被表示为S=0，E=0，M=0（即浮点数0用全0表示） 考虑下面的例子：将一个32位IEEE单精度浮点数X=11000001100110011000000000000000解压为一个符号位、一个偏置指数和一个尾数。 解压这3个字段得到：S = 1，E=10000011，F=00110011000000000000000实际的尾数为1. 00110011000000000000000，因此这个数为： -1. 00110011000000000000000 x 2^(10000011 – 01111111 ) = -1.00110011000000000000000 x 2^4 = -10011.0011 2.6.1.1 IEEE浮点数格式 ANSI/IEEE 745-1985标准定义了基本的和扩展的浮点数格式，以及一组数量有限的算术运算的规则（加、减、乘、除、平方根、求余和比较）。 非数（Not a Number，NaN）是IEEE 754标准提供的一个专门符号，代表IEEE 754标准格式所不能表示的数。 下图，IEEE 754标准定义了3种浮点数格式： 在32位IEEE 754单精度浮点数格式中，最大指数Emax为+127，最小指数Emin为-126，而不是+128~-127。Emin-1（即-127）用来表示浮点0，Emax+1用来表示正/负无穷大或NaN数。 下图，描述了IEEE单精度浮点数格式，指数E=0和E=255等特例分别被用于表示浮点0、非规格化小数、正或负无穷大、以及NaN： 2.6.1.2 十进制数转换为二进制浮点数的实例 将十进制数4100.12510转换为符合IEEE 754标准的32位单精度二进制浮点数？ 步骤：1）将4100.125转换为二进制定点数，整数部分4100(10)=1000000000100(2)，小数部分0.12510=0.0012，则4100.125(10)=1000000000100.001(2)2）将1000000000100.0012规格化为1.000000000100001 x 2(12)，则： 符号位S为0，该数为正数 指数为12 + 127 = 139(10) = 100010112尾数为0000000001000010000000（起始位1被省略，尾数扩展为23位）因此结果为0100010110000000001000010000000 2.6.1.3 二进制浮点数转换为十进制 将二进制浮点数11000100011011000000000000000000转换为十进制？ 步骤：1）分析得到符号位S =1，偏置指数E=10001000，尾数F=11011000000000000000000 2）偏置指数100010002减去127得到实际指数 100010002-01111111(2)=000001112=7(10)，则：这个数为：-1.11011000000000000000000(2) x 2^7 = -11101100(2) = -236(10) 2.6.2 IEEE浮点数的特点 1）浮点数接近0时的特点，下图描述了一个指数为2位，尾数为2位的浮点数系统。浮点数0表示为00 000，下一个规格化的正数表示为00 100（即2-bx 1.00，b为偏置常量）： 浮点数0附近有一块禁止区，其中的浮点数都是非规格化的，因此无法被表示为IEEE标准格式。这个数的指数和起始位都是0的区域，也可用来表示浮点数。但是这些数都是非规格化的，其精度比规格化数的进度低，会导致渐进式下溢。 2）IEEE标准规定，缺省的舍入技术应该向最近的值舍入3）IEEE标准规定了4种比较结果，分别是等于、小于、大于和无序（unordered），无序用于一个操作数是NaN数的情景4）IEEE标准规定了5种异常： a)操作数不合法：当程序员使用一些不合法的操作数。如NaN数、与无穷大数 相加或相减时、求负数的平方根等 b)除数为0 c)上溢：当结果比最大浮点数还大时。处理上溢的方法有终止计算和饱和运算（用最 大值作为结果）等 d)下溢：当结果比最小浮点数还小时。也就是说，结果小于2Emin。下溢可以通过将 最小浮点数设为0或用一个小于2Emin的非规格化数表示最小浮点数等方式处理 e)结果不准确：当某个操作产生舍入错误时 2.7 浮点运算 浮点数不能直接相加。 下面以一个简单的8位尾数和一个未对齐的指数为例说明浮点运算，A=1.0101001x2^4，B=1.1001100x2^3。若要计算两个数的乘积，应将尾数相乘，指数相加： 浮点数的加法，笔算时，将A与B的小数点对齐： 由于浮点操作数已被表示为规格化形式，计算机在进行浮点加法时面临以下问题： 为了对齐指数，计算机必须执行下面步骤：第1步，找出指数较小的数第2步，使两个数的指数相同第3步，尾数相加（或相减）第4步，如果有必要，将结果规格化 因为B的指数比A小，将B转为0.110011x2^4，将A与非规格化的B相加： 对结果规格化，得到1.00001111x2^5 下图，给出了浮点加法运算的流程： 注意：1）因为指数有时与尾数位于同一个字中，在加法过程开始之前必须将它们分离开（减压缩） 2）如果两个指数的差大于p+1，p为尾数的位数，较小的数由于太小而无法影响较大的数，结果实际就等于较大的数。如，1.1010x2^60+1.01x2^-12的结果为1.1010x2^60，因为指数之差为72 3）结果规格化时检查指数范围，以分别检测指数下溢或上溢。指数下溢会导致结果为0，而指数上溢会造成错误。 1. 舍入和截断误差 浮点运算可能引起尾数位数的相加，需要保持尾数位数不变的方法。最简单的技术叫作截断。 如，将0.1101101截断为4位尾数的结果为0.1101。截断会产生诱导误差（即误差是由施加在数上的操作计算所引起的），诱导误差是偏置的，因为截断后的数总比截断前小。 舍入是一种更好的减少数的位数的技术。如果丢弃的位的值大于剩余数最低位的一半，将剩余数的最低位加1。 考虑两个数在小数点后第4位上舍入的例子： 下图描述了舍入机制： 1）最简单的舍入机制是截断或向0舍入。2）“向最近的数舍入”方法会选择距离该数最近的那个浮点数作为结果。3）“向正或负无穷大舍入”方法会选择正或负无穷大方向上最近的有效浮点数作为结果。当要舍入的数位于两个连续浮点数的正中时，IEEE舍入机制选择最低位为0的点（即向偶数舍入）。 2.8 浮点运算和程序员 整数操作时精确、可重复的，浮点数操作是不精确的。 考虑表达式z = x^2-y^2，x、y、z都是实数。可以将表达式视作x^2-y^2或(x+y)(x-y)计算，整数运算得到相同结果，但浮点数运算可能得到不同结果。 IEEE要求加、减、乘和除运算结果能够精确计算，并用向偶数舍入的方法将结果舍入为最近的浮点数。 2.8.1浮点运算中的误差传播2.8.2生成数学函数 sin(x) —-&gt;泰勒级数 二、指令集体系结构三、体系结构与组成 计算机的指令集体系结构（ISA）从汇编语言程序员的角度描述了计算机，并强调了计算机的功能，而不是它的内部组成或实现。ISA说明了计算机能做什么，而计算机组成则说明了它是如何做的。 3.1 存储程序计算机 （1）ARM这一类处理器采用了存储程序体系结构，它将程序和数据放在同一个存储空间内，采用取指-执行模式执行，即按照顺序从内存读取指令、译码、执行。 （2）寄存器是位于CPU内部的存储单元，类似于内存中的存储单元。寄存器使用名字而不是地址来访问，如r0，r1，……，r15（ARM的命名），或是AX，BX，CX，DX，SP，BP，SI（Intel命名），或是D0，D1，……，D7（Freesacle的命名）。 （3）计算机指令的操作码可以使用很少的几位来引用寄存器，指令中用来选择寄存器的字段一般为3~5位，具体数值取决于计算机中程序可见寄存器的个数。 （4）CPU中的寄存器有几个功能，一些寄存器是高速暂存寄存器，用于保存数据或数据单元的地址（即指针）。另外一些事特殊功能寄存器，如对一个循环的次数进行计数的循环计数器，有的用来记录处理器的状态。CPU中最重要的寄存器是程序计数器（PC），它记录了要执行的下一条指令的地址。 （5）计算机指令有多种格式，通用计算机提供了以下3种指令格式： LDR 寄存器目的,存储单元源 STR 寄存器源,存储单元目的 Operation 寄存器目的,寄存器源1,寄存器源2 如： LDR r1,1234 ​ LDR指令把数据从存储器复制到寄存器，将地址为1234的存储单元中 的数据 读到寄存器r1中 ​ STR r2,2000 ​ STR指令把数据从寄存器传输到存储器，将寄存器r2的值写入地址为 2000的存 储单元 ​ ADD r1,r2,r3 ​ 将寄存器r2和r3中的内容相加，把结果写入寄存器r1，因此，r2和r3 的内容保 持不变 下图，描述了存储程序计算机的功能图： 下图，给出了虚拟的 存储程序计算机的结构： 图中寄存器定义如下：MAR： 存储器地址寄存器，保存了读或写操作正在访问的存储单元的地址 MBR： 存储器数据寄存器，保存了刚从存储器中读出的数据，或将要写入存储器的数据 PC： 程序计数器，保存了要执行的下一条指令的地址 IR： 指令寄存器，存放最近从存储器中读出的指令，也就是当前正在执行的指令 r0-r7： 寄存器文件，包括8个通用目的寄存器r0，r1，…，r7，用于存放临时数据 下述RTL表明了下图中的处理器如何读取并 执行LDR r1,1234的： 1. 寄存器的可见性 寄存器有3种类型：通用寄存器，用来保存计算过程产生的临时数据。ARM有16个通用寄存器，r0,r1….,r15。寄存器r14和r15是通用寄存器，程序员可以访问这两个寄存器，然而，r14与r15又在ARM体系结构中扮演着特殊角色。 特殊功能寄存器，用于特定功能。如，PC指向要执行的下一条执行指令。其他特殊功能寄存器还有状态寄存器、栈指针寄存器以及CPU标识寄存器等。 不可见寄存器，不属于处理器体系结构的一部分，不能被程序员直接使用。如，指令寄存器IR和内存地址寄存器MAR等，这些都是实现计算机所必需的，但又不属于ISA的一部分。 为什么程序计数器要加4 计算机存储器按照字节编址，各个字节存储单元依次命名为0，1，2…。但是32位微处理器使用32位指令和32位字数据。 因此每一次取指后PC必须加4，因为4字节x8位/字节=32位=1指令字。 3.1.1 扩展处理器：常量处理 LDR r1,1234，这里的“1234”是指地址为1234的存储单元的内容。假设要将数值1234载入寄存器r1中，这样的数字叫作立即操作数。立即数是一个在运算中可以直接使用的数，与存储单元的值完全不同，需要用哈希符号**(#)前缀**来声明。如： 汇编指令 RTL表示 LDR r1,200 [r1]&lt;- [200] LDR r1,#200 [r1]&lt;-200 ADD r0,r1,#25 | 下图描述了实现立即数操作所需的新数据路径： || ———————————————————— || | 2. 一些常用指令 类ARM指令： LDR r0,address STR r0,address ADD r0,r1,r2 SUB r0,r1,r2 ；r0=r2-r1 BPL target ; 如果前一个操作结果大于等于0，则跳转到 target处 BEQ target ; 如果前一个操作结果为0，则跳转到target处 B target ; 无条件跳转到地址为target处 3.1.2 扩展处理器：流控制 流控制是指任意能够改变程序中指令顺序执行的动作，它是指计算机非顺序执行指令的能力。 流控制是指转移到程序中特定位置的分支和跳转指令、子程序/过程调用，返回、中断以及操作系统调用。 流控制的典型例子就是条件行为，它允许处理器在两个可能的动作序列中选择一个执行。 | 下图显示了计算机实现条件控制所需的信息通路： || ———————————————————— || | 下述代码段描述了一个条件分支的行为： SUBS r5，r5，#1 ; r5减1 BEQ onZero ; 如果r5为0则跳到标号onZero处执行 notZero ADD r1，r2，r3 ; 否则继续执行 . . onZero SUB r1, r2, r3 ; 分支的转移目的地伪代码表示： if zero then r1 = r2 – r3 else r1 = r2 + r3 3. 条件码寄存器（Condition Code Register，CCR） ALU的信息将被写入条件码寄存器（Condition Code Register，CCR），它保存了各种用于测试的条件（如，零、负、正）。当ALU执行一个操作时，它会更新CCR中的零位、借位位、负位以及溢出位。 3.1.2扩展处理器： 流控制 下图说明了ALU运算的结果如何 被反馈给程序计数器PC， 以选择实现控制转移的指令： 从使用PC中的地址到存储器地址中取出条件分支指令开始。分支指令读出CCR的内容，其内容由上一条指令的结果决定。在执行时，条件分支指令将完成以下两个动作中的一个： 1）如果CCR中的测试位为false，则处理器从[PC]+4处取出下一条指令2）如果CCR中的测试位为true，则PC从IR的操作数字段载入新的地址，并跳转到新地址处执行 （1）状态信息计算机执行一个操作时，将状态或条件信息保存在CCR中，处理器记录下结果是否为0（Z），结果的二进制形式是否为负（N），是否产生进位位（C），是否算术溢出（V）。 考虑下述例子中8位加法对CCR中位的影响： 更新CCR还是不更新CCR？CCR中的位会在每次操作后被更新，这一说法并不完全准确。不同处理器的情况完全不同。Intel IA32和Fresscale 68K那样的CISC处理器会在每次操作后自动更新状态标志，而ARM那样的RISC处理器则需要程序员来强制更新状态标志。ARM处理器，需要在指令中添加后缀“S”（如SUBS、ADDS）来完成。如CMP（比较）和TST（测试），会自动更新状态标志位，不需要添加后缀“S”。 （2）分支指令例子例1：如何使用条件分支指令BEQ address来实现高级语言结构？首先处理器用IR中BEQ指令的操作码字段选出CCR中的一位进行测试（如Z、N或C位），如果被测试的位为1，则PC载入一个新地址（即分支目标地址），否则PC不变。 ​ 汇编语言表示：​ BEQ address ; 如果Z标志位为1，则跳转到address处​​ RTL表示：​ IF [Z] = 1​ THEN [PC] &lt;- RTL表示： 下图说明了上述代码是如何在虚拟计算机上执行的，它考虑了两种情形：情形1：P = 12，Q = 9，分支转移成功，控制转移到分支目标地址情形2：P = 12，Q = 14，分支转移不成功，控制转移到PC + 4 例3：在循环中使用条件分支来计算1+2+3+…+20 LDR r0,#1 ; 把1放入寄存器r0中 LDR r1,#0 ; 把0放入寄存器r1中Next ADD r1,r1,r0 ; 重复：当前计数值与部分和相加 ADD r0,r0,#1 ; 计数值加1 CMP r0,#21 ; 20个数是否都已加完 BNE Next ; 直到：完成20次迭代 STOP ; 若完成，则停止 3.2 ISA的组成 ISA的3个组成部分：寄存器集、寻址方式和指令格式 3.2.1 寄存器 片内的一个指针寄存器保存了存储器中寄存器的地址。 寄存器对于提高计算机性能和实际指令集设计是很有必要的。 设计一条ADD P=Q+ R的计算机指令，P、Q、R都是存储地址。假设操作码为16位（ADD部分），地址空间为32位，则指令长度为16 + 32 +32 +32 = 112位，如下图： 典型的真实计算机的指令长度为16位或32位，所以112位的指令长度是不可行的。 实际计算机用寄存器实现片上存储，寄存器的功能与存储单元一样，唯一的区别在于访问的便捷性和响应时间。仅需很少的指令就可以指定一个片上寄存器。如，某计算机的操作码为8位，带有8个片上寄存器（用3位就可以访问r0-r7中一个），就能用8 + 3+3+3=17位实现指令ADD P = Q+ R。如图：某计算机有3个5位操作数地址字段，可以寻址32个寄存器，32位指令字中余下的17位用于指令操作码和额外的控制字段 3.2.2 寻址方式概述 指令对数据进行操作，并且必须将数据移动到其被处理的地方。指定数据的方式统称为“寻址方式”。 3种基本寻址方式为： 1）立即数寻址 2）直接寻址 3）间接寻址 4. 立即数寻址 最简单的寻址方式，其操作数是指令的一部分。 如操作P= Q+5，这里的5就是立即数，它没有被保存在存储单元或寄存器中，而是指令的组成部分。 ARM处理器使用前缀#指定立即操作数，如ADD r1,r2,#5完成了操作[r1] &lt;-[r2]+5 5.直接寻址 也称作绝对寻址。把操作数地址用作指令的一部分。如指令ADD P,Q,R表示将存储单元Q的内容与存储单元R的内容相加，并将结果保存在存储单元P中。 直接寻址在CISC计算机上得到广泛使用，如Intel IA32或68K系列，Load/store型计算机，如ARM，没有实现直接寻址。 6.间接寻址 更严格地说，叫作寄存器间接寻址。在寄存器间接寻址中，指令给出了包含操作数地址的寄存器的地址。 获得一个操作数需要3次访问：读指令，读含有操作数地址的寄存器，以及最后读出实际的操作数。 含有操作数地址的寄存器称作指针寄存器。Load/store型计算机（如ARM），使用这种寻址方式访问存储器操作数。 如，ARM指令LDR r1,[r2]表示将寄存器r2所指的存储单元的内容加载到寄存器r1中。 以下分别是ARM、Intel IA32和Freescale 68K的汇编语言语句： LDR r1,[r2] ; 将寄存器r2所指存储单元的内容复制到寄存器r1中 MOV ax,[bx] ; 将寄存器bx所指存储单元的内容复制到寄存器ax中 MOVE (A5),D2 ; 将寄存器A5所指存储单元的内容复制到寄存器D2中 寄存器间接寻址有许多变种，最常用的格式是带偏移量的寄存器间接寻址，其中操作数的地址由寄存器内容加上常量或偏移量指定。 典型格式为： LDR r2,[r3,#8] ; 把寄存器r3+8所指存储单元的内容复制到寄存器r2中 MOV ax,[12,bx] ; 把寄存器bx+12所指存储单元的内容复制到寄存器ax中 MOVE (16,A5),D2 ; 把寄存器A5+16所指存储单元的内容复制到寄存器D2中 如图，描述了这些寻址方式的处理过程：、 7. 存储器与寄存器寻址 寄存器与存储单元之间没有本质区别，其区别主要体现在它们的相对访问速度以及指定一个寄存器和一个存储单元所需的地址位数上。 由此推出，这些计算机不支持存储器-存储器型寻址方式 3.2.4 操作码与指令 计算机体系结构设计中最重要的一个因素是每条指令中操作数地址的数量。 如，实现了指令ADD r1,r2,r3的指令集是三地址计算机，而实现了ADD r1,r2指令的计算机是双地址计算机。在此主要介绍三地址、双地址、单地址、零地址的计算机。 考虑下面例子，指令带有0~3个操作数，操作数P、Q、R是存储单元或寄存器 ​ 操作数 指令 作用​ 3个 ADD P,Q,R Q与R相加，结果存放在P中​ 2个 ADD P,Q Q与P相加，结果存放在P中​ 1个 ADD P P与累加器相加，结果存放在累加器中​ 0个 ADD 从栈顶弹出两个数相加，结果放在栈顶 204Page","categories":[],"tags":[]},{"title":"Jwt","slug":"Jwt","date":"2022-02-04T08:53:53.000Z","updated":"2022-02-04T09:05:34.753Z","comments":true,"path":"posts/jwt/","link":"","permalink":"https://dahammer666.github.io/posts/jwt/","excerpt":"","text":"六、设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } }","categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"}],"tags":[]},{"title":"Test","slug":"Test","date":"2022-01-29T07:03:58.000Z","updated":"2022-01-29T14:12:36.958Z","comments":true,"path":"posts/784dd132/","link":"","permalink":"https://dahammer666.github.io/posts/784dd132/","excerpt":"","text":"1 2","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2022-01-29T04:02:19.000Z","updated":"2022-01-29T14:24:08.165Z","comments":true,"path":"posts/c0add594/","link":"","permalink":"https://dahammer666.github.io/posts/c0add594/","excerpt":"","text":"一、VUE简介 项目结构经历的三个阶段 后端MVC：它是单体结构，流程控制是由后端控制器来完成的 前端MVC：前后端分离开发，后端只负责接收响应请求 MVVM：前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据的数据设置“VM”，HTML从vm中取值。 M model 数据模型，指的是从后端接口返回的数据 (前端发送请求，后端接收数据) V view 视图（HTML） VM ViewModel（js） 视图模型，数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据。 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据{{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str1(){ } str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为`@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换 十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[],"tags":[]},{"title":"测试博客","slug":"测试博客","date":"2022-01-27T09:55:34.000Z","updated":"2022-02-04T09:02:00.036Z","comments":true,"path":"posts/d9407122/","link":"","permalink":"https://dahammer666.github.io/posts/d9407122/","excerpt":"","text":"TT title: 博客与博主comments: truetoc: truecover: https://s4.ax1x.com/2022/01/28/7x30g0.pngcategories: 生活tags: 想法abbrlink: 1date: 2021-5-27 21:00:00 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true 安装插件: npm install https://github.com/CodeFalling/hexo-asset-image -- save 运行hexo n \"XXXXXX\", 生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。 添加图片: 在想添加的位置写入![](图片名字.图片格式),例如![](1.png)。图片的路径和你写入的路径一致。 hexo-abbrlink导致图片不能显示 在安装了hexo-abbrlink后博客图片无法正常显示（用的是hexo-asset-image） 之前_config.yml中配置如下 permalink: archives/:abbrlink.html 在hexo g后时观察到，文章中的连接被重定向的位置，与图片在public中的文件位置不相符解决：根据参考重写_config.yml permalink: posts/:abbrlink/ 删除文件命令行 rm -rf xxx （xxx - 文件名）","categories":[{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}],"categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"},{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}