{"meta":{"title":"TT","subtitle":"DaChui","description":"多搞学习就好了","author":"DaChui","url":"https://dahammer666.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-01-29T04:58:56.000Z","updated":"2022-01-29T03:28:32.892Z","comments":false,"path":"about/index.html","permalink":"https://dahammer666.github.io/about/index.html","excerpt":"","text":"TT“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我座右铭：钱难赚，屎难吃"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://dahammer666.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://dahammer666.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://dahammer666.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://dahammer666.github.io/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://dahammer666.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://dahammer666.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T03:48:51.191Z","updated":"2022-01-29T03:48:51.191Z","comments":false,"path":"List/gallery/index.html","permalink":"https://dahammer666.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片 TT 關於head的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://dahammer666.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-01-28T06:56:56.575Z","comments":false,"path":"List/music/index.html","permalink":"https://dahammer666.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://dahammer666.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T14:56:13.000Z","updated":"2022-01-29T03:43:19.826Z","comments":false,"path":"List/gallery/head/index.html","permalink":"https://dahammer666.github.io/List/gallery/head/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://dahammer666.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"shopFM","slug":"shopFM","date":"2022-02-14T14:48:55.000Z","updated":"2022-02-14T15:29:54.078Z","comments":true,"path":"posts/shopfm/","link":"","permalink":"https://dahammer666.github.io/posts/shopfm/","excerpt":"","text":"一、项目介绍1.1 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.2 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.2.1 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、数据库设计 4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、设计及实现—用户管理 6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息 14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper） 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现微信支付 为商家提供代理收款服务 1.微信支付业务-商户需要注册微信支付业务 商户编号：3454563 商户账号：23435 商户编号appID： werselfjldsjhtoieiurt0 商户密钥：sdfsdlkfjdslkjfFGFGDSRTG89 2. 微信支付业务-商户注册微信支付业务 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1导入微信支付Maven依赖 wxpay的maven依赖生成 &lt;!-- https://mvnrepository.com/artifact/com.github.wxpay/wxpay-sdk --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类： 创建一类，实现WxPayConfig接口 重写三分方法，分别设置AppID\\商户ID\\商户密钥 package com.qfedu.fmmall.config; import com.github.wxpay.sdk.WXPayConfig; import java.io.InputStream; public class MyPayConfig implements WXPayConfig { //商户账号 @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } //商户appID @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } //商户的密钥 @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.2和微信的接口进行相关的参数设置和获取微信支付链接2.21创建自己的url,PayController类：package com.qfedu.fmmall.controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/pay\") public class PayController { @PostMapping(\"/success\") public void success(){ } } 2.22添加订单快照成功生成支付链接必须设置的配置参数： // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPay; import com.qfedu.fmmall.config.MyPayConfig; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultStatus; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @CrossOrigin @RequestMapping(\"/order\") @Api(value = \"提供订单相关的接口\",tags = \"订单管理\") public class OrderController { @Autowired private OrderService orderService; @PostMapping(\"/add/{cids}\") public ResultVO add(@PathVariable(\"cids\") List&lt;Integer&gt; cids, @RequestBody Orders orders){ ResultVO resultVO=null; // 测试用的OrderId try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, orders); String orderId=orderInfo.get(\"orderId\"); // 订单快照创建成功，申请支付链接 HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;(); // 设置当前订单信息 data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId);//使用当前用户订单编号作为当前支付交易的交易编号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\", orders.getActualAmount()+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\");//交易类型 // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); WXPay wxPay=new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); // 把微信支付平台生成的链接获取到 orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO=new ResultVO(ResultStatus.OK,\"提交订单成功！\",orderInfo); System.out.println(resp); // code_url -&gt; weixin://wxpay/bizpayurl?pr=Iv5Fsq6zz } catch (SQLException e) { resultVO= new ResultVO(ResultStatus.NO,\"下单失败\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } }","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2022-02-14T13:21:33.000Z","updated":"2022-02-14T15:31:27.131Z","comments":true,"path":"posts/computermanage/","link":"","permalink":"https://dahammer666.github.io/posts/computermanage/","excerpt":"","text":"一、计算机系统体系结构1.1 术语体系结构的三种用法 指令集体系结构（ISA） ​ 描述了程序员看到的计算机的抽象视图，并且定义了汇编语言和编程模型。之所以说它是抽象的，是因为它并没有考虑计算机的实现。 微体系结构（具体实现） ​ 描述了一种指令集体系结构的实现方式。微体系结构关注计算机的内部设计。 系统体系结构 ​ 关注包括处理器、存储器、总线和外设在内的整个系统。 计算机系统体系结构所涉及的内容 1.2 什么是计算机体系结构 计算机系统包括读取并执行程序的中央处理单元（Central processing unit,CPU），保存程序和数据的存储器，以及输入输出子系统，这些子系统会使CPU与显示器、打印机等外部设备之间的通信变得更加容易。 计算机中实际执行程序的部分叫做CPU，或者更简单地被称作处理器。微处理器则是在单个硅片上实现的CPU。围绕着微处理器构建的计算机被称作微机。 尽管CPU是计算机的核心，计算机的性能既取决于CPU，也取决于其他子系统的性能。如果不能高效进行数据传输，仅仅提高CPU的性能是毫无意义的。 简单通用计算机结构 1.2.1 简单通用计算机结构 信息（即程序和数据）保存在存储器中，为了实现不同的目标，计算机会使用不同类型的存储器，如Cache、主存、辅存等多个存储层次，大多数处理器都在CPU内集成了片上Cache。 Cache是存放常用数据的高速、专用存储器。主存中存放了大量的工作数据。辅存是指磁盘和CD-ROM，能够存储海量数据。 组成计算机的各个子系统通过总线连接在一起，数据通过总线从计算机中的一个位置传递到另一个位置。 可编程计算机接收两种类型的输入：要处理的数据，以及要如何处理输入数据的程序。程序不过是计算机所执行的完成给定任务的操作序列。 数字计算机的结构，可以被分为两部分：中央处理单元和存储器系统。CPU读程序并完成程序指定的操作。存储器系统保存两类信息：程序，程序处理或产生的数据。 寄存器是CPU内部用来存放数据的存储单元。 时钟提供了脉冲流，所有内部操作都在时钟脉冲的触发下进行。时钟频率是决定计算机速度的一个因素。","categories":[],"tags":[]},{"title":"Jwt","slug":"Jwt","date":"2022-02-04T08:53:53.000Z","updated":"2022-02-04T09:05:34.753Z","comments":true,"path":"posts/jwt/","link":"","permalink":"https://dahammer666.github.io/posts/jwt/","excerpt":"","text":"六、设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } }","categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"}],"tags":[]},{"title":"Test","slug":"Test","date":"2022-01-29T07:03:58.000Z","updated":"2022-01-29T14:12:36.958Z","comments":true,"path":"posts/784dd132/","link":"","permalink":"https://dahammer666.github.io/posts/784dd132/","excerpt":"","text":"1 2","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2022-01-29T04:02:19.000Z","updated":"2022-01-29T14:24:08.165Z","comments":true,"path":"posts/c0add594/","link":"","permalink":"https://dahammer666.github.io/posts/c0add594/","excerpt":"","text":"一、VUE简介 项目结构经历的三个阶段 后端MVC：它是单体结构，流程控制是由后端控制器来完成的 前端MVC：前后端分离开发，后端只负责接收响应请求 MVVM：前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据的数据设置“VM”，HTML从vm中取值。 M model 数据模型，指的是从后端接口返回的数据 (前端发送请求，后端接收数据) V view 视图（HTML） VM ViewModel（js） 视图模型，数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据。 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据{{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str1(){ } str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为`@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换 十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[],"tags":[]},{"title":"测试博客","slug":"测试博客","date":"2022-01-27T09:55:34.000Z","updated":"2022-02-04T09:02:00.036Z","comments":true,"path":"posts/d9407122/","link":"","permalink":"https://dahammer666.github.io/posts/d9407122/","excerpt":"","text":"TT title: 博客与博主comments: truetoc: truecover: https://s4.ax1x.com/2022/01/28/7x30g0.pngcategories: 生活tags: 想法abbrlink: 1date: 2021-5-27 21:00:00 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true 安装插件: npm install https://github.com/CodeFalling/hexo-asset-image -- save 运行hexo n \"XXXXXX\", 生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。 添加图片: 在想添加的位置写入![](图片名字.图片格式),例如![](1.png)。图片的路径和你写入的路径一致。 hexo-abbrlink导致图片不能显示 在安装了hexo-abbrlink后博客图片无法正常显示（用的是hexo-asset-image） 之前_config.yml中配置如下 permalink: archives/:abbrlink.html 在hexo g后时观察到，文章中的连接被重定向的位置，与图片在public中的文件位置不相符解决：根据参考重写_config.yml permalink: posts/:abbrlink/ 删除文件命令行 rm -rf xxx （xxx - 文件名）","categories":[{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}],"categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"},{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}