{"meta":{"title":"TT","subtitle":"DaChui","description":"多搞学习就好了","author":"DaChui","url":"https://dahammer666.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-01-29T04:58:56.000Z","updated":"2022-01-29T03:28:32.892Z","comments":false,"path":"about/index.html","permalink":"https://dahammer666.github.io/about/index.html","excerpt":"","text":"TT“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我座右铭：钱难赚，屎难吃"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://dahammer666.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://dahammer666.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://dahammer666.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://dahammer666.github.io/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://dahammer666.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://dahammer666.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T03:48:51.191Z","updated":"2022-01-29T03:48:51.191Z","comments":false,"path":"List/gallery/index.html","permalink":"https://dahammer666.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片 TT 關於head的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://dahammer666.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-01-28T06:56:56.575Z","comments":false,"path":"List/music/index.html","permalink":"https://dahammer666.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://dahammer666.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T14:56:13.000Z","updated":"2022-01-29T03:43:19.826Z","comments":false,"path":"List/gallery/head/index.html","permalink":"https://dahammer666.github.io/List/gallery/head/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://dahammer666.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"javaBase","slug":"javaBase","date":"2022-02-17T08:03:11.000Z","updated":"2022-03-01T19:21:38.964Z","comments":true,"path":"posts/javabase/","link":"","permalink":"https://dahammer666.github.io/posts/javabase/","excerpt":"","text":"一、javaBase1.1 Java特性 简单性 面向对象 可移植性（跨平台） 高性能 分布式 动态性（反射） 多线程 安全性（安全） 健壮性 1.2 Java三大版本 Java SE: 标准版（桌面程序） Java ME: 嵌入式开发（手机、小家电） Java EE: E企业级开发（web端，服务器开发） 1.3 JDK、JRE、JVM是什么？ jdk:在jre之上扩充一些开发工具，让我们开发者使用的 jre:运行时环境，只要安装了jre，就可以运行我们的java程序了、一般我们只需要下载安装jadk即可，因为jdk包含了jre。 jvm:java虚拟机，把它当做一种规范，可以用软件来实现，也可以用硬件来实现。它就相当于在所有的操作系统上模拟了一个小小的cpu，去处理我们java相关的东西。java的跨平台核心是使用了java虚拟机，在不同的操作系统上安装jvm。 Java是大小写敏感的语言 1.4 Java程序的运行机制编译型 ​ 把整个程序编译 解释性 ​ 给出命令，执行语句（网页js,便解释，边执行） java属于上面两种类型，先编译，再解释 二、java基础语法2.1 注释注释并不会被执行，是写给我们写代码的人看的 单行注释 //单行注释 多行注释 /* 多行注释 */ 文档注释 /** * @Description Hello World * @Autor: Dahammer */ 2.2 标识符Java 所有的组成部分都需要名字。类名、变量名、以及方法名都被成为标识符。所有的标识符都应该以A-Z或者a-z、美元符号$、下划线_开始 2.3 数据类型强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义才能使用。 弱类型语言： JS 强类型语言安全，但是速度慢！ java是一种强类型语言，要求十分严格。 基本数据类型 整数型：byte(1字节)、short(2字节)、int(4字节)、long(8字节)long类型要在后面加上L，（可以省略，超出int的范围时需要加L） 浮点型：float(4字节)、double(8字节)float类型 要在数字后面加f 字符型：char（2字节） 布尔型：boolean（1位）是非对错 引用数据类型 除了基本数据类型之外的，都叫引用类型。 类 接口 数组 枚举 2.4 什么是字节 位(bit): 是计算机内部数据，存储的最小单位.11001100是一哥八位二进制 字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示；1B（byte字节）=8bit(位) 字符：是指计算机中使用的字母、数字和符号 常见的单位换算 1bit 表示 1位 1byte 表示一哥字节 1B = 8bit 1024b = 1kb 1024M = 1G 1024G = 1TB 2.5 进制问题 进制说明 二进制： 0b 十进制：默认 八进制：0逢八进1 十六进制：0X逢十六进1 银行业务用什么表示？用BigDecimal类 数学工具类 不能使用浮点数。 float:浮点数是有限的射入误差，大约接近但不等于 double: 最好完全使用浮点数进行比较 public static void main(String[] args){ int i1 =10; int i2 = 010; int i3 = 0x10; System.out.println(i1); //10 System.out.println(i2); //8 System.out.println(i3); //16 float f = 0.1f //0.1 double d = 1.0/10; //0.1 System.out.println( f == d); //false } 字符扩展 char c1 = 'a'; char c2 = '中'; System.out.println(c1); System.out.println((int)c1);//97 强制转换 System.out.println(c2); System.out.println((int)c2); //20013 所有的字符本质还是数学 编码问题 Unicode表： (97 = a, 65 =A)编码占了两个字节 转义字符 \\t制表符 \\n换行 2.6 类型转换 通过查看byte包装类型得到：byte 最大值信息 public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。 低—–&gt;高 byte、short、char、int、float、long、double 运算中，不同类型的数据先转换为同一类型，然后进行运算。（小数优先级高于整数） 强制类型转换 高到低 int i =128; double d = i; System.out.println(i); //128 System.out.println(d); //128.0 总结： 不能对布尔类型进行转换。 不能把对象类型转换为不相干的类型 在吧高容量转换为低容量的时候，需要强制转换。 转换的时候可能存在内存溢出，或者精度问题。 2.7 变量Java是一门强类型语言，每一个变量必须声明其类型。 Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。 格式： ​ 数据类型 变量名 值; 作用域： ​ 局部变量：类中方法内：局部变量必须声明和赋值 ​ 成员变量：类中方法外：示例变量从属于对象，如果不自行初始化，这个类型的默认值：0.0.0/布尔值默认是：false、除了基本类型，其余的默认是null ​ 2.8 常量常量：初始化后不能变动的值 final 数据类型 常量名 = 常量值 final double PI = 3.14; 修饰符不存在先后顺序。 2.9运算符 算数运算符：+ 、-、*、/、++、– 赋值运算符：= 关系运算符：==、！=、&lt;、&gt;、&lt;=、&gt;=、instanceof 逻辑运算符：&amp;&amp; || ! 位运算符：&amp; 、|、 ^、 &gt;&gt;、 &lt;&lt;、 &gt;&gt;&gt; 条件运算符：? 扩展赋值运算符：+=、-+、*=、/= 一元运算符 自增 ++ int a = 3; int b = a++; //++在后，先赋值，后+1 int c = ++a; //++在前，先+1，再赋值 System.out.println(a); //5 System.out.println(b); //3 System.out.println(c); //5 //自减 -- 逻辑运算符 与 and &amp;&amp; 或 or 非 取反 位运算 /* A = 0011 1100 B = 0000 1101 ------------------------------------------------------- 拿上面的数字跟下面的去比较 A&amp;B 如果两个都是1，才为1 = 0000 1100 A|B 如果对应为都是0，结果为0，否则是1 = 0011 1101 A^B 如果如果两个相同，则为0，否则为1 = 0011 0001 ~B 取反，如果是1则为0，如果是0则为1 = 1111 0010 */ 面试题：2 * 8 = 怎么计算最快？ /* 2*8=16 2*2*2*2 效率极高 0000 0000 0 0000 0001 1 0000 0010 2 0000 0011 3 0000 0100 4 0000 1000 8 0001 0000 16 &lt;&lt; 左移 把数字 * 2 &gt;&gt; 右移 把数字 / 2 */ System.out.println(2&lt;&lt;3);//16 面试题： int a = 10; int b = 20; System.out.println(\"\"+a+b);//1020 System.out.println(a+b+\"\");//30 三元运算符 x ? y : z 如果x == ture,则结果为y，否则为z String flag = score &lt; 60 ? \"不及格\" : \"及格\"; System.out.println(flag);//及格 2.10 包机制为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。 包语句的语法格式为： package pgk1[.pck2[.pck3]]; package 必须放在类中所有语句的最上面（第一行代码） 导包 import pgk1[.pck2[.pck3]].(classname | *); 三、java流程控制3.1 Scanner 类通过scanner 类的next() 与nextLine()方法获取输入的字符串，在读取我们一般需要使用hashNext() 与 hasNextLine() 判断是否还有输入的数据 Scanner sc = new Scanner(System.in); public static void main(String[] args) { //从键盘接收数据 Scanner sc = new Scanner(System.in); System.out.println(\"使用next方式接收：\"); //判断是否还有输入 if (sc.hasNext()){ //next() 只读取第一个字符串 //String str = sc.next(); //nextLine() 获取一行数据 String str = sc.nextLine(); System.out.println(\"用户输入是：\"+str); } sc.close(); } next(): 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next（）方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next（）方法不能得到有空格的不能得到有空格的字符串 nextLine() 以Enter为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符 可以获得空白。 3.2 顺序结构Java的基本结构就是顺序结构，除非特别指明，否则按照顺序一句一句执行。 语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由于若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。 3.3 选择结构​ 我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用if语句来表示。 语法 if(布尔表达式){ //如果布尔表达式为true，则进入if语句块了，执行里面代码 } if(布尔表达式){ //如果布尔表达式为true，则进入if语句块，执行里面代码 }else{ //如果布尔表达式为false，则进入else语句块，执行里面代码 } if(布尔表达式1){ //如何布尔表达式1为true }else if(布尔表达式2){ //如何布尔表达式2为true }else if(布尔表达式3){ //如何布尔表达式3为true }else{ //如果以上的表达式都不满足，则执行这里 } 3.4 switch 多选择语句switch case 语句判断一个变量和与一系列值中某个值相等，每个值称为一个分支，switch语句中的变量类型可以是： byte、short、int、或者是char 从 Java SE 7开始 switch 开始支持字符串 String 类型了 同时case 标签必须为字符串常量或字面量 case 穿透现象 swtich(expression){ case value: //语句 break;//可选 case value: //语句 break;//可选 default://可选 //语句 } 3.5 循环结构 while循环 while(布尔表达式){ //循环内容 } 只要布尔表达式为true，循环就会一直执行下去 大多数情况是会让循环停止下拉，我们需要一个让表达式失效的方式来结束循环 少部分情况需要循环一直执行，比如服务器的请求响应监听等 do..while循环 do..while 循环至少会让循环体里的语句执行一遍 while 先判断后执行 do..while x先执行后判断 for循环 for循环的执行次数在执行前就确定了 for(初始值；布尔表达式;迭代){ ​ //代码语句 } 打印99乘法 for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;= i;j++){ System.out.print(i+\"*\"+j+\"=\"+i*j+\"\\t\"); } System.out.println(); } break、continue ​ break 用于强行退出循环，不执行中循环体中剩余代码。 continue 用于终止某次循环过程，即跳过循环体尚未执行的语句，继续下一次循环 四、Java方法 java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序集合 方法包含于类或对象中 方法在程序中被创建，在其他类中被调用 设计方法的时候要保证方法的原子性，就是一个方法只完成一个功能 4.1 方法的定义：Java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法。 修饰符：修饰符，这个是可选的，告诉编译器如何调用该方法，定义该方法的访问类型 返回值类型： ​ 方法可能会有返回值，return Value Type是方法返回值的数据类型。 ​ 有些方法可能没有返回值。在这种情况下，return Value Type 是关键字void 方法名：是方法的实际名称 参数类型： 参数像一个占位符。当方法 被调用时，传值给参数这个值被称为实参或者变量 参数列表是指方法的参数类型、顺序、参数个数 参数是可选的，方法可以不包含任何参数 方法体：方法体包含具体的语句，定义该方法的功能 格式 对象名.方法名([参数]) 了解：值传递、引用传递 4.2 方法重载​ 重载就是在一个类中，有相同的函数名称，但是形参不同的函数 方法重载的规则： 方法名称必须相同 参数列表必须不同 参数个数、参数类型、参数位置排列不同等 返回值类型可以相同也可以不相同 注意：仅仅返回值类型不同不足以成为方法的重载 public int max() { return 1; } public int max(int a) { return 1; } public void max(int j, int d) { } 实现理论： ​ 方法名称相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，编译器报错. 4.3 可变参数jdk1.5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) ​ 一个方法中只能传递一个可变参数，它必须是方法的font color = blue &gt;最后一个参数。任何普通参数必须在它之前声明。 public static int max(int x,int ... a) { int[] a1 = a;//可变参数返回数组 return -1; } 4.4 递归A方法调用B方法，很容易理解 递归就是：A方法调用A方法，就是自己调用自己 递归结构包含两个部分： 递归头：什么时候不调用自身方法，如果没有头，将陷入死循环 递归体：什么时候调用自身方法 什么是阶乘？ 阶乘就是值从1乘以2乘以3乘以4一直乘到所要求的数 例如所要求的的数就是4，则阶乘式是1 * 2 * 3 * 4，得到的积是24,24就是4的阶乘。 求阶乘 public static void main(String[] args) { //求4的阶乘 System.out.println(f(4)); } public static int f(int n){ if (n == 1){ return 1; } return n * f(n-1); } 使用栈的机制 五、数组5.1 数组的定义 数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 其中，每一个数据称作一个数组元素，每一个数组元素通过一个下标来访问他们。 数组下标从0开始 5.2 数组声明和创建在类型后面加[] 或者在数组后面加[] dataType 数组名[] = new dataType[数组长度] dataType[] 数组名 = new dataType[数组长度] int[] nums = new int[10]; nums[0] = 1; nums[1] = 2; nums[2] = 3; nums[3] = 4; nums[4] = 5; nums[5] = 6; nums[6] = 7; nums[7] = 8; nums[8] = 9; nums[9] = 10; 获取数组长度 System.out.println(\"数组长度是：\"+nums.length); 数组长度是：10 5.3 Java内存分析堆 ​ 存储new 出来的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈 ​ 存放基本变量类型（会包括这个基本类型的具有数值） ​ 引用类型变量（会存放这个引用在堆里面的具体地址） 方法区 ​ 可以被所有线程共享 ​ 包含了所有的class和static变量 5.4 三种初始化 静态初始化 -创建+赋值 int[] a = {1,2,3}; 动态初始化 -包含默认初始化 int[] a = new int[3]; a[0] = 1; 动态初始化包含：数组的默认初始化 ​ 数组是引用类型。它的元素相当于类的实例变量，因此数组已经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化、 5.5 数组的四个基本特点 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的 其元素必须是相同类型，不允许出现混合类型。 数组的元素可以是任意数据类型，包括基本类型和引用类型、 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中，因此数组无论保存原始类型还是其他对象类型，数组对象本身在堆中 ArrayIndexOutOfBoundsException：数组下标越界异常！ 总结： 1. 数组是相同数据类型的有序集合 1. 数组也是对象。数组元素相当于对象的成员变量 1. 数组长度是确定的，不可改变 5.6 求数组最大值public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; int max = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] &gt; max){ max = nums[i]; } } System.out.println(\"数组的最大值是：\"+max); } 5.7 打印数组public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; for (int i : nums){ System.out.print(i+\" \"); } System.out.println(); System.out.println(\"===================\"); for (int i = 0;i&lt;nums.length;i++){ System.out.print(nums[i]+\" \"); } } 5.8 反转数组public static void main(String[] args) { int[] nums = {1, 5, 2, 39, 2, 5, 72, 24}; for (int i = nums.length - 1; i &gt;= 0; i--) { System.out.print(nums[i] + \" \"); } } 5.9 多维数组多维数组可以看成是数组的数组。比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组 int[][] arr = new int[3][2]; 定义了一个3行2列的数组 5.10 Arrays 类 数组的工具类java.utils.Arrays 由于数组对象本身没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用 Arrays 类中的方法都是static修饰的静态动作，在使用的时候可以直接使用类名，进行调用。 具备以下常用功能 给数组赋值：通过fill方法 给数组排序：通过sort方法，按升序 比较数组：通过equals方法比较数组中元素值是否相等 查找数组元素：通过binarySearch 方法对排序号的数组进行二分查找法操作 Arrays.toString实现 public static String toString(int[] a) { if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) { b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); } } 5.11 冒泡排序​ 冒泡排序无疑是最出名的排序算法之一，总共有八大排序！ ​ 冒泡排序、两层循环、外层冒泡轮数、里层依次比较。 public static void main(String[] args) { int[] arr = {1, 23, 6, 6, 2, 2, 23, 34, 5}; //1.比较数组中两个相邻的元素，如果第一个数比第二个数大，就交互位置 //2.每一次比较，都会产生一个最大，或者最小的数字 //3.下一轮可以少一次排序 //4.依次循环，直到结束！ System.out.println(Arrays.toString(arr)); sort(arr); System.out.println(Arrays.toString(arr)); } public static void sort(int[] arr) { //外层循环，判断我们这个要走几次 for (int i = 0; i &lt; arr.length - 1; i++) { //内层循环，比较判断两个数，如果第一个数比第二个数大，则交换位置 for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j+ 1]; arr[j + 1] = temp; } } } } 5.12 稀疏数组当一个数组中大部分元素为0，或者为同一值的数组时候，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： ​ 记录数组一共有几行几列，有多少个不同值 ​ 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模 控制台输出 全部代码： public class P1 { public static void main(String[] args) { //创建一个11 * 11的二维数组，0为 默认 1为白子、2为黑子 int[][] arr = new int[11][11]; arr[1][2] = 1; arr[2][3] = 2; //打印二维数组 System.out.println(\"原二维数组======================\"); print(arr); //获取维数组的有效值 int sum = 0; for (int[] ints : arr) { for (int anInt : ints) { if (anInt != 0) { sum++; } } } System.out.println(\"二维数组的有效值是：\" + sum); //构建稀疏数组 int[][] arr2 = new int[sum + 1][3]; arr2[0][0] = 11; arr2[0][1] = 11; arr2[0][2] = sum; int count = 0; //遍历二维数组，为稀疏数组赋值 for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { if (arr[i][j] != 0) { count++; arr2[count][0] = i; arr2[count][1] = j; arr2[count][2] = arr[i][j]; } } } System.out.println(\"转换为稀疏数组================================\"); print(arr2); //还原 System.out.println(\"================\"); System.out.println(\"还原\"); int[][] arr3 = new int[arr2[0][0]][arr2[0][1]]; for (int i = 1; i &lt; arr2.length; i++) { arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2]; } print(arr3); } /** * 打印二维数组 * * @param arr */ public static void print(int[][] arr) { String str = \"[ \"; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \"\\t\"); } System.out.println(); } } } 六、面向对象编程6.1 面向过程&amp;面向对象面向过程思想： ​ 步骤清晰简单、第一步做什么、第二步做什么 ​ 面向过程适合处理一些较为简单的问题 面向对象思想： ​ 分类的思维模式，解决问题首先会解决问题需要那些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 什么是面向对象? ​ 面向对象编程(OOP) ​ 面向对象编程的本质就是：以类的方式组织代码，以对象的方式组织(封装)数据； 三大特性： 封装 继承 多态 从认识角度考虑是先有对象后有类。对象，是具体的事务。类是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板 6.2 构造方法​ 使用new 关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用 构造器的特点 必须和类的名字相同 必须没有返回值类型的声明，也不能写void 一旦定义了有参构造，无参构造必须显示定义 构造器作用： 使用new 关键字必须要有构造器 用来初始化值 6.3 封装程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用 6.4 继承 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模 extends的意思是扩展，子类是父类的扩展 Java中类只有单继承，没有多继承 在Java中，所有的类都默认继承Object类，都默认直接或者间接继承Object类 super注意点： super调用父类的构造方法，必须在构造方法中的第一行 super 必须只能出现在子类的方法或者构造方法中 super和this 不能同时调用构造方法 super &amp; this 代表的对象不同： this:本身调用者这个对象 super:只能在继承条件才可以使用 （前提） this:没有继承也可以使用 super:只能在继承条件下可以使用 构造方法： this():本类的构造 super():父类的构造 6.5 重写需要有继承关系，子类重写父类的方法 子类的方法必须和父类要一致，方法体不同 前提 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但不能缩小：private(小) =&gt;public(大) 抛出的异常：范围可以被缩小，但不能扩大： ClassNofoundException（小） –》 Exception（大） 静态方法和非静态方法却别很大！静态方法调用跟左边有关 6.6 多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是固定的，可以指向的引用类型就不确定了 public static void main(String[] args) { // 能调用的方法都是自己的和父类的 Student s1 = new Student(); //不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); } 子类重写父类的方法，执行子类的方法 编译看左边，运行看右边。 多态是方法的多态，属性没有多态性 多态的条件 继承关系 父类引用指向子类对象 方法重写 ClassCaseException 类型转换异常 以下情况方法不能重写 static 方法：属于类，他不属于实例 final常量：在常量池里面的 private:父类私有的方法 6.7 static 详解静态方法、静态属性 ​ 非静态方法可以调用静态方法，静态方法只能调用静态方法 ​ 静态随着类的加载而加载 静态代码块，随着类的加载而调用，永远只执行一次 static{ } 匿名代码块，在构造器之前调用。每次创建对象的时候都会执行 { } 6.8 抽象类abstract可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法。如果修饰类，那么该类就是抽象类 抽象类可以没有抽象方法，但是有抽象方法的类必须声明为抽象类 抽象类，不能使用new关键字创建对象，他是用来让子类继承的。 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。 子类继承抽象类，必须实现所有的抽象方法，否则该子类也要声明为抽象类。 抽象类中可以写普通方法 抽象方法必须在抽象类中 6.9 接口普通类：只有具体实现 抽象类：具体实现和规范(抽象方法都有) 接口：只有规范！自己无法写方法-专业的约束！ ​ 接口就是规范，定义的就是一组规则，体现了显示世界中”如果你是、、、就必须能、、“的思想。 作用： 约束 定义一些方法，让不同的人实现 方法都是public abstract 常量都是public static final 接口中没有构造方法(它都不是类) 可以实现多个接口 必须重写接口中的方法 6.10 内部类内部类就是在一个类的内部定义一个类，比如，A类中定义了一个B类，那么B类相对A类来说就成为内部类，而A类相对于B类来说就是外部类了 内部类分类 成员内部类 静态内部类 局部内部类 匿名内部类 成员内部类 public class Outer { private int id; public void out(){ System.out.println(\"这是外部类方法\"); } class Inner{ public void in(){ System.out.println(\"这是内部类的方法\"); } } } //测试 public static void main(String[] args) { Outer outer = new Outer(); outer.out(); Outer.Inner inner = new Outer().new Inner(); inner.in(); } 静态内部类 public class Outer { private int id; public void out() { System.out.println(\"这是外部类方法\"); } static class Inner { public void in() { System.out.println(\"这是内部类方法\"); } } } //测试 public static void main(String[] args) { Outer outer = new Outer(); outer.out(); Outer.Inner inner = new Outer.Inner(); inner.in(); } 局部内部类 public class Outer { private int id; public void method() { class Inner { public void in() { System.out.println(\"这是局部内部类\"); } } Inner inner = new Inner(); inner.in(); } } //测试 public static void main(String[] args) { Outer outer = new Outer(); outer.method(); } 七、多线程7.1 任务生活中的例子： ​ 边吃饭、边玩手机 ​ 上厕所、玩手机 看起来多个任务都在做，其实本质上我们的大脑在同一时间依旧只做了一件事情 7.2 进程在操作系统中运行的程序就是进程，比如QQ、播放器、游戏、IDE等等 一个进程可以有多个线程 说进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 而进程是执行程序的一次执行过程，它是动态的概念，是系统资源分配的单位 通常在一个进程中可以包含若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位 注意：很多 多线程 是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一时间点，cpu只能执行一个代码，因为切换的很快，所以有同时执行的错觉。 总结： 线程是独立的执行路径； 在程序运行时候，即使没有创建线程，后台也会有多个线程，如主线程、gc线程 main()称之为主线程，为系统的入口，用于执行整个程序； 在一个进程中，如果开辟了多个线程，线程的运行由调度器(CPU)安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时候，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程都在自己的工作内存交互，内存控制不当会造成数据不一致 7.3 多线程 原来是一条路，慢慢因为车变多了，道路堵塞，效率极低 为了提高使用的频率，能够充分利用道路，于是加了多个车道 线程实现三种方式 继承Thread类 实现Runnable接口 实现Callable接口 继承Thread类实现多线程步骤如下： 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象。调用start()方法启动线程 7.3.1 创建线程方式1：继承Thread(通过查看源码发现Thread是实现Runnable接口的)注意：线程开启不一定立即执行，由CPU调度安排 public class TestThread1 extends Thread { @Override public void run() { //run方法 线程体 for (int i = 0; i &lt; 10; i++) { System.out.println(\"我在撸代码--\"+i); } } public static void main(String[] args) { //创建线程对象 TestThread1 testThread1 = new TestThread1(); //调用start()方法 ，开启线程 testThread1.start(); //main线程，主线程 for (int i = 0; i &lt; 10; i++) { System.out.println(\"我在学习--\"+i); } } } //执行结果 我在学习--0 我在学习--1 我在学习--2 我在学习--3 我在学习--4 我在学习--5 我在学习--6 我在学习--7 我在撸代码--0 我在撸代码--1 我在学习--8 我在撸代码--2 我在撸代码--3 我在撸代码--4 我在学习--9 我在撸代码--5 我在撸代码--6 我在撸代码--7 我在撸代码--8 我在撸代码--9 案例：网图下载 package cn.bloghut.thread; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; /** * @classname TestThread2 * @description 实现多线程同步下图片 */ public class TestThread2 extends Thread{ private String url;//网络图片地址 private String name;//保存的文件名 public TestThread2(String url,String name){ this.name = name; this.url = url; } /** * 下载图片线程的执行体 */ @Override public void run(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downLoader(url,name); System.out.println(\"下载了文件名为：\"+name); } public static void main(String[] args) { TestThread2 thread1 = new TestThread2(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"1.jpg\"); TestThread2 thread2 = new TestThread2(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"2.jpg\"); TestThread2 thread3 = new TestThread2(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"3.jpg\"); //先下载t1 thread1.start(); //先下载t2 thread2.start(); //先下载t3 thread3.start(); } } class WebDownloader{ public void downLoader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO 异常，Downloader方法出现问题\"); } } } //输出 下载了文件名为：2.jpg 下载了文件名为：1.jpg 下载了文件名为：3.jpg 7.3.2 创建线程方式2：实现Runnable接口 /** * @classname TestThread1 * @description 实现多线程第二种方式 */ public class TestThread3 implements Runnable{ @Override public void run() { //run方法 线程体 for (int i = 0; i &lt; 10; i++) { System.out.println(\"我在撸代码--\"+i); } } public static void main(String[] args) { //创建线程对象 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象来开启我们的线程 Thread thread = new Thread(testThread3); thread.start(); //main线程，主线程 for (int i = 0; i &lt; 10; i++) { System.out.println(\"我在学习--\"+i); } } } //输出 我在学习--0 我在学习--1 我在学习--2 我在学习--3 我在学习--4 我在撸代码--0 我在学习--5 我在撸代码--1 我在学习--6 我在撸代码--2 我在撸代码--3 我在学习--7 我在学习--8 我在学习--9 我在撸代码--4 我在撸代码--5 我在撸代码--6 我在撸代码--7 我在撸代码--8 我在撸代码--9 7.4 Thread和Runnable小结 继承Thread类 子类继承Thread类具有多线程能力 启动线程：子类对象.start() 不建议使用：避免opp单继承局限性 实现Runnable接口 实现接口Runnbale具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性、灵活方便，方便同一个对象被多个线程使用 7.5 案例：龟兔赛跑 首先来个赛道距离，然后要离终点越来越近 判断比赛是否结束 打印出胜利者 龟兔赛跑开始 故事中是乌龟赢，兔子需要睡觉，我们需要模拟兔子睡觉 最后，乌龟赢了 /** * @classname Race * @description 模拟龟兔赛跑 */ public class Race implements Runnable { //胜利者 private static String winner; @Override public void run() { for (int i = 1; i &lt;= 100; i++) { //模拟兔子休息 if (Thread.currentThread().getName().equals(\"兔子\") || i % 10 == 0) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } //判断比赛是否结束 boolean flag = gameOver(i); //如果比赛结束了，就停止程序 if (flag) { break; } System.out.println(Thread.currentThread().getName() + \"--&gt;跑了\" + i + \"步\"); } } //判断是否完成比赛 private boolean gameOver(int steps) { if (winner != null) {//已经由胜利者了 return true; } else { if (steps &gt;= 100) { winner = Thread.currentThread().getName(); System.out.println(\"Winner is \" + winner); return true; } } return false; } public static void main(String[] args) { Race race = new Race(); new Thread(race, \"乌龟\").start(); new Thread(race, \"兔子\").start(); } } //结果 Winner is 乌龟 7.5.1 创建线程方式3：实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务 提交执行 获取结果 关闭服务 import cn.bloghut.thread.TestThread2; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; /** * @classname TestCallable * @description 线程创建方式三：实现Callable即可 */ public class TestCallable implements Callable&lt;Boolean&gt; { private String url;//网络图片地址 private String name;//保存的文件名 public TestCallable(String url, String name) { this.name = name; this.url = url; } //下载图片线程的执行体 @Override public Boolean call() throws Exception { WebDownloader webDownloader = new WebDownloader(); webDownloader.downLoader(url,name); System.out.println(\"下载了文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"1.jpg\"); TestCallable t2 = new TestCallable(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"2.jpg\"); TestCallable t3 = new TestCallable(\"https://img-blog.csdnimg.cn/img_convert/d8885c9a178b2fcaea732190717b516d.png\", \"3.jpg\"); //1.创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //2.提交执行 Future&lt;Boolean&gt; r1 = ser.submit(t1); Future&lt;Boolean&gt; r2 = ser.submit(t2); Future&lt;Boolean&gt; r3 = ser.submit(t3); //获取结果 Boolean rs1 = r1.get(); Boolean rs2 = r2.get(); Boolean rs3 = r3.get(); //关闭服务 ser.shutdownNow(); } } class WebDownloader { public void downLoader(String url, String name) { try { FileUtils.copyURLToFile(new URL(url), new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO 异常，Downloader方法出现问题\"); } } } 7.6 静态代理例子： ​ 你：真实角色 ​ 婚庆公司：代理你，帮你处理结婚的事情 ​ 结婚：实现结婚接口 静态代理总结： 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 好处： ​ 代理对象可以做很多对象做不了的事情 ​ 真实对象专注做自己的事情 /** * @classname StactProxy * @description 静态代理简单说明 */ public class StacticProxy { public static void main(String[] args) { You you = new You();//你要结婚 new Thread( () -&gt; System.out.println(\"嘤嘤嘤\")).start(); new WeddingCompany(new You()).hashCode(); } } interface Marry { void HappyMarry(); } //真实角色，你去结婚 class You implements Marry { @Override public void HappyMarry() { System.out.println(\"XX要结婚了，超开心\"); } } //真实角色，帮助你结婚 class WeddingCompany implements Marry { //代理谁--》真实目标角色 private Marry target; public WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry();//这就是真实对象 after(); } private void after() { System.out.println(\"结婚之后，收尾款\"); } private void before() { System.out.println(\"结婚之前，布置现场\"); } } 7.7 Lambda表达式入 希腊字母表中排序第十一位的字母，英语名称为Lambda 避免内部类定义过多 其实质属于函数式编程概念 （params） -&gt; expression [表达式] （params） -&gt; statement [语句] （params） -&gt; {statement } new Thread(()-&gt; System.out.println(\"多线程学习\")).start(); 为什么要使用lambda 表达式 1.避免你们内部类定义过多 2.可以让你的代码看起来很简洁 3.去掉了一堆没有意义的代码，只留下核心的逻辑 函数式接口的定义 1.任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。 2.对于函数式接口，我们可以通过lambda 表达式来创建该接口的对象。 public interface Runnable{ public abstract void run(); } 案例1 /** * @classname Testlambda * @description 推导lambda表达式 */ public class Testlambda { //3.静态内部类 static class Like2 implements ILike { @Override public void lambda() { System.out.println(\" i like lambda2\"); } } public static void main(String[] args) { ILike like = new Like(); like.lambda(); like = new Like2(); like.lambda(); //4.局部内部类 class Like3 implements ILike { @Override public void lambda() { System.out.println(\" i like lambda3\"); } } like = new Like3(); like.lambda(); //5.匿名内部类 like = new ILike() { @Override public void lambda() { System.out.println(\" i like lambda4\"); } }; like.lambda(); //6.用lambda表达式 like = ()-&gt;{ System.out.println(\" i like lambda5\"); }; like.lambda(); } } //1.定义一个函数式接口 interface ILike { void lambda(); } //2.实现类 class Like implements ILike { @Override public void lambda() { System.out.println(\" i like lambda\"); } } 7.8 线程状态 线程方法 线程停止 1. 建议线程正常停止=&gt;利用次数。不建议死循环 1. 建议使用标志位=&gt;设置一个标志位 1. 不用使用stop或destory等过时或者JDK不建议使用的方法 /** * @classname TestStop * @description 测试stop */ public class TestStop implements Runnable { //1.设置一个标志位 private boolean flag = true; @Override public void run() { int i = 0; while (flag) { System.out.println(\"run...Thread-&gt;\" + i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop() { this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); //开启线程 new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) { System.out.println(\"main\" + i); if (i == 900) { //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"该线程停止了\"); } } } } 7.9 线程休眠(sleep) sleep(时间) 指定当前线程阻塞的毫秒数； sleep 存在异常InterruptedException; sleep 时间达到后线程进入就绪状态 sleep 可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁； 案例：模拟网络延时 /** * @classname TestSleep * @description 模拟网络延时：放大问题的发生性 */ public class TestSleep implements Runnable { //票数 private int ticketNums = 10; @Override public void run() { while (true) { if (ticketNums &lt;= 0) { break; } //模拟延时 try { Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"---&gt;拿到了第\" + ticketNums-- + \"票\"); } } public static void main(String[] args) { TestSleep testSleep = new TestSleep(); new Thread(testSleep,\"小明\").start(); new Thread(testSleep,\"小红\").start(); new Thread(testSleep,\"小黄牛\").start(); } } 案例：模拟倒计时、打印当前系统时间 import java.text.SimpleDateFormat; import java.util.Date; /** * @classname TestSleep2 * @description 模拟倒计时 */ public class TestSleep2 { /** * 模拟倒计时 * * @throws InterruptedException */ public static void testDown() throws InterruptedException { int num = 10; while (true) { Thread.sleep(1000); System.out.println(num--); if (num == 0) { break; } } } /** * 打印当前时间 */ public static void printNowDate() { //打印当前系统时间 Date stattTime = new Date(System.currentTimeMillis()); while (true) { try { //休眠1秒 Thread.sleep(1000); //格式化时间,并输出时间 System.out.println(new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\").format(stattTime)); //更新获取时间 stattTime = new Date(System.currentTimeMillis()); } catch (Exception e) { e.printStackTrace(); } } } public static void main(String[] args) { printNowDate(); } } 7.10 线程礼让(yield) 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看CPU状态 /** * @classname TestYied * @description 测试礼让线程 * 礼让不一样成功，看CPU心情 */ public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"A\").start(); new Thread(myYield,\"B\").start(); } } class MyYield implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); } } 7.11 线程强制执行：（join）Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 可以想象成插队 练习： /** * @classname TestJoin * @description 测试join 方法 * 想象为插队 */ public class TestJoin implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(\"线程VIP 来了\" + i); } } public static void main(String[] args) throws InterruptedException { TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 200; i++) { if (i == 100) { thread.join();//插队 } System.out.println(\"main\" + i); } } } Thread.State 线程状态，线程可以处于以下状态之一： NEW 尚未启动的线程处于此状态RUNNABLE 在Java虚拟机中执行的线程处于此状态BLOCKED 被阻塞等待监视器锁定的线程处于此状态WAITING 正在等待另一个线程执行特定动作的线程处于此状态TIMED WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态，这些状态不反映任何操作系统线程状态的虚拟机状态。 /** * @classname TeestState * @description 观测线程状态 */ public class TeestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for (int i = 0; i &lt; 5; i++) { try { Thread.sleep(1000); }catch (Exception e){ e.printStackTrace(); } System.out.println(\"/\"); } }); //观察状态 Thread.State state = thread.getState(); System.out.println(state); //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); //只要线程不终止，就一直输出状态 while (state != Thread.State.TERMINATED){ Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state);//输出线程状态 } } } 注意：线程中断或结束，一旦进入死亡状态，就不能再次启动。 7.12 线程优先级 Java提供一个线程调度器来监控程序中启动后加入就绪状态的所有线程，线程调度器安装优先级决定应该调度哪个线程来执行 线程的优先级用数字表示，范围从1——10 ​ Thread.MIN_PRIORITY = 1; ​ Thread.MAX_PRIORITY = 10; Thread.NOPM_PRIORITY = 5; 使用以下方式改变或获取优先级 getPriority() setPriority(int xx) /** * @classname TestPriority * @description 测试线程的优先级 */ public class TestPriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"==\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY);//10 t4.start(); // t5.setPriority(-1);//通过查看源码发现，设置优先级为-1会报错（小于1） // t5.start(); // t6.setPriority(11);//通过查看源码发现，设置优先级为11会报错（大于10） //t6.start(); t5.setPriority(8); t5.start(); t6.setPriority(7); t6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"==\"+Thread.currentThread().getPriority()); } } 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用，这都是看CPU的调度。 7.13 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志、监控内存、垃圾回收等等… /** * @classname TestDaemon * @description 测试守护线程 */ public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(god); thread.setDaemon(true);//默认是false表示是用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程启动 new Thread(you).start();//你 用户线程启动 } } //你 class You implements Runnable { @Override public void run() { for (int i = 0; i &lt; 36500; i++) { System.out.println(\"你一生都开心活着\"); } System.out.println(\"=========goodbye! world=======\"); } } //上帝 class God implements Runnable { @Override public void run() { while (true) { System.out.println(\"上帝保护着你\"); } } } 线程同步 多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 ​ 现实生活中，我们会遇到“同一资源，多个人都想使用”的问题，比如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队。一个个来 处理多线程问题时，多个线程访问同一个对象（并发），并且某些线程还想修改这个对象，这个时候我们就需要线程同步，线程同步就是一种机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 7.14 队列和锁 由于同一个进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入 锁机制 synchronized ，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题： 1.一个线程有锁会导致其他需要此锁的线程挂起； 2.在多线程竞争下，加锁，释放锁会导致比较多的上下文切换 和 调度延时，引起性能问题； 3.如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题。 7.14.1线程不安全案例1：不安全的买票/** * @classname UnsafeBuyTicket * @description 不安全的卖票 */ public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"闲言\").start(); new Thread(station,\"鸡哥\").start(); new Thread(station,\"黄牛\").start(); } } class BuyTicket implements Runnable { //票 private int ticketNums = 10; private boolean flag = true;//外部停止方式 @Override public void run() { //买票 while (flag) { buy(); } } private void buy() { //判断是否有票 if (ticketNums &lt;= 0) { flag = false; return; } //模拟延时 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //买票 System.out.println(Thread.currentThread().getName() + \"拿到\" + ticketNums-- + \"张票\"); } } 7.14.2 线程不安全案例2：不安全的取钱/** * @classname UnsafeBank * @description 不安全的取钱 */ public class UnsafeBank { public static void main(String[] args) { //账户 Account account = new Account(100, \"结婚基金\"); Drawing you = new Drawing(account,50,\"你\"); Drawing girlFriend = new Drawing(account,100,\"girlFriend\"); you.start(); girlFriend.start(); } } //账户 class Account { int money;//余额 String name;//卡名 public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread { Account account;//账户 //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account, int drawingMoney, String name) { super(name); this.account = account; this.drawingMoney = drawingMoney; } @Override public void run() { //判断有没有钱 if (account.money - drawingMoney &lt; 0) { System.out.println(Thread.currentThread().getName() + \"钱不够，取不了\"); return; } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 减去 你取的前 account.money = account.money - drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name + \"余额为：\" + account.money); //Thread.currentThread().getName() = this.getName(); System.out.println(this.getName() + \"手里的钱\" + nowMoney); } } 7.14.3 线程不安全案例3：不安全的集合import java.util.ArrayList; import java.util.List; /** * @classname UnsafeList * @description 线程不安全的集合 */ public class UnsafeList { public static void main(String[] args) throws InterruptedException { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } Thread.sleep(3000); System.out.println(list.size()); } } 7.14.4 同步方法​ 由于我们可以通过private 关键字来保证数据对象只能被方法访问，所以我们只需要对方法提出一套机制，这套机制就是synchronized 关键字，它包括两种用法：synchronized 方法和synchronized 块； 同步方法：public synchronized void method(int args){} ​ synchronized 方法 控制对 “ 对象”的访问，每个对象对应一把锁，每个synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法声明为synchronized 将会影响效率。 方法里面需要修改的内容才需要锁，锁的太多，浪费资源。 同步块：synchronized (obj){ } obj 称之为 同步监视器 obj 可以是任何对象，但是推荐使用共享资源作为同步监视器同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是和这个对象本身，或者是class 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行其中代码 2.第二个线程访问，发现同步监视器，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 锁的对象就是变化的量，需要增删改的数据 7.15 死锁​ 多个线程互相抱着对象需要的资源，然后形成僵持。 多个线程各自占有一些资源，并且互相等待其他线程占有的资源才能运行，而导致这两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁时”，就可能发生“死锁”的问题。 产生死锁的四个必要条件： 1.互斥条件：一个资源每次只能被一个进程使用。 2.请求与保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不放。 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 4.循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源关系。 死锁案例 /** * @classname TestLock * @description 死锁案例 */ public class TestLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑凉\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } class Lipstick { } //镜子 class Mirror { } class Makeup extends Thread { //需要的资源只有一份，用static 来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice;//选择 String girlName;//使用化妆品的人 public Makeup(int choice, String girlName) { this.choice = choice; this.girlName = girlName; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException { if (choice == 0) { synchronized (lipstick) {//获得口红的锁 System.out.println(this.girlName + \"获得口红的锁\"); Thread.sleep(100); synchronized (mirror) {//一秒钟后想获得镜子 System.out.println(this.girlName + \"获得镜子的锁\"); } } } else { synchronized (mirror) {//想获得镜子的锁 System.out.println(this.girlName + \"获得镜子的锁\"); Thread.sleep(100); synchronized (lipstick) {//一秒钟后想获得口红 System.out.println(this.girlName + \"获得口红的锁\"); } } } } } 7.16 Lock(锁)可重入锁 ​ 1. 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 ​ 2.java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 3.ReentrantLock 类实现了Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 Synchronized 与 Lock 的对比 1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁，出了作用域自动释放 2.Lock只有代码块锁,synchronized有代码块锁和方法锁 3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 4.优先使用顺序: Lock &gt; 同步代码块 （已经进入了方法体，分配相应资源） &gt; 同步方法（在方法体之外） lock锁案例 import java.util.concurrent.locks.ReentrantLock; /** * @classname TestLock * @description 测试lock锁 */ public class TestLock { public static void main(String[] args) { TestLock2 lock2 = new TestLock2(); new Thread(lock2,\"闲言\").start(); new Thread(lock2,\"鸡哥\").start(); new Thread(lock2,\"黄牛\").start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try { lock.lock();//加锁 if (ticketNums &gt;0){ try { Thread.sleep(100); }catch (Exception e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\" \"+ticketNums--); }else { break; } }catch (Exception e){ e.printStackTrace(); }finally { lock.unlock();//解锁 } } } } 7.17 线程通信问题生产者和消费者问题 1.假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库﹐消费者将仓库中产品取走消费。 2.如果仓库中没有产品﹐则生产者将产品放入仓库﹐否则停止生产并等待，直到仓库中的产品被消费者取走为止。 3.如果仓库中放有产品,则消费者可以将产品取走消费﹐否则停止消费并等待，直到仓库再次放入产品为止。 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 1.对于生产者﹐没有生产产品之前，要通知消费者等待﹒而生产了产品之后﹐又需要马上通知消费者消费 2.对于消费者﹐在消费之后﹐要通知生产者已经结束消费﹐需要生产新的产品以供消费. 3.在生产者消费者问题中,仅有synchronized是不够的 synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递(通信) Java提供了几个方法解决线程之间的通信问题 注意：均是Object类 的方法，都只能在同步方法或者同步代码块中使用，否则会抛出lllegalMonitorStateException 解决方式1：并发协作模型“生产者/消费者模式”—&gt;管程法 1.生产者:负责生产数据的模块(可能是方法﹐对象﹐线程,进程); 2. 消费者∶负责处理数据的模块(可能是方法,对象﹐线程﹐进程); 3.缓冲区:消费者不能直接使用生产者的数据﹐他们之间有个“缓冲区 生产者将生产好的数据放入缓冲区,消费者从缓冲区拿出数据 /** * @classname TestPC * @description 测试生产者消费者模型---》利用缓冲去解决：管程法 */ public class TestPC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); } } //生产者 class Productor extends Thread { SynContainer container; public Productor(SynContainer container) { this.container = container; } //生产 @Override public void run() { for (int i = 1; i &lt;= 20; i++) { container.push(new Chiken(i)); System.out.println(\"生产了\"+i+\"只鸡\"); } } } //消费者 class Consumer extends Thread { SynContainer container; public Consumer(SynContainer container) { this.container = container; } //生产 @Override public void run() { for (int i = 1; i &lt;= 20; i++) { Chiken pop = container.pop(); System.out.println(\"消费了第\"+pop.id+\"只鸡\"); } } } //产品 class Chiken { int id;//编号 public Chiken(int id) { this.id = id; } } //缓冲区 class SynContainer { //需要一个容器大小 Chiken[] chikens = new Chiken[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Chiken chiken) { //如果容器满了，就需要等待消费者消费 if (count == chikens.length) { //通知消费者消费，生产者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果容器没有满，我们就需要丢入产品 chikens[count] = chiken; count++; //通知消费者消费 this.notifyAll(); } //通知消费者消费 public synchronized Chiken pop() { //判断能否消费 if (count == 0) { //等待生产者生产，消费者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果可以消费 count--; Chiken chiken = chikens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chiken; } } 7.18 线程池背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路︰提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处: 1.提高响应速度（减少了创建新线程的时间) 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建) 3.便于线程管理(…) corePoolSize:核心池的大小 maximumPoolSize:最大线程数 keepAliveTime:线程没有任务时最多保持多长时间后会终止 JDK 5.0起提供了线程池相关API: ExecutorService和ExecutorsExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable cgmmand):执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task):执行任务，有返回值，一般又来执行Callable void shutdown():关闭连接池 Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @classname TestPool * @description 测试线程池 */ public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2022-02-15T09:35:11.000Z","updated":"2022-02-27T16:54:30.616Z","comments":true,"path":"posts/managermodel/","link":"","permalink":"https://dahammer666.github.io/posts/managermodel/","excerpt":"","text":"一、设计模式七大原则1.1 单一职责原则 降低类复杂度，一个类只负责一项职责。 提高类的可读性、可维护性 只要逻辑足够简单，类中的方法数量足够少，可以违反单一职责原则。 1.2 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上 1.3 依赖倒转原则 核心是面向接口编程 高层模块不应该依赖低层模块，二者都应该依赖其抽象 注意事项： 低模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好。 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里式替换原则 1.4 里式替换原则 所有引用基类的地方能够透明地使用其子类的对象 在使用继承时，遵循里式替换原则，在子类中尽量不要重写父类的方法 继承实际让两个类耦合性增强了，可通过聚合、组合、依赖解决问题 -&gt; 通用做法是：原来的父类和子类都继承了一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等 1.5 开闭原则 最基础、重要的设计原则 开：对功能的扩展开放（对提供方）；关：修改关闭（使用方） ocp: 尽量通过扩展软件实体的行为，不是通过修改已有代码 -&gt; 将父类做成抽象类，并提供一个抽象方法，让子类去继承实现。如此我们有新的种类时，只需要让新的种类继承父类，实现抽象方法即可，使用方的代码就不需要关闭。满足开闭原则 1.6 迪米特法则 最少知道原则，即一个类对自己依赖的类知道的越少越好，即降低耦合度；对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。 直接‘朋友’：每个对象都会有与其他对象有耦合关系，耦合方式很多：依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数和方法的返回值中的类为直接朋友；而出现在局部变量中的类不是直接朋友，也就是说，陌生的对象/类 不要以局部变量的形式出现在类的内部。 注意事项：迪米特法则核心是降低类之间的耦合。 1.7 合成复用原则 原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则核心思想 找出应用中需要修改的地方，把它们独立出来，跟不需要修改的代码隔离。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计 二、UML图 uml基本详情 是一种用于软件系统分析和设计的语言工具 uml图 用例图 静态结构图：类图、对象图、包图、组件图、部署图 动态行为图：交互图（时序图与协作图）、状态图、活动图 说明： 类图是描述类与类（对象）的静态关系，是uml图中最核心的 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。 类与类之间的关系 2.1 依赖 -&gt; 主要在类中用到了对方，他们之间就存在依赖 依赖的构成： 类的成员属性 方法的返回类型 接收的参数类型 方法中使用到 2.2 泛化：实际上就是继承关系，是依赖关系的特立。 -&gt;如果A类继承了B类，我们就能说是A和B存在泛化关系 2.3 实现：实现关系实际上就是A类实现B接口，他是依赖关系的特例； 2.4 关联关系 关联关系实际上就是类与类之间的关系，他是依赖关系的特例。 关联具有导航性，即双向关系或者单向关系（单向一对一关系、双向一对一关系） 关系具有多重性（一对一，多对多） 2.5 聚合关系 表示整体和部分的关系，整体与部门可以分开。聚合关系是关联关系的特例；所以它具有关联的导航性（B聚合A）与多重性（多个属性聚合了A）。 2.6 组合关系 组合关系也是整体与部分的关系，但是整体与部分不能分开。 聚合和组合区别： 聚合中整体与部分能看；组合中整体与部分不能分开 public class Person{ private IDCard card;//聚合 private Head head = new Head();//组合 } public class IDCard{} public class Head{} -&gt; 如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了 三、设计模式分类 ./设计模式分为三种类型，共23种 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式、 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）。 ./设计模式介绍： 模式不是代码，是某类问题的通用解决方案。 本质上是提高软件的维护性、通用性和扩展性，并降低软件的复杂度。 3.1 单例模式-&gt; 采用方法，对某个类只能存在一个对象实例，并该类只提供一个取得其对象实例的方法（静态方法）。 3.1.1单例模式八种写法 *饿汉式（静态常量）** *饿汉式（静态代码块）** 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程不安全，同步代码块） *双重检查** *静态内部类** *枚举** 3.2 饿汉式（静态常量）-&gt;应用实例： 构造器私有化 （防止其他对象/类 创建对象(new)） 类的内部创建对象 向外暴露一个静态的公共方法 getInstance 代码实现 优缺点说明： 优点：这种写法简单，在类装载的时候就完成实例化。避免了线程同步问题。 缺点：在类装载时就完成实例化，没有达到Lazy Loading（懒加载）的效果。例如：如果从未用过这个实例的话，就会造成内存的浪费。 这种方式基于classloder机制避免了多线程的同步问题，不过,instance在类装载时候就实例化了，在单例模式中大多数都是在调用getInstance方法，但是导致类装载的原因有很多种，不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化Instance就没有达到lazy loading的效果 饿汉式（静态常量）这种单例模式可用，但是可能造成内存浪费。 package com.atiguigu1.singleton; public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); System.out.println(\"instance.hasCode=\" + instance.hashCode()); System.out.println(\"instance2.hasCode=\" + instance2.hashCode()); } } class Singleton{ //1、构造器私有化，外部能New private Singleton(){ } //2、本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供一个公有的静态方法，返回实例对象 public static getInstance(){ return instance; } } 3.3饿汉式（静态代码块）优缺点说明： 这种方式和上面饿汉式（静态常量）的方式类似，只不过将实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化的实例。优缺点和上面的一样的。 饿汉式（静态代码块）这种 单例模式可用，但是也是可能造成内存浪费。 class Singleton{ private Singleton() { } private final static Singleton instance; //在静态代码块中，创建单例对象 static { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 3.4 懒汉式（线程不安全）优缺点说明： 起到了Lazy Loading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入方法中的if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式。 结论：在实际开发中，不使用懒汉式。 //懒汉式（线程不安全） class Singleton { private static Singleton instance; private Singleton() { } //提供一个静态的共有方法，当使用该方法的时候，才去创建instance public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3.5 懒汉式（线程安全，同步方法）优缺点说明： -&gt;在静态getInstance()方法前面加 synchronized 解决了线程不安全问题 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法我们需求是只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低了。 //懒汉式（线程安全，同步方法） class Singleton { private static Singleton instance; private Singleton() { } //提供了一个静态的共有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3.6 懒汉式（线程不安全，同步代码块）-&gt; 这种港式，本事想对第四种{ 懒汉式（线程安全，同步方法）}实现方式的改进，因为同步方法效率态度，改为同步方法里面的产生实例化的代码块。 但是这种同步并不能起到线程同步的作用。跟第三种实现方式遇到的情形一致，假如一个线程进入了if(singleton == null)判断语句块中，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便回产生多个实例。不能保证线程安全。 class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } 3.7 双重检查 //双重检查 class Singleton { private static volatile Singleton instance; private Singleton() { } //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题 //同时保证了效率，推荐使用 public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { instance = new Singleton(); } } return instance; } } 优缺点说明： Double-Check概念是多线程开发中常用到的，代码中，我们进行了两次if(singleton == null)检查，可以保证线程安全。 实例化代码只用了一次，后面再次访问时，判断if(singleton == null),直接return实例化对象；延迟加载；效率较高 实际开发中，推荐使用双重检查做单例设计模式（推荐使用） 3.8 静态内部类//静态内部类 class Singleton{ private static volatile Singleton instance; //构造器私有化 private Singleton() { } //写一个静态内部类，该类中有一个静态属性Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点说明： 采用了类装载的机制来保证初始化实例时只有一个线程 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程无法进入。 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高（推荐使用） 3.9 枚举public class SingletonTest { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } enum Singleton { INSTANCE; public void sayOK(){ System.out.println(\"yyds\"); } } 优缺点说明： 借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。（推荐使用） 单例模式注意事项和细节说明 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须记住使用相应的获取对象的方法，而不是使用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等） 四、工厂模式 工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护。 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式) 设计模式的依赖抽象原则（不要依赖具体类） 注意： 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。（变量不要直接持有具体类的引用） 不要让类继承具体类，而是继承抽象类或者是实现interface（接口） 不要覆盖基类中已经实现的方法 Pizza项目需求： 披萨种类（GreekPizza、CheesePizza） 披萨的制作过程：prepare、bake、cut、box 完成披萨订单功能 4.1 传统方式 //Pizza实体 public abstract class Pizza { protected String name; //不同的Pizza不同的制作方法，做成一个抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \"bake\"); } public void cut() { System.out.println(name + \"cutting\"); } public void box() { System.out.println(name + \"boxing\"); } public void setName(String name) { this.name = name; } } //CheesePizza public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(\" 给制作奶酪披萨 准备原材料 \"); } } //OrderPizza pizza制作过程 public class OrderPizza { // 构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" greek披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" cheese披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } else { break; } //输出pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } //getType方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //pizza订单 public class PizzaStore { public static void main(String[] args) { new OrderPizza(); } } 传统方式的优缺点 优点是好理解，简单易操作 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者可能少修改代码。 例如，如果我们在上面功能还要再加新的Pizza种类，我们要修改如下 新增（扩展开放）： 修改（修改关闭）：-&gt;如果增加一个pizza类，主要是订购pizza的代码都要修改 简单工厂模式进行修改 把创建pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类即可，其它有创建到Pizza对象的代码就不需要修改了 4.2 简单工厂模式 基本介绍 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。 定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 实例代码 /** * 新增加pizza种类 简单工厂创建用来实例化对象的代码 */ public class SimpleFactory { //更改orderType 返回对应的Pizza 对象 简单工厂模式1 public Pizza createPizza(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } //简单工厂模式 也叫 静态工厂模式 简单工厂模式2 public static Pizza createPizza2(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式2\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } } --------- /** * 简单工厂模式1 */ public class OrderPizza2 { //定义一个简单工厂对象 SimpleFactory simpleFactory; Pizza pizza = null; //构造器 public OrderPizza2(SimpleFactory simpleFactory) { setFactory(simpleFactory); } public void setFactory(SimpleFactory simpleFactory) { //用户输入 String orderType = \"\"; //设置简单工厂对象 this.simpleFactory = simpleFactory; do { orderType = getType(); pizza = this.simpleFactory.createPizza(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购披萨失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * 简单工厂模式2 */ public class OrderPizza3 { Pizza pizza = null; String orderType = \"\"; //构造器 public OrderPizza3() { do { orderType = getType(); pizza = SimpleFactory.createPizza2(orderType); //输出pizza if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\" 订购披萨失败 \"); break; } }while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } /** * main方法 */ public class PizzaStore { public static void main(String[] args) { //常规方式 // new OrderPizza(); //简单工厂模式1 // new OrderPizza2(new SimpleFactory()); //简单工厂模式2 new OrderPizza3(); } } 4.3 工厂方法模式 工厂方法模式介绍 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 BJCheessPizza，BJPepperPizza，LDCheessPizza，LDPepperPizza /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } --- public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } ---- public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 工厂模式 */ public abstract class OrderPizza { //定义一个抽象方法，createPizza , 让各个工厂子类自己实现 abstract Pizza createPizza(String orderType); //构造器 public OrderPizza() { Pizza pizza = null; // 订购披萨的类型 String orderType; do { orderType = getType(); //抽象方法，由工厂子类完成 pizza = createPizza(orderType); //输出pizza制作过程 if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } --- public class BJOrderPizza extends OrderPizza{ @Override Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //main public class PizzaStore { public static void main(String[] args) { new BJOrderPizza(); } } 4.4 抽象工厂模式 基本介绍 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（进一步的抽象）。 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成工厂簇。更利于代码的维护和扩展。 /** * 将Pizza 类做成抽象 */ public abstract class Pizza { protected String name; //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } //实现抽象类1 public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪pizza\"); System.out.println(\" 北京的奶酪pizza 准备原材料\"); } } //实现抽象类2 public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒pizza\"); System.out.println(\" 北京的胡椒pizza 准备原材料\"); } } /** * 一个抽象工厂模式的抽象层(接口) */ public interface AbsFactory { //让下面的工厂子类来 具体实现 public Pizza createPizza(String orderType); } //实现抽象工厂 public class BJFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\"); Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } return pizza; } } //封装方法 public class OrderPizza { AbsFactory factory; // 构造器 public OrderPizza(AbsFactory factory) { setFactory(factory); } private void setFactory(AbsFactory factory) { Pizza pizza = null; String orderType = \"\"; this.factory = factory; do { orderType = getType(); // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类 pizza = factory.createPizza(orderType); if (pizza != null) { // 订购ok pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败\"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } //main方法 public class PizzaStore { public static void main(String[] args) { new OrderPizza(new BJFactory()); } } 五、原型模式题型：克隆sheep 现在有一只羊tom，姓名为:tom，年龄为:1，颜色为:白色，请编写程序创建和tom羊属性完全相同的10只羊。 5.1 传统方式public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\"; } } ------ public class Client { public static void main(String[] args) { //传统的方法 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); //.... System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); //... } } 传统格式的优缺点 优点是比较好理解，简单易操作。 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率低。 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不灵活。 改进：java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的Java类必须实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力-》原型模式 5.2 原型模式基本介绍 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建的细节。 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即，对象.clone() -&gt;原型结构图说明 Prototype：原型类，声明一个克隆自己的接口。 ConcretePrototype：具体的原型类，实现一个克隆自己的操作 Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样） public class Sheep implements Cloneable{ private String name; private int age; private String color; private String address = \"蒙古羊\"; public Sheep friend; //是对象, 克隆是会如何处理 public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\"; } @Override protected Object clone(){ Sheep sheep = null; try { sheep = (Sheep) super.clone(); } catch (CloneNotSupportedException e) { // e.printStackTrace(); System.out.println(e.getMessage()); } return sheep; } } ||||| public class Client { public static void main(String[] args) { System.out.println(\"原型模式完成对象的创建\"); Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 2, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); //克隆 Sheep sheep3 = (Sheep)sheep.clone(); //克隆 Sheep sheep4 = (Sheep)sheep.clone(); //克隆 Sheep sheep5 = (Sheep)sheep.clone(); //克隆 System.out.println(\"sheep2 =\" + sheep2); System.out.println(\"sheep2 =\" + sheep3); System.out.println(\"sheep2 =\" + sheep4); System.out.println(\"sheep2 =\" + sheep5); System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode()); System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode()); System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode()); System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode()); } } 5.2.1 浅拷贝和深拷贝浅拷贝： 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值赋值一份给新的对象。 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数值、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 克隆羊是浅拷贝。 浅拷贝是使用默认的clone()方法实现 sheep =(Sheep)super.clone 深拷贝： 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝。 深拷贝实现方式1：重写clone方法来实现深拷贝 深拷贝实现方式2：通过对象序列化实现深拷贝 原型模式的注意事项 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码。 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。 public class DeepCloneableTarget implements Serializable, Cloneable { private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; //构造器 public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } //因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } ||||| public class DeepProtoType implements Serializable, Cloneable { public String name; //String 属性 public DeepCloneableTarget deepCloneableTarget;// 引用类型 public DeepProtoType() { super(); } //深拷贝 - 方式 1 使用clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; //这里完成对基本数据类型(属性)和String的克隆 deep = super.clone(); //对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType) deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone(); return deepProtoType; } //深拷贝 - 方式2 通过对象的序列化实现 (推荐) public Object deepClone() { //创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //序列化. bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //当前这个对象以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType copyObj = (DeepProtoType) ois.readObject(); return copyObj; } catch (Exception e) { e.printStackTrace(); return null; }finally { //关闭流 try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (Exception e2) { System.out.println(e2.getMessage()); } } } } |||||||| public class Client { public static void main(String[] args) throws CloneNotSupportedException { DeepProtoType p = new DeepProtoType(); p.name = \"宋江\"; p.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\"); //方式1 完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.clone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p2.name=\" + p2.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode()); //方式2 完成深拷贝 DeepProtoType p3 = (DeepProtoType) p.deepClone(); System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode()); System.out.println(\"p3.name=\" + p3.name + \"p3.deepCloneableTarget=\" + p3.deepCloneableTarget.hashCode()); } } 六、建造者模式项目盖房需求： 需要建房子：打桩、砌墙、封顶 有普通房、高楼、别墅各种房子，但是要求不要相同 6.1 传统方式 分析 传统方式有点比较好理解，简单易操作 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，这种设计方案，把产品（即：房子）和创建产品的过程（即：建造房子流程）封装在一起，耦合性增强 解决方案：将产品和产品建造过程解耦 =&gt;建造者模式 public abstract class AbstractHouse { //打地基 public abstract void buildBasic(); //砌墙 public abstract void buildWalls(); //封顶 public abstract void roofed(); public void build() { buildBasic(); buildWalls(); roofed(); } } ----------- public class CommonHouse extends AbstractHouse{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙 \"); } @Override public void roofed() { System.out.println(\" 普通房子封顶 \"); } } ------------- public class Client { public static void main(String[] args) { CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); } } 6.2 建造者模式基本介绍 建造者模式，又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不用表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder(抽象建造者) ：创建一个Product对象的各个部件指定的接口/抽象类。 ConcreteBulder(具体建造者) : 继承/实现接口，构建和搭配各个部件。 Director(指挥者) ： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离客户与对象的生产过程。二是：负责控制产品对象的生产过程 建造者模式的注意事项： 客户端(Client)不必知道产品内容组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则” 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类实现这种变化，导致系统变得很庞大，这时候需要考虑是否选择建造者模式 抽象工厂模式和建造者模式区别 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 //产品-&gt;Product public class House { private String basic; private String wall; private String roofed; public String getBasic() { return basic; } public void setBasic(String basic) { this.basic = basic; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } // 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); //将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造房子好， 将产品(房子) 返回 public House buildHouse() { return house; } } //继承抽象 public class CommonHouse extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 普通房子打地基5米 \"); } @Override public void buildWalls() { System.out.println(\" 普通房子砌墙10cm \"); } @Override public void roofed() { System.out.println(\" 普通房子屋顶 \"); } } public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\" 高楼的打地基100米 \"); } @Override public void buildWalls() { System.out.println(\" 高楼的砌墙20cm \"); } @Override public void roofed() { System.out.println(\" 高楼的透明屋顶 \"); } } //指挥者，这里去指定制作流程，返回产品 public class HouseDirector { HouseBuilder houseBuilder = null; //构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //通过setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } //client public class Client { public static void main(String[] args) { //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); System.out.println(\"-------------\"); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品(高楼) houseDirector.constructHouse(); } } 七、适配器模式基本介绍 适配器模式将某个类的接口 转换成客户端期望的另一个借口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(wrapper) 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 工作原理 适配器模式：将一个类的接口转换成另一种接口。让原本接口不兼容的类可以兼容 从用户的角度看不到被适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户受到反馈结果，感觉只是和目标接口交互，如图 适配器模式的注意事项 三种命名方式，是根据【被适配器】src是以怎样的形式给【适配器】Adapter（在Adapter里的形式）来命名的 类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现 Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作 7.1 类适配器模式基本介绍 先有Adapter类（适配器），通过继承被适配者(src类)，实现目标类(dst类)接口，完成src &gt; dst 的适配 应用实例： 充电器本身相当于适配器(Adapter)，插口220V交流电相当于src(即被适配者)，我们的目标(dst)即转换成5v直流电，能够给电器充电 类适配器注意事项 Java是单继承机制，所以类适配器需要继承src类这点算是一个缺点，因为这要求dst必须是接口，有一定的局限性。 src类的方法在Adapter中都会暴露出来，也增加了使用的成本。 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 //被适配的类 public class Voltage220V { //输出220V的电压 public int output220v() { int src =220; System.out.println(\"电压=\" + src + \"伏\"); return src; } } //适配接口 public interface IVoltage5V { public int output5V(); } //适配器类 public class VoltageAdapter extends Voltage220V implements IVoltage5V{ @Override public int output5V() { //获取到220V电压 int srcV = output220v(); int dstV = srcV / 44;//转成 5v return dstV; } } public class Phone { //充电 public void charging(IVoltage5V iVoltage5V) { if (iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V, 可以充电~~\"); } else if (iVoltage5V.output5V() &gt; 5) { System.out.println(\"电压大于5V, 不能充电~~\"); } } } //main public class Client { public static void main(String[] args) { System.out.println(\" === 类适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } 7.2 对象适配器模式 基本介绍 基本思路和类的适配器模式相同，只是将适配器(Adapter类)作修改，不是继承（被适配器）src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现适配接口(dst类接口)，完成src-&gt;dst的适配 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。 对象适配器模式是适配器模式常用的一种 应用实例： 充电器问题，只需要修改适配器即可 //适配器类 public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; // 关联关系-聚合 //通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) { this.voltage220V = voltage220v; } @Override public int output5V() { int dst = 0; if(null != voltage220V) { int src = voltage220V.output220V();//获取220V 电压 System.out.println(\"使用对象适配器，进行适配~~\"); dst = src / 44; System.out.println(\"适配完成，输出的电压为=\" + dst); } return dst; } } public class Client { public static void main(String[] args) { System.out.println(\" === 对象适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); } } 对象适配器模式注意事项 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合同复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须接口。 使用成本更低、更灵活。 7.3 接口适配器模式 适配器模式或缺省适配器模式 当不需要全部实现接口提供的方法时，可先设计一个抽象实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该对象类的子类可有选择地覆盖父类的某些方法来实现需求。 适用于一个接口不想使用其所有的方法的情况、 应用实例 Android中的属性动画ValueAnimator类可以通过addListener（AnimatorListener listener）方法添加监听器，常规写法如下 有时候不想实现Animator.AnimatorListener接口的全部方法，我们只想监听onAnimationStart，我们会如下写： AnimatorListenerAdapter类，就是一个接口适配器，代码如下，它空实现了Animator.AnimatorListener类（src）的所有方法 AnimatorListener是一个接口 程序里的匿名内部类就是Listener具体实现类 案例说明 public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } //在AbsAdapter 我们将 Interface4 的方法进行默认实现 public class AbsAdapter implements Interface4{ //默认实现 @Override public void m1() { } @Override public void m2() { } @Override public void m3() { } @Override public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter(){ //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(\"使用了m1的方法\"); } }; absAdapter.m1(); } } 八、桥接模式应用实例 对不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网、打电话等） 8.1 传统方式 问题分析： 扩展性问题（类爆炸）：如果再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本，所以用桥接模式 8.2 桥接模式 基本介绍 桥接模式(Bridge模式)：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。 是一种结构型模设计模式 Bridge模式基于类的最小设计原则，通过使用封装、聚合以及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。 桥接模式注意事项 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计维度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。 桥接模式的其他应用场景 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 常见的应用场景： -JDBC驱动程序 -银行转账系统 转账分类：网上转账，柜台转账、AMT转账 转账用户类型：普通用户，银卡用户，金卡用户.. -消息管理 消息类型：即时消息，延时消息 消息分类：手机短信，邮件消息，QQ消息 //接口 public interface Brand { void open(); void close(); void call(); } public class XiaoMi implements Brand { @Override public void open() { System.out.println(\" 小米手机开机 \"); } @Override public void close() { System.out.println(\" 小米手机关机 \"); } @Override public void call() { System.out.println(\" 小米手机打电话 \"); } } public abstract class Phone { //组合品牌 private Brand brand; //构造器 public Phone(Brand brand) { this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { brand.close(); } protected void call() { brand.call(); } } //折叠式手机类，继承 抽象类 Phone public class FoldedPhone extends Phone{ //构造器 public FoldedPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 折叠样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 折叠样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 折叠样式手机 \"); } } public class UpRightPhone extends Phone{ //构造器 public UpRightPhone(Brand brand) { super(brand); } @Override public void open() { super.open(); System.out.println(\" 直立样式手机 \"); } @Override public void close() { super.close(); System.out.println(\" 直立样式手机 \"); } @Override public void call() { super.call(); System.out.println(\" 直立样式手机 \"); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"=======================\"); Phone phone2 = new UpRightPhone(new XiaoMi()); phone2.open(); phone2.call(); phone2.close(); } } 九、装饰者模式订单项目 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(没事咖啡)、Decaf（无因咖啡） 调料：Milk、Soy（豆浆）、Chocolate 要求在拓展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。 9.1 传统方式 方案1 Drink是一个抽象类，表示饮料。 des就是对咖啡的描述，比如咖啡的名字 cost()方法就是计算费用，Drink类中做成一个抽象方法 Decaf就是单品咖啡，继承Drink，并实现cost Espress&amp;&amp;Milk就是单品咖啡+调料，这个组合很多 问题：这种设计会导致有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸。 方案2 方案2可以控制类的数量，不至于造成很多的类 在增加或者删除调料种类时，代码的维护量很大 考虑到用户可以添加多份调料时，可以将hasMilk 返回一个对应int 考虑用装饰者模式 9.2 装饰者模式 装饰者模式定义 装饰者模式：动态的将新功能附加到对象上，在对象功能扩展方面，它比继承更加有弹性，装饰者模式也体现了开闭原则(OCP) 这里提到的动态地将新功能附加到对象和ocp原则，在后面的应用实例上面会以代码的形式体现 装饰者模式原理 装饰者模式设计咖啡 public abstract class Drink { public String des;//描述 private float price =0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } //计算费用的抽象方法 //子类来实现 public abstract float cost(); } public class Coffee extends Drink{ @Override public float cost() { return super.getPrice(); } } public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\" shortblack \"); setPrice(4.0f); } } public class DeCaf extends Coffee{ public DeCaf() { setDes(\" 无因咖啡 \"); setPrice(1.0f); } } public class Espresso extends Coffee{ public Espresso() { setDes(\" 意大利咖啡 \"); setPrice(6.0f); } } public class LongBlack extends Coffee{ public LongBlack() { setDes(\" longblack \"); setPrice(5.0f); } } public class Decorator extends Drink{ private Drink obj; public Decorator(Drink obj) { //组合 this.obj = obj; } @Override public float cost() { // getPrice 自己价格 return super.getPrice() + obj.cost() ; } @Override public String getDes() { // obj.getDes() 输出被装饰者的信息 return des + \" \" + getPrice() + \" &amp;&amp; \" + obj.getDes(); } } //具体的Decorator， 这里就是调味品 public class Chocolate extends Decorator{ public Chocolate(Drink obj) { super(obj); setDes(\" 巧克力 \"); setPrice(3.0f); // 调味品 的价格 } } public class Milk extends Decorator{ public Milk(Drink obj) { super(obj); setDes(\" 牛奶 \"); setPrice(2.0f); } } public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); setDes(\" 豆浆 \"); setPrice(1.5f); } } public class CoffeeBar { public static void main(String[] args) { // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用1=\" + order.cost()); System.out.println(\"描述=\" + order.getDes()); // 2. order 加入一份牛奶 order = new Milk(order); System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入一份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入2份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes()); System.out.println(\"===========================\"); Drink order2 = new DeCaf(); System.out.println(\"order2 无因咖啡 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes()); order2 = new Milk(order2); System.out.println(\"order2 无因咖啡 加入一份牛奶 费用 =\" + order2.cost()); System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes()); } } 十、组合模式 学校院系展示需求 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，如图： 10.1 传统方式 传统方式解决学院院系展示存在的问题分析 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现管理的操作，比如学院、系的添加，删除，遍历等。 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承关系，而是一种树形结构，可以更好的实现管理操作。 =&gt;组合模式 10.2 组合模式 基本介绍 组合模式（Composite Pattern），又叫部分整理模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 这种类型的./设计模式属于结构型模式。 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象 组合模式原理类图 对原理机构图的说明（即：组合模式的角色以及职责） Component：这是组合中对象生命接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component 子部件，Component可以是抽象类或者接口 Leaf：在组合中表示叶子节点，叶子节点没有子节点。 Composite：非叶子节点，用于存储子部件，在Component接口实现子部件的相关操作，比如增加（add）,删除。 组合模式解决学校院系展示的应用实例 应用实例要求： 编写程序展示一个学校院系结构：需求是，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。 思路分析图解（类图） 代码实现 public abstract class OrganizationComponent { private String name; //名字 private String des; //说明 protected void add(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } protected void remove(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } //构造器 public OrganizationComponent(String name, String des) { this.name = name; this.des = des; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } //方法print，做成抽象方法,子类都要实现 public abstract void print(); } public class University extends OrganizationComponent{ List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;(); @Override protected void add(OrganizationComponent organizationComponent) { organizationComponents.add(organizationComponent); } @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } //构造器 public University(String name, String des) { super(name, des); } //print方法，就是输出University 包含的学院 @Override public void print() { System.out.println(\"----------\"+ getName() +\"----------\"); for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } public class Colleage extends OrganizationComponent{ //包含Department List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;(); @Override protected void add(OrganizationComponent organizationComponent) { //将来实际业务中，Colleage的 add和University add不一定完全一样 organizationComponents.add(organizationComponent); } @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } //构造器 public Colleage(String name, String des) { super(name, des); } //print方法，就是输出University 包含的学院 @Override public void print() { System.out.println(\"----------\"+ getName() +\"----------\"); for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } public class Department extends OrganizationComponent{ //add,remove不用写了， 也没有集合，因为他是叶子节点 public Department(String name, String des) { super(name, des); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } @Override public void print() { System.out.println(getName()); } } public class Client { public static void main(String[] args) { //从大到小创建对象 学校 OrganizationComponent university = new University(\"清华大学\", \"中国顶级大学\"); //创建学院 OrganizationComponent computerColleage = new Colleage(\"计算机学院\", \"计算机学院\"); OrganizationComponent foreignLanguageColleage = new Colleage(\"外国语学院\", \"外国语学院\"); //创建各个学院下面的系(专业) computerColleage.add(new Department(\"软件工程\",\"软件工程\")); computerColleage.add(new Department(\"信息工程\",\"信息工程\")); computerColleage.add(new Department(\"计算机与科学\",\"计算机与科学\")); foreignLanguageColleage.add(new Department(\"英语\",\"英语\")); foreignLanguageColleage.add(new Department(\"日语\",\"日语\")); //将学院加入到学校 university.add(computerColleage); university.add(foreignLanguageColleage); // university.print(); computerColleage.print(); } } 组合模式的注意事项和细节 简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。 具有较强的扩展性。当我们要更改组合对象时候，我们只需要调整内部的层次关系，客户端不用做出任何改动。 方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式 组合模式在JDK集合的源码分析 Java的集合类-HashMap就使用了组合模式 代码分析+Debug 源码 类图 十一、外观模式影院管理项目 11.1 传统方式 传统方式解决影院管理问题分析 在ClientTest的main方法中，创建各个子系统的对象，并直接去调佣子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程。 不利于在ClientTest中，去维护对子系统的操作。 解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready、play、pause、end),用来访问子系统中的一群接口 也就是说，就是通过定义一个一致的接口(界面类)用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心对这个子系统的内部细节 =&gt;外观模式 11.2 外观模式 外观模式基本介绍 外观模式，也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面”，此模式定义了一个高层接口，这个接口使得这子系统更加容易使用 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节。 外观模式原理类图 类图说明 外观模式（Facade）：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象 调用者(Client)：外观接口的调用者 子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者 外观模式解决影院管理 外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装组件等等），还有就是手机的重启功能（把关机和启动合为一个操作） 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。 示意图说明： 外观模式应用实例 应用实例要求 使用外观模式来完成家庭影院项目 思路分析和图解（类图） 代码实现 public class DVDPlayer { //使用单例模式，使用饿汉式 private static DVDPlayer instance = new DVDPlayer(); public static DVDPlayer getInstance() { return instance; } public void on() { System.out.println(\"dvd on\"); } public void off() { System.out.println(\"dvd off\"); } public void play() { System.out.println(\"dvd is playing\"); } public void pause() { System.out.println(\"dvd is pause\"); } } public class Popcorn { private static Popcorn instance = new Popcorn(); public static Popcorn getInstance() { return instance; } public void on() { System.out.println(\"popcorn on\"); } public void off() { System.out.println(\"popcorn off\"); } public void pop() { System.out.println(\"popcorn is poping\"); } } public class TheatreLight { private static TheatreLight instance = new TheatreLight(); public static TheatreLight getInstance() { return instance; } public void on() { System.out.println(\"Theatre on\"); } public void off() { System.out.println(\"Theatre off\"); } public void bright() { System.out.println(\"Theatre bright.\"); } public void dim() { System.out.println(\"Theatre dim.\"); } } public class HomeTheatreFacade { //定义各个子系统对象 private TheatreLight theatreLight; private Popcorn popcorn; private Stereo stereo; private Projector projector; private Screen screen; private DVDPlayer dvdPlayer; public HomeTheatreFacade() { this.theatreLight = TheatreLight.getInstance(); this.popcorn = Popcorn.getInstance(); this.stereo = Stereo.getInstance(); this.projector = Projector.getInstance(); this.screen = Screen.getInstance(); this.dvdPlayer = DVDPlayer.getInstance(); } //操作分成四部 public void ready() { popcorn.on(); popcorn.pop(); screen.down(); projector.on(); stereo.on(); dvdPlayer.on(); theatreLight.dim(); } public void play() { dvdPlayer.play(); } public void pause() { dvdPlayer.pause(); } public void end() { popcorn.off(); theatreLight.bright(); screen.up(); projector.off(); stereo.off(); dvdPlayer.off(); } } public class Client { public static void main(String[] args) { HomeTheatreFacade homeTheatreFacade = new HomeTheatreFacade(); homeTheatreFacade.ready(); homeTheatreFacade.play(); homeTheatreFacade.pause(); homeTheatreFacade.end(); } } 外观模式在MyBatis框架应用的源码分析 Mybatis中的Configuration去创建MetaObject 对象使用到外观模式 代码分析+Debug源码+示意图 对源码中使用到的外观模式的角色类图 外观模式的注意事项和细节 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性 外观模式对客户端与子系统的耦合关系 -解耦。让子系统内部的模块更容易维护和扩展 通过合理的使用外观模式，可以帮助我们更好的划分访问的层次 当系统需要进行分层设计时候，可以考虑使用Facade模式 在维护一个遗留的大型系统的时候，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Favade类交互，提高复用性。 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。 十二、享元模式 展示网站项目需求 12.1 传统方式 传统方案解决网站展现项目 直接复制粘贴一份，然后根据客户不同要求，进行定制修改 给每个网站租用一个空间 方案设计示意图 传统方案解决网站展现项目-问题分析 需要的网站结构相似度很搞，而且不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。 对于代码来说，由于是一份实例，维护和扩展都更加容易 上面的解决思路就可以使用 享元模式来解决 12.2 享元模式 享元模式基本介绍 享元模式 也叫 蝇量模式：运用共享技术有效地支持大量细粒度的对象 常用于系统底层开发，解决系统的性能问题，像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。 享元模式经典的应用场景就是池技术，String 常量池，数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。 享元模式的原理类图 对类图的说明 FlyWeight 是抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态（后面介绍的）接口或实现 ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。 UnShareConcreteFlyWeight 是不可共享的角色 一般不会出现在享元工厂。 FlyWeightFactory 享元工厂类，用于构建一个池容器(集合)，同时提供从池中获取对象方法 内部状态和外部状态 比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态，而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态 享元模式提出了两个要求，细粒度和共享对象。这里就设计到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态。 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。 举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两三个实例，这样就很好的解决了对象的开小问题。 享元模式解决网站展现项目 应用实例要求 ​ 使用享元模式完成后，前面提出的网站外包问题 思路分析和图解（类图） 代码实现 public abstract class WebSite { public abstract void use(User user);//抽象方法 } //具体网站 public class ConcreteWebSite extends WebSite{ //共享的部分，内部状态 private String type = \"\"; //网站发布的形式(类型) //构造器 public ConcreteWebSite(String type) { this.type = type; } @Override public void use(User user) { System.out.println(\"网站的发布形式为：\"+ type + \"使用者是：\"+ user.getName()); } } //网站工厂类，根据需要返回压一个网站 public class WebSiteFactory { //集合，充当池的作用 private HashMap&lt;String, ConcreteWebSite&gt; pool = new HashMap&lt;&gt;(); //根据网站的类型，返回一个网站，如果没有就创建一个网站，并放入到池中，并返回 public WebSite getWebSiteCategory(String type) { if (!pool.containsKey(type)) { //若有就创建一个网站，并放入到池中 pool.put(type, new ConcreteWebSite(type)); } return (WebSite) pool.get(type); } //获取网站分类的总数（池中有多少个网站类型） public int getWebSiteCount() { return pool.size(); } } public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Client { public static void main(String[] args) { //创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); //客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(new User(\"tom\")); //客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\"博客\"); webSite2.use(new User(\"Jack\")); //客户要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\"博客\"); webSite3.use(new User(\"Polo\")); System.out.println(\"一共有多少个网站分类：\"+ factory.getWebSiteCount()); } } 享元模式在JDK-Integer的应用源码分析 Integer中的享元模式 代码分析 public class FlyWeight { public static void main(String[] args) { Integer x = Integer.valueOf(127); Integer y = new Integer(127); Integer z = Integer.valueOf(127); Integer w = new Integer(127); System.out.println(x.equals(y));//true System.out.println(x == z); //true System.out.println(x == y); //false System.out.println(x == w); //false System.out.println(y == w); //false Integer x1 = Integer.valueOf(200); //false Integer x2 = Integer.valueOf(200); //false System.out.println(x1 == x2); } } 如果Integer.valueOf(x) x在-128~~127之间，就是使用享元模式，如果不在就重新创建新的Integer 小结： 在valueOf方法中，先判断值是否在IntegerCache中，如果不在，就创建新的Integer（new），否则直接从缓存池返回 valueOf() ,就是用到享元模式 如果使用valueOf方法得到一个Integer实例，范围在-128~127，执行速度比new快 享元模式注意事项和细节 在享元模式这样理解，’享‘就表示共享，’元‘表示对象 在系统有大量的对象，这些对象消耗大量的内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式 用唯一表示码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率 享元模式提高了系统的复杂度，需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制 享元模式经典的应用场景就是需要缓冲池的场景，比如String常量池，数据库连接池 十三、代理模式 代理模式的基本介绍 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。 被代理的对象可以使远程对象，创建开销大的对象或需要完全控制的对象。 代理模式有不同的形式，主要有三种，静态代理，动态代理（jdk代理、接口代理）和Cglib代理（可以在内存动态地创建对象，而不是实现接口，他是属于动态代理的范畴） 代理模式示意图 13.1 静态代理 静态代码模式的基本介绍 ​ 静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类 应用实例 具体实现 定义一个接口：ITeacherDao 目标对象TeacherDao实现接口ITeacherDao 使用静态代理方式，就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO 调用的时候通过调用代理对象的方法来调用目标对象 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法 思路分析图解(类图) //接口 public interface ITeacherDao { void teach();//授课的方法 } //目标对象 public class TeacherDao implements ITeacherDao{ @Override public void teach() { System.out.println(\"老师授课中....\"); } } //代理对象，静态代理 public class TeacherDaoProxy implements ITeacherDao{ private ITeacherDao target; //目标对象，通过接口来聚合 //构造器 public TeacherDaoProxy(ITeacherDao target) { this.target = target; } @Override public void teach() { System.out.println(\"开始代理....\"); //可以额外增加的方法 target.teach(); //核心方法 System.out.println(\"提交....\"); //可以额外增加的方法 } } public class Client { public static void main(String[] args) { //创建目标对象（被代理对象） TeacherDao teacherDao = new TeacherDao(); //创建代理对象，同时将被代理对象传递给代理对象 TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao); //通过代理对象，调用到被代理对象的方法 //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 teacherDaoProxy.teach(); } } 静态代理的优缺点 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能的扩展。 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类 一旦接口增加方法，目标对象与代理对象都要维护。 13.2 动态代理 动态代理的基本介绍 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 代理对象的生成，是利用Jdk的API，动态的在内存中构建代理对象。 动态代理也叫作：JDK代理、接口代理 jdk中生成代理对象API 代理类所在包：java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是：static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHanler h) 动态代理应用实例 应用实例要求：将前面的静态代理改进成动态代理模式(即：JDK代理模式) 思路图解(类图) //接口 public interface ITeacherDao { void teach(); //授课方法 void sayHello(String name); } //目标对象 public class TeacherDao implements ITeacherDao{ @Override public void teach() { System.out.println(\"老师正在授课中......\"); } @Override public void sayHello(String name) { System.out.println(\"hey:\"+ name); } } //代理对象 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class ProxyFactory { //维护目标对象，object private Object target; //构造器，对target进行初始化 public ProxyFactory(Object target) { this.target = target; } //给目标对象 生成一个代理对象 public Object getProxyInstance() { /* public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 1. ClassLoader loader： 指定当前目标对象使用的类加载器，获取加载器的方法固定 2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型 3. InvocationHandler: 事情处理，执行目标对象的方法时，会触发事情处理器的方法，会把当前执行的目标对象方法作为参数传入 */ return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"jdk代理开始\"); //反射机制调用目标对象的方法 Object returnVal = method.invoke(target, args); System.out.println(\"JDK代理提交\"); return returnVal; } }); } } public class Client { public static void main(String[] args) { //创建目标对象 ITeacherDao target = new TeacherDao(); //给目标对象，创建代理对象,可以转换成ITeacherDao ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance(); //输出：proxyInstance：com.atiguigu1.proxy.dynamic.TeacherDao@2503dbd3 // System.out.println(\"proxyInstance：\" + proxyInstance); //输出：proxyInstance：class com.sun.proxy.$Proxy0 （内存中动态生成了代理对象） System.out.println(\"proxyInstance：\" + proxyInstance.getClass()); //通过代理对象，调用目标对象的方法 // proxyInstance.teach(); proxyInstance.sayHello(\"tom\"); } } 13.3 Cglib代理13.3.1 Cglib代理模式的基本介绍 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-这就是Cglib代理 Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。 Cglib是一个强大的高性能的代码生成包，它可以在运行期间扩展Java类与实现java接口。它广泛的被许多AOP的框架使用。例如SpringAOP,实现方法拦截 在AOP编程中如何选择代理模式： 目标对象需要实现接口，用JDK代理 目标对象不需要实现接口，用Cglib代理 Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类 13.3.2 Cglib代理模式实现步骤 引入cglib的jar文件 在内存中动态构建子类，注意代理的类不能为final，否则报错 ​ java.lang.ILLegalArgumentExceotion: 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法。 13.3.3 Cglib代理模式应用实例应用实例要求： ​ 将前面的案例用Cglib代理模式实现 思路图解（类图） 代码实现 //目标对象 public class TeacherDao { public String teach() { System.out.println(\"老师授课中，我是cglib代理模式，不需要实现接口\"); return \"hello\"; } } import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class ProxyFactory implements MethodInterceptor { //维护一个目标对象 private Object target; //构造器，传入一个被代理的对象 public ProxyFactory(Object target) { this.target = target; } //返回一个代理对象，是target对象的代理对象 public Object getProxyInstance() { //1. 创建一个工具类 Enhancer enhancer = new Enhancer(); // 2. 设置父类 enhancer.setSuperclass(target.getClass()); // 3. 设置回调函数 enhancer.setCallback(this); // 4.创建子类对象，即代理对象 return enhancer.create(); } // 重写intercept 方法，会调用目标对象的方法 @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"Cglib代理模式 开始\"); Object returnVal = method.invoke(target, args); System.out.println(\"Cglib代理模式 —— 提交\"); return returnVal; } } public class Client { public static void main(String[] args) { //创建目标对象 TeacherDao target = new TeacherDao(); // 获取到代理对象，并且将目标对象传递给代理对象 TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance(); // 执行代理对象的方法，触发intecept方法，从而实现对目标对象的调用 String res = proxyInstance.teach(); System.out.println(res); } } 13.3.4 几种常见的代理模式介绍 -几种变体 防火墙代理 内网通过代理穿透防火墙，实现对公网的访问 缓存代理 比如：当请求图片文件等资源时候，先到缓存代理取，如果取到资源则ok，如果取不到资源，再到公网或者数据库取，然后缓存。 远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。 同步带利：主要使用在多线程编程中，完成多线程之间同步工作 十四、模块方法模式 豆浆制作问题 编写制作豆浆的程序，说明如下： 14.1 模块方法模式14.1.1 模块方法模式基本介绍 模块方法模式(Template Method Pattern),又叫做模块模式(Tenokate pattern)，z在一个抽象类公开定义了执行它的方法的模板，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方法进行。 简单点说，模块方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤 这种类型的设计模式属于行为性模式。 14.1.2 模块方法模式的原理类图 对原理类图的说明-即（木块方法模式的角色及职责） AbstractClass 抽象类，类中实现了模块方法（template），定义了算法的骨架，具体子类需要去实现，其它的抽象方法operationr2,3,4 ConcreteClass 实现抽象方法 operationr2,3,4, 以完成算法中特点子类的步骤 14.1.3 模块方法模式解决豆浆制作问题 思路分析和图解（类图） 代码实现 //抽象类，表示豆浆 public abstract class SoyaMilk { // 模板方法，make,模板方法可以做成final,不让子类去覆盖 final void make() { select(); addCondiments(); soak(); best(); } // 选材料 void select() { System.out.println(\"第一步：选择好的新鲜黄豆\"); } // 添加不同的配料，抽象方法，子类具体实现 abstract void addCondiments(); // 浸泡 void soak() { System.out.println(\"第三步，黄豆和配料开始浸泡，需要3小时\"); } void best() { System.out.println(\"第四步，黄豆和配料放到豆浆机去打碎 \"); } } public class RedBeanSoyaMilk extends SoyaMilk{ @Override void addCondiments() { System.out.println(\"加入上好的红豆\"); } } public class PeanutSoyaMilk extends SoyaMilk{ @Override void addCondiments() { System.out.println(\"加入上好的花生\"); } } public class Client { public static void main(String[] args) { // 制作红豆豆浆 System.out.println(\"制作红豆豆浆\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"制作花生豆浆\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); } } 14.1.4 模块方法模式的钩子方法 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事情，子类可以视情况要不要覆盖它，该方法成为“钩子” 还是用上面做黄豆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的末班方法进行改造。 代码 //抽象类，表示豆浆 public abstract class SoyaMilk { // 模板方法，make,模板方法可以做成final,不让子类去覆盖 final void make() { select(); if (customerWantCondiments()) { addCondiments(); } soak(); best(); } // 选材料 void select() { System.out.println(\"第一步：选择好的新鲜黄豆\"); } // 添加不同的配料，抽象方法，子类具体实现 abstract void addCondiments(); // 浸泡 void soak() { System.out.println(\"第三步，黄豆和配料开始浸泡，需要3小时\"); } void best() { System.out.println(\"第四步，黄豆和配料放到豆浆机去打碎 \"); } // 钩子方法，决定是否需要添加配料 boolean customerWantCondiments() { return true; } } public class PureSoyaMilk extends SoyaMilk{ @Override void addCondiments() { // 空实现 } @Override boolean customerWantCondiments() { return false; } } public class Client { public static void main(String[] args) { // 制作红豆豆浆 System.out.println(\"制作红豆豆浆\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"制作花生豆浆\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); System.out.println(\"制作纯豆浆\"); SoyaMilk pureSoyaMilk = new PureSoyaMilk(); pureSoyaMilk.make(); } } 14.1.5 模板方法模式在Spring框架应用的源码分析 Spring IOC容器初始化时运用到的模板方法模式 代码分析+角色分析+说明类图 针对源码的类图（说明层次关系） 14.1.6 模块方法模式的注意事项和细节 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时候，主要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。 实现了最大化代码复用。父类的模板方法和已经实现的某些步骤会被子类继承而直接使用 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。 一般模板的方法都机上final关键字。防止子类重写模板方法 模板方法模式使用场景：当要完成在某个过程，该过程要执行一些列步骤，这一系列的步骤基本相同，但其个别步骤在实现时，可能不同，通常考虑用模板方法模式来处理、 十五、命令模式 智能生活项目需求 15.1 命令模式基本介绍 命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个 ​ 我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名，同时命令模式也可以支持可撤销的操作。） 通俗易懂的理解：将军发布命令，士兵去执行，其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者），命令（连接将军和士兵） ​ Invoker是调用者（将军）、Receiver是被调用者（士兵）、MyCommand是命令，实现了Command接口，持有接收对象。 15.2 命令模式的原理类图 对原理类图的说明-即（命令模式的角色以及职责） Invoker：是调用者 Command：是命令角色，需要执行的所有命令都在这里，可以是接口或者抽象类 Receiver：接收者角色，知道如何实施和执行一个请求相关的操作 ConcreteCommand：将一个接收对象与一个动作绑定，调用接收者相应的操作，实现execute 15.3 命令模式解决智能生活项目应用实例要求 编写程序，使用命令模式 思路分析和图解 代码实现 //创建命令接口 public interface Command { // 执行动作（操作） public void execute(); // 撤销动作（操作） public void undo(); } public class LigheReceiver { public void on() { System.out.println(\"电灯打开了。。。\"); } public void off() { System.out.println(\"电灯关闭了\"); } } public class LightOnCommand implements Command{ // 聚合LigheReceiver LigheReceiver light; public LightOnCommand(LigheReceiver light) { this.light = light; } @Override public void execute() { // 调用接收者方法 light.on(); } @Override public void undo() { light.off(); } } public class LightOffCommand implements Command{ LigheReceiver light; public LightOffCommand(LigheReceiver light) { this.light = light; } @Override public void execute() { light.off(); } @Override public void undo() { light.on(); } } //没有任何命令，即空执行：用于初始化每个按钮，当调用空命令时候，对象什么都不做， //其实这样是一种设计模式，可以省掉对空的判断 public class NoCommand implements Command{ LigheReceiver light; @Override public void execute() { } @Override public void undo() { } } public class RemoteController { // 开按钮的命令数组 Command[] onCommands; Command[] offCommands; // 执行撤销的命令 Command undoCommand; // 构造器，完成对按钮初始化 public RemoteController() { onCommands = new Command[5]; offCommands = new Command[5]; for (int i = 0; i &lt; 5; i++) { onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); } } // 给我们的按钮设置你需要的命令 public void setCommand(int no, Command onCommand, Command offCommand) { onCommands[no] = onCommand; offCommands[no] = offCommand; } // 按下开按钮 public void onButtonWasPushed(int no) {//no 0 // 找到你按下的按钮,并调用对应的方法 onCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = onCommands[no]; } // 按下关按钮 public void offButtonWasPushed(int no) {//no 0 // 找到你按下的按钮,并调用对应的方法 offCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = offCommands[no]; } // 按下撤销按钮 public void undoButtonWasPushed() { undoCommand.undo(); } } public class Client { public static void main(String[] args) { // 使用命令设计模式，完成通过遥控器，对电灯的操作 // 创建电灯的对象（接受者） LigheReceiver ligheReceiver = new LigheReceiver(); // 创建电灯相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(ligheReceiver); LightOffCommand lightOffCommand = new LightOffCommand(ligheReceiver); // 需要一个遥控器 RemoteController remoteController = new RemoteController(); // 给我们的遥控器设置命令,比如no = 0 是电灯的开和关操作 remoteController.setCommand(0, lightOnCommand, lightOffCommand); System.out.println(\"按下灯开的按钮\"); remoteController.onButtonWasPushed(0); System.out.println(\"按下灯关的按钮\"); remoteController.offButtonWasPushed(0); System.out.println(\"按下灯撤销的按钮\"); remoteController.undoButtonWasPushed(); } } 15.4 命令模式在Spring框架JdbcTemplate应用的源码分析 模式角色分析说明 15.5 命令模式的注意事项和细节 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者。调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：“请求发起者”和“请求执行者”之间的解耦是通过命令对象实现，命令对象起到了纽带桥梁作用。 容易设计一个命令队列。只要把命令对象放到队列，就可以多线程的执行命令。 容易实现对请求的撤销和重做。 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意 空命令也是一种设计模式，它为我们省去了判空的操作，在上面的实例中，如果没有用空命令，我们每按下一个按键就要判空，这给我们编码带来一定的麻烦。 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令）订单撤销/恢复、触发-反馈机制 十六、访问者模式16.1 传统方案 16.2 访问者模式基本介绍 访问者模式(Visitor Pattern),封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 主要将数据结构与拘束操作分离，解决数据结构和操作的耦合性问题 访问者模式的基本工作原理是：在被访问的类型里面加一个对外提供接待访问的接口 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联),同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决。 16.3 访问者模式的原理类图 对原理类图的说明- 即（访问者模式的角色以及职责） Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作 ConcreteVistior：是一个具体的访问值，实现每个有Visitor声明的操作，是每个操作实现的部分 ObjectStruture能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素 Element定义一个accept方法，接收一个访问者对象 ConcreteElement为具体元素，实现了accept方法 16.4 访问者模式应用实例应用实例要求 将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对改个手不同的评价（评价有不同的种类，比如 成功、失败等），请使用访问者模式来实现 思路分析和图解(类图) 代码实现 public abstract class Action { // 得到男性的测评 public abstract void getManResult(Man man); // 得到女性的测评 public abstract void getWomanResult(Woman woman); } public abstract class Person { // 提供一个方法，让访问者可以访问 public abstract void accept(Action action); } public class Man extends Person{ @Override public void accept(Action action) { action.getManResult(this); } } //说明 //1.这里我们使用到了双分派，即首先在客户端程序中，将具体的状态作为参数传递Woman中（第一次分派） //2.然后Woman类中调用作为参数的“具体方法”中方法getWomanResult，同时将自己（this）作为参数传入，完成第二次分派 public class Woman extends Person{ @Override public void accept(Action action) { action.getWomanResult(this); } } public class Success extends Action{ @Override public void getManResult(Man man) { System.out.println(\"男人给的评价是该歌手成功\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"女人给的评价是该歌手成功\"); } } public class Fail extends Action{ @Override public void getManResult(Man man) { System.out.println(\"男人给的评价是该歌手失败\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"女人给的评价是该歌手失败\"); } } public class Wait extends Action{ @Override public void getManResult(Man man) { System.out.println(\"男人给的评价是该歌手待定..\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"男人给的评价是该歌手待定..\"); } } import java.util.LinkedList; import java.util.List; //数据结构，管理很多人(Man,Woman) public class ObjectStructure { // 维护了一个集合 private List&lt;Person&gt; persons = new LinkedList&lt;&gt;(); // 增加到list public void attach(Person p){ persons.add(p); } // 移除 public void detach(Person p){ persons.remove(p); } // 显示测评情况 public void display(Action action) { for (Person p : persons) { p.accept(action); } } } public class Client { public static void main(String[] args) { ObjectStructure objectStructure = new ObjectStructure(); objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 Success success = new Success(); objectStructure.display(success); System.out.println(\" \"); Fail fail = new Fail(); objectStructure.display(fail); System.out.println(\" \"); Wait wait = new Wait(); objectStructure.display(wait); } } 应用实例小结-双分派 上面提到了双分派，所谓的双分派是指不管类怎么变化，我们都能找到期望的方法运行，双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型 以上述实例，假设我们得到添加一个Wait的状态类，考察Man 类和Woman类的反应，由于使用了双分派，只需要增加一个Action子类即可在客户端调用，不需要改动任何其他类的代码 16.5 访问者模式的注意事项和细节优点 访问者模式符合单一职责原则，让程序具有优秀的扩展性、灵活性非常高 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器、适用于数据结构相对稳定的系统 缺点 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难 违背了依赖倒转原则，访问者依赖的是具体元素，而不是抽象元素 因此。如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较适合 十七、迭代器模式17.1 传统方案 传统的设计方案 传统方式的问题分析 将学院你做事学校的子类，系是学院的子类，这样实际上就是站在组织大小进行分层次的 实际上我们的要求是:在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的遍历操作 解决方案=&gt;迭代器模式 17.2 迭代器模式基本介绍基本介绍 迭代器模式是常用的设计模式，属于行为型模式 如果我们的集合元素是不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多重遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构 迭代器模式的原理类图 对原理类图的说明（迭代器模式的角色以及职责） Itertor:迭代器接口，是系统提供，含义hasNext，next,remove ConcretrIterator:具体的迭代器类，管理迭代 Aggregate:一个统一的聚合接口，将客户端和具体聚合解耦 ConcreteAggreage:具体的聚合持有对象集合，并且提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合 Client:客户端，通过Iterator和Aggregate依赖子类 17.3 迭代器模式应用实例 应用实例要求 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校又多个学院，一个学院有多个系 设计思路分析 代码实现 //系 public class Department { private String name; private String desc; public Department(String name, String desc) { this.name = name; this.desc = desc; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } public interface Colleage { public String getName(); // 增加系的方法 public void addDepartment(String name, String desc); // 返回一个迭代器，遍历 public Iterator createIterator(); } public class ConputerColleageIterator implements Iterator { // 这里我们需要知道department是以怎样的方式存放 =》数组 Department[] departments; int position = 0; //遍历的位置 public ConputerColleageIterator(Department[] departments) { this.departments = departments; } // 判断是否还有下一个元素 @Override public boolean hasNext() { if (position &gt;= departments.length || departments[position] == null) { return false; } else { return true; } } @Override public Object next() { Department department = departments[position]; position += 1; return department; } // 删除的方法，默认空实现 @Override public void remove() { } } public class InfoColleageIterator implements Iterator { List&lt;Department&gt; departments; //信息工程学院是以List方式存放系 int index = -1; //索引 public InfoColleageIterator(List&lt;Department&gt; departments) { this.departments = departments; } @Override public boolean hasNext() { if (index &gt;= departments.size() - 1) { return false; } else { index += 1; return true; } } @Override public Object next() { return departments.get(index); } @Override public void remove() { } } public class ComputerColleage implements Colleage{ Department[] departments; int numOfDepartment = 0; //保存当前数组的对象个数 public ComputerColleage() { departments = new Department[5]; addDepartment(\"Java专业\",\"Java专业\"); addDepartment(\"PHP专业\",\"PHP专业\"); addDepartment(\"大数据专业\",\"大数据专业\"); } @Override public String getName() { return \"计算机学院\"; } @Override public void addDepartment(String name, String desc) { Department department = new Department(name, desc); departments[numOfDepartment] = department; numOfDepartment += 1; } @Override public Iterator createIterator() { return new ConputerColleageIterator(departments); } } public class InfoColleage implements Colleage{ List&lt;Department&gt; departmentList; public InfoColleage() { departmentList = new ArrayList&lt;&gt;(); addDepartment(\"信息安全专业\",\"信息安全专业\"); addDepartment(\"网络安全专业\",\"网络安全专业\"); addDepartment(\"数据安全专业\",\"数据安全专业\"); } @Override public String getName() { return \"信息工程学院\"; } @Override public void addDepartment(String name, String desc) { Department department = new Department(name, desc); departmentList.add(department); } @Override public Iterator createIterator() { return (Iterator) new InfoColleageIterator(departmentList); } } public class OutPutImpl { // 学院集合 List&lt;Colleage&gt; colleageList; public OutPutImpl(List&lt;Colleage&gt; colleageList) { this.colleageList = colleageList; } // 遍历所有学院，然后调用printDepartment 输出各个学院的系 public void printColleage() { // 从colleageList取出所有学院，Java中的List已经实现Iterator Iterator&lt;Colleage&gt; iterator = colleageList.iterator(); while (iterator.hasNext()) { // 取出一个学院 Colleage colleage = iterator.next(); System.out.println(\"====\" + colleage.getName() + \"======\"); printDepartment((Iterator) colleage.createIterator());//得到对应的迭代器 } } // 输出学院输出系 public void printDepartment(Iterator iterator) { while (iterator.hasNext()) { Department d = (Department) iterator.next(); System.out.println(d.getName()); } } } public class Client { public static void main(String[] args) { // 创建学院 List&lt;Colleage&gt; colleageList = new ArrayList&lt;&gt;(); ComputerColleage computerColleage = new ComputerColleage(); InfoColleage infoColleage = new InfoColleage(); colleageList.add(computerColleage); colleageList.add(infoColleage); OutPutImpl outPutImpl = new OutPutImpl(colleageList); outPutImpl.printColleage(); } } 17.4 迭代器模式在JDK-ArrayList集合应用的源码分析 JDK的ArrayList集合中就使用了迭代器模式 代码分析+类图+说明 3.对类图的角色分析和说明 内部类Itr充当具体实现迭代器Iterator的类，作为ArrayList内部类 List就是充当了聚合接口，含有一个iterator()方法，返回一个迭代器对象 ArrayList是实现聚合接口List的子类，实现了iterator() Iterator接口系统提供 迭代器模式解决了不同集合(ArrayList,LinkedList)统一遍历问题 17.5迭代器模式的注意事项和细节优点 提供了一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道决和的具体组成 提供了一种设计思想，就是一个类应该只有一个引起变化的原因(叫做单一责任原则)。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方法改变的话，只影响到了迭代器 而要展示一组相似对象。或者遍历一组相同对象时使用，适合使用迭代器模式 缺点 每个聚合对象都是要一个迭代器，会产生多个迭代器不好管理 十八、观察者模式18.1 传统方案 天气预报设计方案-普通方案 WeatherData类 通过getXxx方法，可以让第三方接入，并且得到相关信息 当数据有更新时候，气象站通过调用dataChange()去更新数据。当第三方再次获取时，就能得到最新数据，当然也可以推送 CurrentConditions(当前天气的情况) 可以理解成是我们气象局的网站//推送 代码实现 /** * 显示当前天气情况(可以理解成是气象站自己的网站) */ public class CurrentConditions { // 温度、气压、湿度 private float temperature; private float pressure; private float humidity; // 更新天气情况，是由WeatherData来调用，使用推送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"****Today mTemperature:\" + temperature + \"******\"); System.out.println(\"****Today mPressure:\" + pressure + \"******\"); System.out.println(\"****Today mHumidity:\" + humidity + \"******\"); } } /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有CurrentConditions对象 * 3. 当数据有更新的时候，就调用CurrentConditions对象update方法(含display)，这样他们(接入方)就看到最新的消息 */ public class WeatherData { private float temperatrue; private float pressure; private float humidity; private CurrentConditions currentConditions; public WeatherData(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } public float getTemperatrue() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { // 调用接入方的update currentConditions.update(getTemperatrue(), getPressure(), getHumidity()); } // 当数据有更新时候，就调用setData public void setData(float temperatrue, float pressure, float humidity) { this.temperatrue = temperatrue; this.pressure = pressure; this.humidity = humidity; // 调用dataChange,将最新的信息推送给接入方currentConditions dataChange(); } } public class Client { public static void main(String[] args) { // 创建接入方currentConditions CurrentConditions currentConditions = new CurrentConditions(); // 创建WeatherData 并将接入方currentConditions传递到WeatherData中 WeatherData weatherData = new WeatherData(currentConditions); // 更新天气情况 weatherData.setData(30,150,40); System.out.println(\"======== \"); // 天气情况变化 weatherData.setData(40, 160, 20); } } 问题分析 其他第三方接入气象站获取数据的问题 无法在运行时动态的添加第三方(新浪网站) 违反ocp原则=&gt;观察者模式 //在WeatherData中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到dataChange,不利于维护，也不是动态加入 public void dataChange() { // 调用接入方的update currentConditions.update(getTemperatrue(), getPressure(), getHumidity()); } 18.2 观察者模式原理 观察者模式类似于订牛奶业务 奶站/气象局:Subject 用户/第三方网站:Observer Subject:登记注册、移除和通知 registerObserver 注册 removeObserver移除 notifyObservers( )通知所有的注册的用户，根据不同的需求，可以是更新数据，让用户来取，也可能是实施推送。 Observer:接收输入 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer,Subject通知Observer变化，比如这里的奶站是Subject，是1的一方。用户时Observer,是多的一方。 18.3 观察者模式解决天气预报需求 观察者模式的好处： 观察者模式设计后，会以集合的方式来管理用户(Observer),包括注册，移除和通知 我们增加观察者(这里可以理解成一个新的公告板，就不需要去修改核心类WeatherData不会修改代码)，遵守了ocp原则 类图说明 代码实现 //接口,让 WeatherData 来实现 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } //观察者接口，由观察者来实现 public interface Observer { public void update(float temperature, float pressure, float humidity); } public class CurrentConditions implements Observer{ // 温度、气压、湿度 private float temperature; private float pressure; private float humidity; // 更新天气情况，是由WeatherData来调用，使用推送模式 @Override public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"****Today mTemperature:\" + temperature + \"******\"); System.out.println(\"****Today mPressure:\" + pressure + \"******\"); System.out.println(\"****Today mHumidity:\" + humidity + \"******\"); } } public class BaiduSite implements Observer{ // 温度、气压、湿度 private float temperature; private float pressure; private float humidity; // 更新天气情况，是由WeatherData来调用，使用推送模式 @Override public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"Baidu \"); System.out.println(\"****Baidu Temperature:\" + temperature + \"******\"); System.out.println(\"****Baidu Pressure:\" + pressure + \"******\"); System.out.println(\"****Baidu Humidity:\" + humidity + \"******\"); } } /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有 观察者集合，使用ArrayList管理 * 3. 当数据有更新的时候，就调用 ArrayList,通知所有的(接入方)就看到最新的消息 */ public class WeatherData implements Subject{ private float temperatrue; private float pressure; private float humidity; // 观察者集合 private ArrayList&lt;Observer&gt; observers; // 加入新的第三方 public WeatherData() { observers = new ArrayList&lt;Observer&gt;(); } public float getTemperatrue() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { // 调用接入方的update // currentConditions.update(getTemperatrue(), getPressure(), getHumidity()); notifyObservers(); } // 当数据有更新时候，就调用setData public void setData(float temperatrue, float pressure, float humidity) { this.temperatrue = temperatrue; this.pressure = pressure; this.humidity = humidity; // 调用dataChange,将最新的信息推送给接入方currentConditions dataChange(); } // 注册一个观察者 @Override public void registerObserver(Observer o) { observers.add(o); } // 移除一个观察者 @Override public void removeObserver(Observer o) { if (observers.contains(o)) { observers.remove(o); } } // 遍历所有的观察者，并通知 @Override public void notifyObservers() { for (int i = 0; i &lt; observers.size(); i++) { observers.get(i).update(this.temperatrue, this.pressure, this.humidity); } } } public class Client { public static void main(String[] args) { // 创建一个WeatherData WeatherData weatherData = new WeatherData(); // 创建观察者 CurrentConditions currentConditions = new CurrentConditions(); BaiduSite baiduSite = new BaiduSite(); // 注册到weatherData weatherData.registerObserver(currentConditions); weatherData.registerObserver(baiduSite); // 测试 System.out.println(\"通知各个注册的观察者，看看信息\"); weatherData.setData(10f, 100f, 30.3f); System.out.println(\"====one====\"); weatherData.removeObserver(currentConditions); weatherData.setData(5f, 65f, 12f); } } 18.4 观察者模式在jdk应用的源码分析 jdk的Observable类就使用了观察者模式 代码分析+模式角色分析 模式角色分析 Observable的作用和地位等价于我们前面讲过的Subject Observable是类，不是接口，类中已经实现了核心的方法，即管理Observer的方法 add…delete…notify… Observer的作用和地位等价于我们前面讲过的Observer，有update Observable和Observer的使用方法和前面讲过的一样，只是Observable是类，通过继承来实现观察者模式 十九、中介者模式19.1 传统方案 传统方案解决智能家庭管理问题 传统的方式的问题分析 当各电器对象有多种状态改变时候，相互之间的调用关系会比较复杂 各个电器对象彼此联系，不利于耦合 各个电器对象之间所传递的消息(参数)，容易混乱 当系统增加一个新的电器对象的时候，或者执行流程改变时候，代码的可维护性、扩展性都不理想 19.2 中介者模式基本介绍 中介者模式，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式属于行为型模式，使代码易于维护 比如MVC模式，C（Controller控制器）是M(Model模型)和V(View视图)的中介者，在前后端交互时候起到了中间人的作用 中介者模式的原理类图 19.3 对原理类图的说明-即(中介者模式的角色以及职责) Mediator 就是抽象中介者，定义了同事对象到中介者对象的接口 Colleague是抽象同事类 ConcreteMediator具体的中介者对象，实现抽象方法，他需要知道所有的具体的同事类，即以一个集合来管理HashMap,并接受某个同时对象消息，完成响应的任务 ConcreteColleague具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其他同事类的行为(方法),但时他们都依赖中介者对象 19.4 中介者模式应用实例-只能家庭管理 应用实例要求 ​ 完成前面的智能家庭的项目，使用中介者模式 思路分析和图解(类图) 代码实现 //同事抽象类 public abstract class Colleague { private Mediator mediator; public String name; public Colleague(Mediator mediator, String name) { this.mediator = mediator; this.name = name; } public Mediator GetMediator() { return this.mediator; } public abstract void SendMessage(int stateChange); } public abstract class Mediator { //将给中介者对象，加入到集合中 public abstract void Register(String colleagueName, Colleague colleague); //接收消息, 具体的同事对象发出 public abstract void GetMessage(int stateChange, String colleagueName); public abstract void SendMessage(); } public class CoffeeMachine extends Colleague { public CoffeeMachine(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void StartCoffee() { System.out.println(\"It's time to startcoffee!\"); } public void FinishCoffee() { System.out.println(\"After 5 minutes!\"); System.out.println(\"Coffee is ok!\"); SendMessage(0); } } public class Curtains extends Colleague { public Curtains(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void UpCurtains() { System.out.println(\"I am holding Up Curtains!\"); } } public class TV extends Colleague { public TV(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void StartTv() { // TODO Auto-generated method stub System.out.println(\"It's time to StartTv!\"); } public void StopTv() { // TODO Auto-generated method stub System.out.println(\"StopTv!\"); } } public class CoffeeMachine extends Colleague { public CoffeeMachine(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void StartCoffee() { System.out.println(\"It's time to startcoffee!\"); } public void FinishCoffee() { System.out.println(\"After 5 minutes!\"); System.out.println(\"Coffee is ok!\"); SendMessage(0); } } //具体的中介者类 public class ConcreteMediator extends Mediator { //集合，放入所有的同事对象 private HashMap&lt;String, Colleague&gt; colleagueMap; private HashMap&lt;String, String&gt; interMap; public ConcreteMediator() { colleagueMap = new HashMap&lt;String, Colleague&gt;(); interMap = new HashMap&lt;String, String&gt;(); } @Override public void Register(String colleagueName, Colleague colleague) { // TODO Auto-generated method stub colleagueMap.put(colleagueName, colleague); // TODO Auto-generated method stub if (colleague instanceof Alarm) { interMap.put(\"Alarm\", colleagueName); } else if (colleague instanceof CoffeeMachine) { interMap.put(\"CoffeeMachine\", colleagueName); } else if (colleague instanceof TV) { interMap.put(\"TV\", colleagueName); } else if (colleague instanceof Curtains) { interMap.put(\"Curtains\", colleagueName); } } //具体中介者的核心方法 //1. 根据得到消息，完成对应任务 //2. 中介者在这个方法，协调各个具体的同事对象，完成任务 @Override public void GetMessage(int stateChange, String colleagueName) { // TODO Auto-generated method stub //处理闹钟发出的消息 if (colleagueMap.get(colleagueName) instanceof Alarm) { if (stateChange == 0) { ((CoffeeMachine) (colleagueMap.get(interMap .get(\"CoffeeMachine\")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get(\"TV\")))).StartTv(); } else if (stateChange == 1) { ((TV) (colleagueMap.get(interMap.get(\"TV\")))).StopTv(); } } else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) { ((Curtains) (colleagueMap.get(interMap.get(\"Curtains\")))) .UpCurtains(); } else if (colleagueMap.get(colleagueName) instanceof TV) {//如果TV发现消息 } else if (colleagueMap.get(colleagueName) instanceof Curtains) { //如果是以窗帘发出的消息，这里处理... } } @Override public void SendMessage() { // TODO Auto-generated method stub } } public class Client { public static void main(String[] args) { //创建一个中介者对象 Mediator mediator = new ConcreteMediator(); //创建Alarm 并且加入到 ConcreteMediator 对象的HashMap Alarm alarm = new Alarm(mediator, \"alarm\"); //创建了CoffeeMachine 对象，并 且加入到 ConcreteMediator 对象的HashMap CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, \"coffeeMachine\"); //创建 Curtains , 并 且加入到 ConcreteMediator 对象的HashMap Curtains curtains = new Curtains(mediator, \"curtains\"); TV tV = new TV(mediator, \"TV\"); //让闹钟发出消息 alarm.SendAlarm(0); coffeeMachine.FinishCoffee(); alarm.SendAlarm(1); } } 19.5 中介者模式的注意事项和细节 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦 减少类间依赖，降低了耦合，符合迪米特法则 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响 如果 设计不当，中介者对象本身变得过于复杂，这点在实际使用时候，要特别注意 二十、备忘录模式20.1 传统方案 20.2 备忘录模式基本介绍基本介绍 备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态 可以这样理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作 备忘录模式属于行为型模式 20.3 备忘录模式的原理类图 对原理类图的说明-即(备忘录模式的角色以及职责) originator：对象(需要保存状态的对象) Memento:备忘录对象，负责保存好记录，即Originator内部状态 Caretaker：守护者对象。负责保存多个备忘录对象。使用集合管理，提高效率 说明：如果希望保存个originator对象的不同状态，也可以，只需要HashMap&lt;String,集合&gt; 代码实现 public class Originator { private String state;//状态信息 public String getState() { return state; } public void setState(String state) { this.state = state; } // 编写一哥方法，可以保存一个状态对象Memento // 因此编写一个方法，返回Memento public Memento saveStateMemento() { return new Memento(state); } // 通过备忘录对象，恢复状态 public void getStateFromMemento(Memento memento) { state = memento.getState(); } } public class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } public class Caretaker { // 在List集合中会有很多的备忘录对象 private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); public void add(Memento memento) { mementoList.add(memento); } // 获取到第index个Originator 的备忘录对象(即保存状态) public Memento get(int index) { return mementoList.get(index); } public void getList() { for (Memento memento : mementoList) { System.out.println(memento.getState()); } } } public class Client { public static void main(String[] args) { Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(\"状态#1 攻击力100\"); // 保存了当前的状态 caretaker.add(originator.saveStateMemento()); originator.setState(\"状态#2 攻击力160\"); caretaker.add(originator.saveStateMemento()); originator.setState(\"状态#3 攻击力120\"); caretaker.add(originator.saveStateMemento()); System.out.println(\"当前的状态是=\" + originator.getState()); // 希望恢复到状态1 originator.getStateFromMemento(caretaker.get(0)); System.out.println(\"恢复后的状态=\" + originator.getState()); System.out.println(\"=====\"); caretaker.getList(); } } 20.4 角色恢复状态实例 思路分析和图解(类图) 代码实现 public class Memento { // 攻击力、防御 private int vit; private int def; public Memento(int vit, int def) { this.vit = vit; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } //守护者对象，保存游戏角色的状态 public class Caretaker { // 如果值保存一次状态 private Memento memento; // 对GameRole 保存多次状态 // private ArrayList&lt;Memento&gt; mementos; // 对多个游戏角色保存多个状态 // private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } public class GameRole { private int vit; private int def; // 创建Memento，即根据当前的状态得到Memento public Memento createMemento() { return new Memento(vit, def); } // 从备忘录对象，恢复GameRole状态 public void recoverGameRoleFromMemento(Memento memento) { this.vit = memento.getVit(); this.def = memento.getDef(); } // 显示当前游戏角色的状态 public void display() { System.out.println(\"游戏角色当前的攻击力：\" + this.vit + \" 防御力为：\" + this.def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } public class Client { public static void main(String[] args) { // 创建游戏角色 GameRole gameRole = new GameRole(); gameRole.setVit(100); gameRole.setDef(60); System.out.println(\"和BOSS大战前的状态\"); gameRole.display(); // 把当前状态保存caretaker Caretaker caretaker = new Caretaker(); caretaker.setMemento(gameRole.createMemento()); System.out.println(\"和BOSS大战~~~被削弱\"); gameRole.setVit(80); gameRole.setDef(40); gameRole.display(); System.out.println(\"大战后，使用备忘录对象恢复到战斗前\"); gameRole.recoverGameRoleFromMemento(caretaker.getMemento()); System.out.println(\"恢复后的状态\"); gameRole.display(); } } 20.5 备忘录吗，模式的注意事项和细节 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意 适用的应用场景：1. 后悔药。 2、打游戏时候的存档。 3、Windows里面的ctrl+z。 4.IE的后退。 4、数据库的事务管理 为了节约内存，备忘录模式可以和原型模式配合使用 二十一、解释器模式21.1 四则运算问题 21.2 传统方案解决四则运算问题分析 编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果 问题分析：如果加入新的运算符，比如*/(等等，不利于扩展，另外一个方法来解析会造成程序结构混乱，不够清晰) 解决方案：可有考虑使用解释器模式：即：表达式-&gt;解释器(可以有多种) -&gt;结果 21.3 解释器模式基本介绍 在编译原理中，一个算术表达式通过词法解析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器 解释器模式：是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式) 应用场景 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来表达 一个简单语法需要解释的场景 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等 21.4 解释器模式的原理类图 对原理类图的说明 -即(解释器模式的角色以及职责) Context:是环境角色，含有解释器之外的全局信息 AbstractExpression:抽象表达式，声明一个抽象的解释操作，这个方法为抽象语法树汇总所有的节点所共享 TerminalExpression：为终结符表达式。为文法中的非终结符实现解释操作 NonTermialExpression:为非终结符表达式，为文法中的非终结符实现解释操作 说明：输入Context he TermainalExpression 信息通过Client输入即可 21.5 解释器模式来实现四则 应用实例要求 通过解释器模式来实现四则运算 ​ 如计算a+b-c的值 思路分析和图解(类图) 代码实现 /** * 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值 */ public abstract class Expression { // a + b - c // 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值 // HashMap {a=10, b=20} public abstract int interpreter(HashMap&lt;String, Integer&gt; var); } /** * 变量的解释器 */ public class VarExpression extends Expression { private String key; // key=a,key=b,key=c public VarExpression(String key) { this.key = key; } // var 就是{a=10, b=20} // interpreter 根据 变量名称，返回对应值 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) { return var.get(this.key); } } /** * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系， * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类 */ public class SymbolExpression extends Expression { protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) { this.left = left; this.right = right; } //因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) { // TODO Auto-generated method stub return 0; } } /** * 加法解释器 */ public class AddExpression extends SymbolExpression { public AddExpression(Expression left, Expression right) { super(left, right); } //处理相加 //var 仍然是 {a=10,b=20}.. //一会我们debug 源码,就ok @Override public int interpreter(HashMap&lt;String, Integer&gt; var) { //super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10 //super.right.interpreter(var): 返回right 表达式对应值 b = 20 return super.left.interpreter(var) + super.right.interpreter(var); } } public class SubExpression extends SymbolExpression { public SubExpression(Expression left, Expression right) { super(left, right); } //求出left 和 right 表达式相减后的结果 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) { return super.left.interpreter(var) - super.right.interpreter(var); } } public class Calculator { // 定义表达式 private Expression expression; // 构造函数传参，并解析 public Calculator(String expStr) { // expStr = a+b // 安排运算先后顺序 Stack&lt;Expression&gt; stack = new Stack&lt;&gt;(); // 表达式拆分成字符数组 char[] charArray = expStr.toCharArray();// [a, +, b] Expression left = null; Expression right = null; //遍历我们的字符数组， 即遍历 [a, +, b] //针对不同的情况，做处理 for (int i = 0; i &lt; charArray.length; i++) { switch (charArray[i]) { case '+': // left = stack.pop();// 从stack取出left =&gt; \"a\" right = new VarExpression(String.valueOf(charArray[++i]));// 取出右表达式 \"b\" stack.push(new AddExpression(left, right));// 然后根据得到left 和 right 构建 AddExpresson加入stack break; case '-': // left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: //如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack stack.push(new VarExpression(String.valueOf(charArray[i]))); break; } } //当遍历完整个 charArray 数组后，stack 就得到最后Expression this.expression = stack.pop(); } public int run(HashMap&lt;String, Integer&gt; var) { //最后将表达式a+b和 var = {a=10,b=20} //然后传递给expression的interpreter进行解释执行 return this.expression.interpreter(var); } } public class Client{ public static void main(String[] args) throws IOException { // TODO Auto-generated method stub String expStr = getExpStr(); // a+b HashMap&lt;String, Integer&gt; var = getValue(expStr);// var {a=10, b=20} Calculator calculator = new Calculator(expStr); System.out.println(\"运算结果：\" + expStr + \"=\" + calculator.run(var)); } // 获得表达式 public static String getExpStr() throws IOException { System.out.print(\"请输入表达式：\"); return (new BufferedReader(new InputStreamReader(System.in))).readLine(); } // 获得值映射 public static HashMap&lt;String, Integer&gt; getValue(String expStr) throws IOException { HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : expStr.toCharArray()) { if (ch != '+' &amp;&amp; ch != '-') { if (!map.containsKey(String.valueOf(ch))) { System.out.print(\"请输入\" + String.valueOf(ch) + \"的值：\"); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(ch), Integer.valueOf(in)); } } } return map; } } 21.6 解释器模式在Spring框架应用的源码剖析 说明 21.7 解释器模式的注意事项和细节 当有一个语言需要解释执行，可将语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性 应用场景：编译器、运算表达式计算、正则表达式、机器人等 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低 二十二、状态模式22.1 APP抽奖活动问题 22.2 状态模式基本介绍 状态模式：它主要用来解决对象再多种状态转换时候，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换 当一个对象的内在状态改变时候，允许改变其行为，这个对象看起来像是改变了其类 22.3 状态模式的原理类图 对原理类图的说明-即（状态模式的角色以及职责） Context类为环境角色，用于维护State实例，这个实例定义当前状态 State是抽象状态角色，定义一个接口封装与Context的一个特点接口相关行为 ConcreteState具体的状态角色，每个子类实现一个与Context的一个状态相关行为 22.4 状态模式解决APP抽奖问题 应用实例要求 完成APP抽象活动项目，使用状态模式 思路分析和图解(类图) 定义一个接口叫做状态接口，每个状态都实现它 接口有扣除积分方法、抽奖方法、发放讲评方法 代码实现 /** * 状态抽象类 */ public abstract class State { // 扣除积分 - 50 public abstract void deductMoney(); // 是否抽中奖品 public abstract boolean raffle(); // 发放奖品 public abstract void dispensePrize(); } /** * 不能抽奖状态 */ public class NoRaffleState extends State { // 初始化时传入活动引用，扣除积分后改变其状态 RaffleActivity activity; public NoRaffleState(RaffleActivity activity) { this.activity = activity; } // 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态 @Override public void deductMoney() { System.out.println(\"扣除50积分成功，您可以抽奖了\"); activity.setState(activity.getCanRaffleState()); } // 当前状态不能抽奖 @Override public boolean raffle() { System.out.println(\"扣了积分才能抽奖喔！\"); return false; } // 当前状态不能发奖品 @Override public void dispensePrize() { System.out.println(\"不能发放奖品\"); } } import java.util.Random; /** * 可以抽奖的状态 */ public class CanRaffleState extends State { RaffleActivity activity; public CanRaffleState(RaffleActivity activity) { this.activity = activity; } //已经扣除了积分，不能再扣 @Override public void deductMoney() { System.out.println(\"已经扣取过了积分\"); } //可以抽奖, 抽完奖后，根据实际情况，改成新的状态 @Override public boolean raffle() { System.out.println(\"正在抽奖，请稍等！\"); Random r = new Random(); int num = r.nextInt(10); // 10%中奖机会 if(num == 0){ // 改变活动状态为发放奖品 context activity.setState(activity.getDispenseState()); return true; }else{ System.out.println(\"很遗憾没有抽中奖品！\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); return false; } } // 不能发放奖品 @Override public void dispensePrize() { System.out.println(\"没中奖，不能发放奖品\"); } } /** * 发放奖品的状态 */ public class DispenseState extends State { // 初始化时传入活动引用，发放奖品后改变其状态 RaffleActivity activity; public DispenseState(RaffleActivity activity) { this.activity = activity; } // @Override public void deductMoney() { System.out.println(\"不能扣除积分\"); } @Override public boolean raffle() { System.out.println(\"不能抽奖\"); return false; } //发放奖品 @Override public void dispensePrize() { if(activity.getCount() &gt; 0){ System.out.println(\"恭喜中奖了\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); }else{ System.out.println(\"很遗憾，奖品发送完了\"); // 改变状态为奖品发送完毕, 后面我们就不可以抽奖 activity.setState(activity.getDispensOutState()); System.out.println(\"抽奖活动结束\"); System.exit(0); } } } /** * 奖品发放完毕状态 * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束 */ public class DispenseOutState extends State { // 初始化时传入活动引用 RaffleActivity activity; public DispenseOutState(RaffleActivity activity) { this.activity = activity; } @Override public void deductMoney() { System.out.println(\"奖品发送完了，请下次再参加\"); } @Override public boolean raffle() { System.out.println(\"奖品发送完了，请下次再参加\"); return false; } @Override public void dispensePrize() { System.out.println(\"奖品发送完了，请下次再参加\"); } } /** * 抽奖活动 // */ public class RaffleActivity { // state 表示活动当前的状态，是变化 State state = null; // 奖品数量 int count = 0; // 四个属性，表示四种状态 State noRafflleState = new NoRaffleState(this); State canRaffleState = new CanRaffleState(this); State dispenseState = new DispenseState(this); State dispensOutState = new DispenseOutState(this); //构造器 //1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态） //2. 初始化奖品的数量 public RaffleActivity( int count) { this.state = getNoRafflleState(); this.count = count; } //扣分, 调用当前状态的 deductMoney public void debuctMoney(){ state.deductMoney(); } //抽奖 public void raffle(){ // 如果当前的状态是抽奖成功 if(state.raffle()){ //领取奖品 state.dispensePrize(); } } public State getState() { return state; } public void setState(State state) { this.state = state; } //这里请大家注意，每领取一次奖品，count-- public int getCount() { int curCount = count; count--; return curCount; } public void setCount(int count) { this.count = count; } public State getNoRafflleState() { return noRafflleState; } public void setNoRafflleState(State noRafflleState) { this.noRafflleState = noRafflleState; } public State getCanRaffleState() { return canRaffleState; } public void setCanRaffleState(State canRaffleState) { this.canRaffleState = canRaffleState; } public State getDispenseState() { return dispenseState; } public void setDispenseState(State dispenseState) { this.dispenseState = dispenseState; } public State getDispensOutState() { return dispensOutState; } public void setDispensOutState(State dispensOutState) { this.dispensOutState = dispensOutState; } } /** * 状态模式测试类 */ public class ClientTest { public static void main(String[] args) { // TODO Auto-generated method stub // 创建活动对象，奖品有1个奖品 RaffleActivity activity = new RaffleActivity(1); // 我们连续抽300次奖 for (int i = 0; i &lt; 30; i++) { System.out.println(\"--------第\" + (i + 1) + \"次抽奖----------\"); // 参加抽奖，第一步点击扣除积分 activity.debuctMoney(); // 第二步抽奖 activity.raffle(); } } } 22.5 状态模式在实际项目-借贷平台 源码分析 借贷平台的订单，有审核-发布-抢单等等步骤，随着操作的不同，会改变订单的状态，项目中的这个模块实现就会使用到状态模式 通常通过if/else 判断订单的状态，从而实现不同的逻辑，伪代码如下 使用状态模式完成 借贷平台项目的审核模块 /** * 状态接口 */ public interface State { /** * 电审 */ void checkEvent(Context context); /** * 电审失败 */ void checkFailEvent(Context context); /** * 定价发布 */ void makePriceEvent(Context context); /** * 接单 */ void acceptOrderEvent(Context context); /** * 无人接单失效 */ void notPeopleAcceptEvent(Context context); /** * 付款 */ void payOrderEvent(Context context); /** * 接单有人支付失效 */ void orderFailureEvent(Context context); /** * 反馈 */ void feedBackEvent(Context context); String getCurrentState(); } public abstract class AbstractState implements State { protected static final RuntimeException EXCEPTION = new RuntimeException(\"操作流程不允许\"); //抽象类，默认实现了 State 接口的所有方法 //该类的所有方法，其子类(具体的状态类)，可以有选择的进行重写 @Override public void checkEvent(Context context) { throw EXCEPTION; } @Override public void checkFailEvent(Context context) { throw EXCEPTION; } @Override public void makePriceEvent(Context context) { throw EXCEPTION; } @Override public void acceptOrderEvent(Context context) { throw EXCEPTION; } @Override public void notPeopleAcceptEvent(Context context) { throw EXCEPTION; } @Override public void payOrderEvent(Context context) { throw EXCEPTION; } @Override public void orderFailureEvent(Context context) { throw EXCEPTION; } @Override public void feedBackEvent(Context context) { throw EXCEPTION; } } //各种具体状态类 class FeedBackState extends AbstractState { @Override public String getCurrentState() { return StateEnum.FEED_BACKED.getValue(); } } class GenerateState extends AbstractState { @Override public void checkEvent(Context context) { context.setState(new ReviewState()); } @Override public void checkFailEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.GENERATE.getValue(); } } class NotPayState extends AbstractState { @Override public void payOrderEvent(Context context) { context.setState(new PaidState()); } @Override public void feedBackEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.NOT_PAY.getValue(); } } class PaidState extends AbstractState { @Override public void feedBackEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.PAID.getValue(); } } class PublishState extends AbstractState { @Override public void acceptOrderEvent(Context context) { //把当前状态设置为 NotPayState。。。 //至于应该变成哪个状态，有流程图来决定 context.setState(new NotPayState()); } @Override public void notPeopleAcceptEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.PUBLISHED.getValue(); } } class ReviewState extends AbstractState { @Override public void makePriceEvent(Context context) { context.setState(new PublishState()); } @Override public String getCurrentState() { return StateEnum.REVIEWED.getValue(); } } //环境上下文 public class Context extends AbstractState{ //当前的状态 state, 根据我们的业务流程处理，不停的变化 private State state; @Override public void checkEvent(Context context) { state.checkEvent(this); getCurrentState(); } @Override public void checkFailEvent(Context context) { state.checkFailEvent(this); getCurrentState(); } @Override public void makePriceEvent(Context context) { state.makePriceEvent(this); getCurrentState(); } @Override public void acceptOrderEvent(Context context) { state.acceptOrderEvent(this); getCurrentState(); } @Override public void notPeopleAcceptEvent(Context context) { state.notPeopleAcceptEvent(this); getCurrentState(); } @Override public void payOrderEvent(Context context) { state.payOrderEvent(this); getCurrentState(); } @Override public void orderFailureEvent(Context context) { state.orderFailureEvent(this); getCurrentState(); } @Override public void feedBackEvent(Context context) { state.feedBackEvent(this); getCurrentState(); } public State getState() { return state; } public void setState(State state) { this.state = state; } @Override public String getCurrentState() { System.out.println(\"当前状态 : \" + state.getCurrentState()); return state.getCurrentState(); } } /** * 状态枚举类 * @author Administrator * */ public enum StateEnum { //订单生成 GENERATE(1, \"GENERATE\"), //已审核 REVIEWED(2, \"REVIEWED\"), //已发布 PUBLISHED(3, \"PUBLISHED\"), //待付款 NOT_PAY(4, \"NOT_PAY\"), //已付款 PAID(5, \"PAID\"), //已完结 FEED_BACKED(6, \"FEED_BACKED\"); private int key; private String value; StateEnum(int key, String value) { this.key = key; this.value = value; } public int getKey() {return key;} public String getValue() {return value;} } /**测试类*/ public class ClientTest { public static void main(String[] args) { // TODO Auto-generated method stub //创建context 对象 Context context = new Context(); //将当前状态设置为 PublishState context.setState(new PublishState()); System.out.println(context.getCurrentState()); // //publish --&gt; not pay context.acceptOrderEvent(context); // //not pay --&gt; paid // context.payOrderEvent(context); // // 失败, 检测失败时，会抛出异常 // try { // context.checkFailEvent(context); // System.out.println(\"流程正常..\"); // } catch (Exception e) { // // TODO: handle exception // System.out.println(e.getMessage()); // } } } 22.6 状态模式的注意事项和细节 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中 方便维护。将容易产生问题的if-else语句删除，如果把每个状态的行为都放到一个类中，每次调用方法的时候都要判断当前是什么状态，不但会产生很多if-else语句，而且容易出错 符合“开闭原则”。容易增删状态 会产生很多类。每个状态都要一个对应的类，当状态过多时候会产生很多类，加大维护难度 应用场景：当一个时间或者对象有很多状态时候，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式。 二十三、策略模式23.1 传统方案 传统方案解决鸭子问题的分析和代码实现 代码实现 public abstract class Duck { public Duck() { } public abstract void display();//显示鸭子信息 public void quack() { System.out.println(\"鸭子嘎嘎叫~~\"); } public void swim() { System.out.println(\"鸭子会游泳~~\"); } public void fly() { System.out.println(\"鸭子会飞翔~~~\"); } } public class PekingDuck extends Duck { @Override public void display() { // TODO Auto-generated method stub System.out.println(\"~~北京鸭~~~\"); } //因为北京鸭不能飞翔，因此需要重写fly @Override public void fly() { // TODO Auto-generated method stub System.out.println(\"北京鸭不能飞翔\"); } } public class ToyDuck extends Duck{ @Override public void display() { // TODO Auto-generated method stub System.out.println(\"玩具鸭\"); } //需要重写父类的所有方法 @Override public void quack() { System.out.println(\"玩具鸭不能叫~~\"); } @Override public void swim() { System.out.println(\"玩具鸭不会游泳~~\"); } @Override public void fly() { System.out.println(\"玩具鸭不会飞翔~~~\"); } } public class WildDuck extends Duck { @Override public void display() { // TODO Auto-generated method stub System.out.println(\" 这是野鸭 \"); } } public class Client { public static void main(String[] args) { Duck pekingDuck = new PekingDuck(); pekingDuck.display(); pekingDuck.fly(); pekingDuck.swim(); pekingDuck.quack(); Duck toyDuck = new ToyDuck(); toyDuck.display(); toyDuck.quack(); toyDuck.fly(); toyDuck.swim(); WildDuck wildDuck = new WildDuck(); wildDuck.display(); wildDuck.quack(); wildDuck.fly(); wildDuck.swim(); } } 23.2 传统的方式实现的问题分析和解决方案 其他鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的 上面说的1的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应 为了改进1问题，我们可以通过覆盖fly方法来解决=&gt;覆盖解决 问题又来了，如果我们有一个玩具鸭子ToyDuck，这样就需要ToyDuck去覆盖Duck的所有实现方法=&gt;解决思路=&gt;策略模式 23.3 策略模式基本介绍 策略模式中，定义算法族（策略组），分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类(定义了策略接口)；第三、多用组合/聚合，少用继承(客户通过组合方式使用策略)。 策略模式的原理类图 说明：从上图可以看到，客户context有成员变量strategy或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定 23.4 策略模式解决鸭子问题 应用实例要求 ​ 编写程序完成前面的鸭子项目，要求使用策略模式 思路分析(类图) ​ 策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者 代码实现 public interface FlyBehavior { void fly(); // 子类具体实现 } public class GoodFlyBehavior implements FlyBehavior { @Override public void fly() { // TODO Auto-generated method stub System.out.println(\" 飞翔技术高超 ~~~\"); } } public class BadFlyBehavior implements FlyBehavior { @Override public void fly() { // TODO Auto-generated method stub System.out.println(\" 飞翔技术一般 \"); } } public class NoFlyBehavior implements FlyBehavior{ @Override public void fly() { // TODO Auto-generated method stub System.out.println(\" 不会飞翔 \"); } } public abstract class Duck { //属性, 策略接口 FlyBehavior flyBehavior; //其它属性&lt;-&gt;策略接口 QuackBehavior quackBehavior; public Duck() { } public abstract void display();//显示鸭子信息 public void quack() { System.out.println(\"鸭子嘎嘎叫~~\"); } public void swim() { System.out.println(\"鸭子会游泳~~\"); } public void fly() { //改进 if(flyBehavior != null) { flyBehavior.fly(); } } public void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } } public class WildDuck extends Duck { //构造器，传入FlyBehavor 的对象 public WildDuck() { // TODO Auto-generated constructor stub flyBehavior = new GoodFlyBehavior(); } @Override public void display() { // TODO Auto-generated method stub System.out.println(\" 这是野鸭 \"); } } public class PekingDuck extends Duck { //假如北京鸭可以飞翔，但是飞翔技术一般 public PekingDuck() { // TODO Auto-generated constructor stub flyBehavior = new BadFlyBehavior(); } @Override public void display() { // TODO Auto-generated method stub System.out.println(\"~~北京鸭~~~\"); } } public class ToyDuck extends Duck{ public ToyDuck() { // TODO Auto-generated constructor stub flyBehavior = new NoFlyBehavior(); } @Override public void display() { // TODO Auto-generated method stub System.out.println(\"玩具鸭\"); } //需要重写父类的所有方法 @Override public void quack() { System.out.println(\"玩具鸭不能叫~~\"); } @Override public void swim() { System.out.println(\"玩具鸭不会游泳~~\"); } } public interface QuackBehavior { void quack();//子类实现 } public class Client { public static void main(String[] args) { WildDuck wildDuck = new WildDuck(); wildDuck.fly();// ToyDuck toyDuck = new ToyDuck(); toyDuck.fly(); PekingDuck pekingDuck = new PekingDuck(); pekingDuck.fly(); //动态改变某个对象的行为, 北京鸭 不能飞 pekingDuck.setFlyBehavior(new NoFlyBehavior()); System.out.println(\"北京鸭的实际飞翔能力\"); pekingDuck.fly(); } } 23.5 策略模式在JDK-Arrays应用的源码分析 代码 import java.util.Arrays; import java.util.Comparator; public class Strategy { public static void main(String[] args) { // TODO Auto-generated method stub //数组 Integer[] data = { 9, 1, 2, 8, 4, 3 }; // 实现降序排序，返回-1放左边，1放右边，0保持不变 // 说明 // 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;(){..} // 2. 对象 new Comparator&lt;Integer&gt;(){..} 就是实现了 策略接口 的对象 // 3. public int compare(Integer o1, Integer o2){} 指定具体的处理方式 Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() { public int compare(Integer o1, Integer o2) { if (o1 &gt; o2) { return -1; } else { return 1; } }; }; // 说明 /* * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) { if (c == null) { sort(a); //默认方法 } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); //使用策略对象c else // 使用策略对象c TimSort.sort(a, 0, a.length, c, null, 0, 0); } } */ //方式1 Arrays.sort(data, comparator); System.out.println(Arrays.toString(data)); // 降序排序 //方式2- 同时lambda 表达式实现 策略模式 Integer[] data2 = { 19, 11, 12, 18, 14, 13 }; Arrays.sort(data2, (var1, var2) -&gt; { if(var1.compareTo(var2) &gt; 0) { return -1; } else { return 1; } }); System.out.println(\"data2=\" + Arrays.toString(data2)); } } 23.6 策略模式的注意事项和细节 策略模式的关键是：分析项目中变化部分与不变部分 策略模式的核心思想是：多用组合/聚合 少用继承：用行为类组合，而不是行为的继承。更有弹性 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句(if..else if..else) 提供了可以替换继承关系的方法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大 二十四、职责链模式24.1 传统方案 传统方案类图 传统方案解决OA系统审批解决问题分析 传统方式是：接收到一个采购请求后，根据采购金额来调用对应的Approver(审批人)完成审批。 传统方式的问题分析：客户端这里会使用到分支判断(比如switch)来对不同的采购请求处理，这样就存在如下问题(1)如果各个级别的人员审批金额发生变化，在客户端的也需要变化(2)客户端必须明确的知道 有多少个审批级别和访问 这样 对一个采购请求进行处理和Approver(审批人)就存在强耦合关系，不利于代码的扩展和维护 解决方案=&gt; 职责链模式 24.2 职责链模式基本极少 职责链模式，又叫做责任链模式，为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，以此类推 这种类型的设计模式属于行为型模式 24.3 职责链模式的原理类图 对原理类图的说明(职责链模式的角色以及职责) Handler：抽象的处理者，定义了一个处理请求的接口，同时含义另外Handler ConcreteHandlerA，B是具体的处理者，处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，如果可以处理当前请求，则处理，否则将该请求交个后继者去处理，从而形成一个职责链 Request，含义很多属性，表示一哥请求 24.4 职责链模式解决OA系统采购审批 应用实例要求 思路分析和图解(类图) 代码实现 //请求类 public class PurchaseRequest { private int type = 0; //请求类型 private float price = 0.0f; //请求金额 private int id = 0; //构造器 public PurchaseRequest(int type, float price, int id) { this.type = type; this.price = price; this.id = id; } public int getType() { return type; } public float getPrice() { return price; } public int getId() { return id; } } public abstract class Approver { Approver approver; //下一个处理者 String name; // 名字 public Approver(String name) { // TODO Auto-generated constructor stub this.name = name; } //下一个处理者 public void setApprover(Approver approver) { this.approver = approver; } //处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象 public abstract void processRequest(PurchaseRequest purchaseRequest); } public class DepartmentApprover extends Approver { public DepartmentApprover(String name) { // TODO Auto-generated constructor stub super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { // TODO Auto-generated method stub if(purchaseRequest.getPrice() &lt;= 5000) { System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); }else { approver.processRequest(purchaseRequest); } } } public class CollegeApprover extends Approver { public CollegeApprover(String name) { // TODO Auto-generated constructor stub super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { // TODO Auto-generated method stub if(purchaseRequest.getPrice() &gt; 5000 &amp;&amp; purchaseRequest.getPrice() &lt;= 10000) { System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); }else { approver.processRequest(purchaseRequest); } } } public class ViceSchoolMasterApprover extends Approver { public ViceSchoolMasterApprover(String name) { // TODO Auto-generated constructor stub super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { // TODO Auto-generated method stub if(purchaseRequest.getPrice() &gt; 10000 &amp;&amp; purchaseRequest.getPrice() &lt;= 30000) { System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); }else { approver.processRequest(purchaseRequest); } } } public class SchoolMasterApprover extends Approver { public SchoolMasterApprover(String name) { // TODO Auto-generated constructor stub super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { // TODO Auto-generated method stub if(purchaseRequest.getPrice() &gt; 30000) { System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); }else { approver.processRequest(purchaseRequest); } } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //创建一个请求 PurchaseRequest purchaseRequest = new PurchaseRequest(1, 20000, 1); //创建相关的审批人 DepartmentApprover departmentApprover = new DepartmentApprover(\"张主任\"); CollegeApprover collegeApprover = new CollegeApprover(\"李院长\"); ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover(\"王副校\"); SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover(\"佟校长\"); //需要将各个审批级别的下一个设置好 (处理人构成环形: ) departmentApprover.setApprover(collegeApprover); collegeApprover.setApprover(viceSchoolMasterApprover); viceSchoolMasterApprover.setApprover(schoolMasterApprover); schoolMasterApprover.setApprover(departmentApprover); departmentApprover.processRequest(purchaseRequest); viceSchoolMasterApprover.processRequest(purchaseRequest); } } 24.5 职责链模式在SpringMVC框架应用的源码分析 源码和说明 import org.springframework.web.servlet.HandlerExecutionChain; import org.springframework.web.servlet.HandlerInterceptor; public class ResponsibilityChain { public static void main(String[] args) { // TODO Auto-generated method stub // DispatcherServlet //说明 /* * * protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { * HandlerExecutionChain mappedHandler = null; * mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象 * //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor * //调用了拦截器的 interceptor.preHandle * if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用 //拦截器的 interceptor.postHandle(request, response, this.handler, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); * } * * * //说明：在 mappedHandler.applyPreHandle内部中， * 还调用了 triggerAfterCompletion 方法，该方法中调用了 * HandlerInterceptor interceptor = getInterceptors()[i]; try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable ex2) { logger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2); } */ } } 对源码总结 springmvc 请求的流程图中，执行了拦截器相关方法iterceptor.preHanlder等等 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式 HandlerExecutionChain主要负责的是请求拦截器的执行和请求处理，但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程 HandlerExecutionChain维护了HandlerInterceptor的集合，可以向其中注册相应的拦截器 24.6 职责链模式的注意事项和细节 将请求和处理分开，实现解耦，提高系统的灵活性 简化了对象，使对象不需要知道链的结构 性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阈值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能。 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂 最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器","categories":[],"tags":[]},{"title":"shopFM","slug":"shopFM","date":"2022-02-14T14:48:55.000Z","updated":"2022-02-14T15:29:54.078Z","comments":true,"path":"posts/shopfm/","link":"","permalink":"https://dahammer666.github.io/posts/shopfm/","excerpt":"","text":"一、项目介绍1.1 项目功能https://www.processon.com/view/link/606bde8b1e08534321fd2103 1.2 单体项目 项目的页面和代码都在同一个项目，项目开发完成之后直接部署在一台服务器 单体项目遇到的问题：用户对页面静态资源以及对Java代码的访问压力都会落在Tomcat服务器上。 1.2.1 技术清单 项目架构：前后端分离 前端技术：vue、axios、妹子UI、layui、bootstrap 后端技术：SpringBoot+MyBatis、RESTful、swagger 服务器搭建：Linux、Nginx 二、项目架构的演进2.1 单体架构 前后端都部署在同一台服务器上（前后端代码都在同一个应用中） 缺点：对静态资源的访问压力也会落在Tomcat上 2.2 前后端分离 前后端分离：前端和后端分离开发和部署（前后端部署在不同的服务器） 优点：将对静态资源的访问和对接口的访问进行分离，Tomcat服务器只负责数据服务的访问 2.3 集群与负载均衡 优点：提供并发能力、可用性 2.4 分布式 基于redis实现 分布式锁 分布式数据库mycat redis集群 数据库中间件 消息中间件 2.5 微服务架构 微服务架构：将原来在一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性、性能 三、项目搭建 基于Maven的聚合工程完成项目搭建，前端采用vue+axios，后端使用SpringBoot整合SSM 3.1 技术储备 （√）SpringBoot： 实现无配置的SSM整合 （√）Maven聚合工程：实现模块的复用 3.2 创建Maven聚合工程 3.2.1 构建父工程fmmall 创建一个maven工程、packing设置为 pom 父工程继承继承spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; 3.2.2 创建common工程 选择fmmall，右键—New—Module （Maven工程） 修改common的pom.xml，设置packing=jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; 3.2.3 创建beans工程 选择fmmall，右键—New—Module （Maven工程） 修改beans的pom.xml，设置packing —– jar 3.2.4 创建mapper工程 选择fmmall，右键—New—Module （Maven工程） 修改mapper的pom.xml，设置packing —– jar 在mapper的pom.xml，依赖beans &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;beans&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.5 创建service工程 选择fmmall，右键—New—Module （Maven工程） 修改service的pom.xml，设置packing —– jar 在service的pom.xml，依赖mapper、commom &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 3.2.6 创建api工程 选择fmmall，右键—New—Module （SpringBoot工程） 修改api的pom.xml，继承fmmall，删除自己的groupId 和 version &lt;parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/parent&gt; 将spring boot的依赖配置到父工程fmmall的pom.xml 在父工程fmmall的pom.xml的modules添加api &lt;!--fmmall pom.xml--&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;fmmall&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;beans&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在api中，依赖service &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; api的pom.xml继承fmmall 3.3 Maven聚合工程依赖分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程中都会继承父工程的依赖： 好处：当有多个子工程都需要相同的依赖时，无需在子工程中重复添加依赖 缺点：如果某些子工程不需要这个依赖，还是会被强行继承 如果在父工程中没有添加统一依赖，则每个子工程所需的依赖需要在子工程的pom中自行添加 如果存在多个子工程需要添加相同的依赖，则需在父工程pom进行依赖版本的管理 依赖配置说明 在父工程的pom文件中一次性添加各个子工程所需的所有依赖 在各个子工程中单独添加当前子工程的依赖 3.4 整合MyBatis3.4.1 common子工程 lombok 3.4.2 beans子工程 lombok 3.4.3 MyBatis整合 在mapper子工程的pom文件，新增mybatis所需的依赖 &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 在mapper子工程的resources目录创建application.yml spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 在api子工程的启动类通过@MpperScan声明dao包的路径 @SpringBootApplication @MapperScan(\"com.qfedu.fmmall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 3.5 基于SpringBoot的单元测试3.5.1 添加依赖&lt;!--test starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5.2 测试类@RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDAOTest { @Resource private UserDAO userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 3.6 整合Druid3.6.1 添加依赖 在mapper子工程添加druid-starter &lt;!--druid starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; 3.6.2 修改数据源配置 修改mapper子工程application.yml文件 spring: datasource: druid: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_2010_mybatis?characterEncoding=utf-8 username: root password: admin123 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.qfedu.fmmall.entity 四、数据库设计 4.1 软件开发步骤 问题定义/提出问题 可行性分析（技术、成本、法律法规） 需求分析（需求采集、需求分析）—-&gt;甲方 概要设计 架构设计（技术选型、架构模式、项目搭建） 数据库设计 UI设计 业务流程设计 详细设计 实现步骤（业务流程的实现细节） 编码 根据设计好的实现步骤进行代码实现 开发过程中开发者要进行单元测试 测试 集成测试 功能测试（黑盒） 性能测试（白盒） 交付/部署实施 4.2 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征） 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 4.3 数据库设计分析4.3.1 PDMan建模工具使用 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（模型–导出DDL脚本） 记录数据设计的版本-数据库模型版本的管理（模型版本） 同步数据模型到数据库（开始-数据库连接） 4.3.2 分析《锋迷商城》的数据库模型 用户 首页 商品 购物车 订单 和 订单项 评论 4.4 SPU 和 SKU4.4.1 SPU SPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。 1 荣耀8 2 小米10 4.4.2 SKU SKU（中文译为最小存货单位，英文全称为Stock Keeping Unit,简称SKU，定义为保存库存控制的最小可用单位) 101 8G / 128G 10 1800 1 102 4G / 128G 20 1500 1 103 8G / 128G 12 2999 2 104 12G / 256G 11 3999 2 4.5 建库建表4.5.1 创建数据表 从PDMan导出sql，导入到mysql 4.5.2 准备测试数据 首页轮播图 index_img 首页类别信息 category 商品信息 sku 五、业务流程设计-接口规范 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组就会按照项目中的功能进行开发任务的分配 5.1 前后端分离与单体架构流程实现的区别 单体架构：页面和控制之间可以进行跳转，同步请求控制器，流程控制由的控制来完成 前后端分离架构：前端和后端分离开发和部署，前端只能通过异步向后端发送请求，后端只负责接收请求及参数、处理请求、返回处理结果，但是后端并不负责流程控制，流程控制是由前端完成 5.1.1 单体架构 5.1.2 前后端分离架构 5.2 接口介绍5.2.1 接口概念 狭义的理解：就是控制器中可以接受用户请求的某个方法 应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 5.2.2 接口规范 作为一个后端开发者，我们不仅要完成接口程序的开发，还要编写接口的说明文档——接口规范 接口规范示例： 参考：《锋迷商城》后端接口说明 5.3 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间 swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 5.3.1 作用 生成接口说明文档 对接口进行测试 5.3.2 Swagger整合 在api子工程添加依赖（Swagger2 \\ Swagger UI） &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 在api子工程创建swagger的配置（Java配置方式） @Configuration @EnableSwagger2 public class SwaggerConfig { /*swagger会帮助我们生成接口文档 * 1：配置生成的文档信息 * 2: 配置生成规则*/ /*Docket封装接口文档信息*/ @Bean public Docket getDocket(){ //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(\"《锋迷商城》后端接口说明\") .description(\"此文档详细说明了锋迷商城项目后端接口规范....\") .version(\"v 2.0.1\") .contact( new Contact(\"亮哥\",\"www.liangge.com\",\"liangge@wang.com\") ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.qfedu.fmmall.controller\")) .paths(PathSelectors.any()) .build(); return docket; } } 测试： 启动SpringBoot应用，访问：http://localhost:8080/swagger-ui.html 5.3.3 Swagger注解说明 swagger提供了一套注解，可以对每个接口进行详细说明 @Api 类注解，在控制器类添加此注解，可以对控制器类进行功能说明 @Api(value = \"提供商品添加、修改、删除及查询的相关接口\",tags = \"商品管理\") @ApiOperation方法注解：说明接口方法的作用 @ApiImplicitParams和@ApiImplicitParam 方法注解，说名接口方法的参数 @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) @RequestMapping(value = \"/login\",method = RequestMethod.GET) public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } @ApiModel和@ApiModelProperty 当接口参数和返回值为对象类型时，在实体类中添加注解说明 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { @ApiModelProperty(dataType = \"int\",required = false) private int userId; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册账号\") private String userName; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户注册密码\") private String userPwd; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户真实姓名\") private String userRealname; @ApiModelProperty(dataType = \"String\",required = true, value = \"用户头像url\") private String userImg; } @ApiIgnore接口方法注解，添加此注解的方法将不会生成到接口文档中 5.3.4 Swagger-ui 插件 导入插件的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 文档访问 http://ip:port/doc.html 5.4 RESTful 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful 是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete?goodsId=1 商品1 http://localhost:8080/goods/delete?goodsId=2 商品2 RESTful设计： http://localhost:8080/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 使用不同的请求方式表示不同的操作 SpringMVC对RESTful风格提供了很好的支持，在我们定义一个接口的URL时，可以通过@RequestMapping(value=\"/{id}\",method=RequestMethod.GET)形式指定请求方式，也可使用特定请求方式的注解设定URL @PostMapping(\"/add\") @DeleteMapping(\"/{id}\") @PutMapping(\"/{id}\") @GetMapping(\"/{id}\") post 添加 get 查询 put 修改 delete 删除 option (预检) 根据ID删除一个商品： //http://localhost:8080/goods/1 [delete] @RequestMapping(value = \"/{id}\",method = RequestMethod.DELETE) public ResultVO deleteGoods(@PathVariable(\"id\") int goodsId){ System.out.println(\"-----\"+goodsId); return new ResultVO(10000,\"delete success\",null); } 根据ID查询一个商品： //http://localhost:8080/goods/1 [get] @RequestMapping(value = \"/{id}\",method = RequestMethod.GET) public ResultVO getGoods(@PathVariable(\"id\") int goodsId){ return null; } 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody注解将返回的对象格式为json 或者直接在控制器类使用@RestController注解声明控制器 前端(Android\\ios\\pc)通过无状态的HTTP协议与后端接口进行交互 六、设计及实现—用户管理 6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 八、首页—轮播图8.1 实现流程分析 流程图 接口 查询轮播图信息返回 8.2 完成后台接口开发8.2.1 数据库操作实现 分析数据表结构 添加测试数据 编写sql语句 select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq 在Mapper接口（DAO）中定义操作方法 public interface IndexImgMapper extends GeneralDAO&lt;IndexImg&gt; { //1.查询轮播图信息： 查询status=1 且 按照seq进行排序 public List&lt;IndexImg&gt; listIndexImgs(); } 配置映射文件 &lt;!--BaseResultMap是由逆向工程生成的--&gt; &lt;select id=\"listIndexImgs\" resultMap=\"BaseResultMap\"&gt; select img_id, img_url, img_bg_color, prod_id, category_id, index_type, seq, status, create_time, update_time from index_img where status=1 order by seq &lt;/select&gt; 8.2.2 业务层实现 IndexImgService接口 public interface IndexImgService { public ResultVO listIndexImgs(); } IndexImgServiceImpl实现类 @Service public class IndexImgServiceImpl implements IndexImgService { @Autowired private IndexImgMapper indexImgMapper; public ResultVO listIndexImgs() { List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size()==0){ return new ResultVO(ResStatus.NO,\"fail\",null); }else{ return new ResultVO(ResStatus.OK,\"success\",indexImgs); } } } 8.2.3 控制层实现 IndexController类 @RestController @CrossOrigin @RequestMapping(\"/index\") @Api(value = \"提供首页数据显示所需的接口\",tags = \"首页管理\") public class IndexController { @Autowired private IndexImgService indexImgService; @GetMapping(\"/indeximg\") @ApiOperation(\"首页轮播图接口\") public ResultVO listIndexImgs(){ return indexImgService.listIndexImgs(); } } 8.3 完成前端功能 当进入到index.html，在进行页面初始化之后，就需要请求轮播图数据进行轮播图的显示 index.html 九、首页-分类列表9.1 实现流程分析 方案一：一次性查询三级分类 优点：只需要一次查询，根据一级分类显示二级分类时响应速度较快 缺点：数据库查询效率较低，页面首次加载的速度也相对较慢 方案二：先只查询一级分类，用户点击/鼠标移动到一级分类，动态加载二级分类 优点：数据库查询效率提高，页面首次加载速度提高 缺点：需要多次连接数据库 9.2 接口开发9.2.1 数据库操作实现 数据表结构 添加测试数据 编写接口实现所需的SQL 连接查询 select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 子查询 -- 根据父级分类的id查询类别信息 select * from category where parent_id=3; 创建用于封装查询的类别信息的CategoryVO 在beans子工程的entity包新建一个CategoryVO用于封装查询到类别信息，相对于Category来说，新增了如下属性： public class CategoryVO { //用于存放当前分类的子分类 private List&lt;CategoryVO&gt; categories; public List&lt;CategoryVO&gt; getCategories() { return categories; } } 在CategoryMapper定义操作方法 @Repository public interface CategoryMapper extends GeneralDAO&lt;Category&gt; { //1.连接查询 public List&lt;CategoryVO&gt; selectAllCategories(); //2.子查询：根据parentId查询子分类 public List&lt;CategoryVO&gt; selectAllCategories2(int parentId); } 映射配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.CategoryMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.Category\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"categoryVOMap\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id1\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name1\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level1\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id1\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon1\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan1\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic1\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color1\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id2\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name2\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level2\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id2\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;collection property=\"categories\" ofType=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id3\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name3\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level3\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id3\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllCategories\" resultMap=\"categoryVOMap\"&gt; select c1.category_id 'category_id1', c1.category_name 'category_name1', c1.category_level 'category_level1', c1.parent_id 'parent_id1', c1.category_icon 'category_icon1', c1.category_slogan 'category_slogan1', c1.category_pic 'category_pic1', c1.category_bg_color 'category_bg_color1', c2.category_id 'category_id2', c2.category_name 'category_name2', c2.category_level 'category_level2', c2.parent_id 'parent_id2', c3.category_id 'category_id3', c3.category_name 'category_name3', c3.category_level 'category_level3', c3.parent_id 'parent_id3' from category c1 inner join category c2 on c2.parent_id=c1.category_id left join category c3 on c3.parent_id=c2.category_id where c1.category_level=1 &lt;/select&gt; &lt;!----------------------------------------------------------------------------&gt; &lt;resultMap id=\"categoryVOMap2\" type=\"com.qfedu.fmmall.entity.CategoryVO\"&gt; &lt;id column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"category_name\" jdbcType=\"VARCHAR\" property=\"categoryName\" /&gt; &lt;result column=\"category_level\" jdbcType=\"INTEGER\" property=\"categoryLevel\" /&gt; &lt;result column=\"parent_id\" jdbcType=\"INTEGER\" property=\"parentId\" /&gt; &lt;result column=\"category_icon\" jdbcType=\"VARCHAR\" property=\"categoryIcon\" /&gt; &lt;result column=\"category_slogan\" jdbcType=\"VARCHAR\" property=\"categorySlogan\" /&gt; &lt;result column=\"category_pic\" jdbcType=\"VARCHAR\" property=\"categoryPic\" /&gt; &lt;result column=\"category_bg_color\" jdbcType=\"VARCHAR\" property=\"categoryBgColor\" /&gt; &lt;collection property=\"categories\" column=\"category_id\" select=\"com.qfedu.fmmall.dao.CategoryMapper.selectAllCategories2\"/&gt; &lt;/resultMap&gt; &lt;!-- 根据父级分类的id查询子级分类 --&gt; &lt;select id=\"selectAllCategories2\" resultMap=\"categoryVOMap2\"&gt; select category_id, category_name, category_level, parent_id, category_icon, category_slogan, category_pic, category_bg_color from category where parent_id=#{parentId} &lt;/select&gt; &lt;/mapper&gt; 9.2.2 业务层实现 CategoryService接口 public interface CategoryService { public ResultVO listCategories(); } CategoryServiceImpl @Service public class CategoryServiceImpl implements CategoryService { @Autowired private CategoryMapper categoryMapper; public ResultVO listCategories() { List&lt;CategoryVO&gt; categoryVOS = categoryMapper.selectAllCategories(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", categoryVOS); return resultVO; } } 9.2.3 控制层实现 IndexController @Autowired private CategoryService categoryService; @GetMapping(\"/category-list\") @ApiOperation(\"商品分类查询接口\") public ResultVO listCatetory(){ return categoryService.listCategories(); } 9.3 前端功能实现十、首页-商品推荐10.1 流程分析 10.2 接口开发10.2.1 数据库实现 商品推荐算法：推荐最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算，计算出一个匹配值 数据表分析及数据准备 sql -- 商品推荐：查询最新上架的商品 select * from product order by create_time desc limit 0,3; -- 子查询：根据商品id查询商品图片 select * from product_img where item_id=2; 在beans子工程entity包创建ProductVO,相比较Product新增了List imgs用于存储商品的图片 public class ProductVO{ private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() { return imgs; } public void setImgs(List&lt;ProductImg&gt; imgs) { this.imgs = imgs; } } Mapper接口定义操作方法： ProductMapper public interface ProductMapper extends GeneralDAO&lt;Product&gt; { public List&lt;ProductVO&gt; selectRecommendProducts(); } ProductImgMapper public interface ProductImgMapper extends GeneralDAO&lt;ProductImg&gt; { //根据商品id查询当前商品的图片信息 public List&lt;ProductImg&gt; selectProductImgByProductId(int productId); } 配置映射文件 ProductMapper.xml &lt;resultMap id=\"ProductVOMap\" type=\"com.qfedu.fmmall.entity.ProductVO\"&gt; &lt;id column=\"product_id\" jdbcType=\"VARCHAR\" property=\"productId\" /&gt; &lt;result column=\"product_name\" jdbcType=\"VARCHAR\" property=\"productName\" /&gt; &lt;result column=\"category_id\" jdbcType=\"INTEGER\" property=\"categoryId\" /&gt; &lt;result column=\"root_category_id\" jdbcType=\"INTEGER\" property=\"rootCategoryId\" /&gt; &lt;result column=\"sold_num\" jdbcType=\"INTEGER\" property=\"soldNum\" /&gt; &lt;result column=\"product_status\" jdbcType=\"INTEGER\" property=\"productStatus\" /&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\" /&gt; &lt;result column=\"update_time\" jdbcType=\"TIMESTAMP\" property=\"updateTime\" /&gt; &lt;result column=\"content\" jdbcType=\"LONGVARCHAR\" property=\"content\" /&gt; &lt;collection property=\"imgs\" select=\"com.qfedu.fmmall.dao.ProductImgMapper.selectProductImgByProductId\" column=\"product_id\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectRecommendProducts\" resultMap=\"ProductVOMap\"&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product order by create_time desc limit 0,3 &lt;/select&gt; ProductImgMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.ProductImgMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.qfedu.fmmall.entity.ProductImg\"&gt; &lt;id column=\"id\" jdbcType=\"VARCHAR\" property=\"id\" /&gt; &lt;result column=\"item_id\" jdbcType=\"VARCHAR\" property=\"itemId\" /&gt; &lt;result column=\"url\" jdbcType=\"VARCHAR\" property=\"url\" /&gt; &lt;result column=\"sort\" jdbcType=\"INTEGER\" property=\"sort\" /&gt; &lt;result column=\"is_main\" jdbcType=\"INTEGER\" property=\"isMain\" /&gt; &lt;result column=\"created_time\" jdbcType=\"TIMESTAMP\" property=\"createdTime\" /&gt; &lt;result column=\"updated_time\" jdbcType=\"TIMESTAMP\" property=\"updatedTime\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectProductImgByProductId\" resultMap=\"BaseResultMap\"&gt; select id, item_id, url, sort, is_main, created_time, updated_time from product_img where item_id=#{productId} &lt;/select&gt; &lt;/mapper&gt; 10.2.2 业务层实现 ProductService接口 public interface ProductService { public ResultVO listRecommendProducts(); } ProductServiceImpl实现类 @Service public class ProductServiceImpl implements ProductService { @Autowired private ProductMapper productMapper; public ResultVO listRecommendProducts() { List&lt;ProductVO&gt; productVOS = productMapper.selectRecommendProducts(); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productVOS); return resultVO; } } 10.2.3 控制层实现 IndexController @Autowired private ProductService productService; @GetMapping(\"/list-recommends\") @ApiOperation(\"查询推荐商品接口\") public ResultVO listRecommendProducts() { return productService.listRecommendProducts(); } 10.3 前端实现十一、首页-分类商品推荐 按照商品的分类（一级分类）推荐销量最高的6个商品 11.1 流程分析 加载分类商品推荐有两种实现方案： 方案一：当加载首页面时不加载分类的推荐商品，监听进度条滚动事件，当进度条触底（滚动指定的距离）就触发分类推荐商品的加载，每次只加载一个分类的商品。 方案二：一次性加载所有分类的推荐商品，整体进行初始化。 11.2 接口实现11.2.1 数据库实现 数据准备 -- 添加商品 -- 添加十个分类下的商品： insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('5','商品5',10,1,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('6','商品6',10,1,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('7','商品7',10,1,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('8','商品8',10,1,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('9','商品9',10,1,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('10','商品10',10,1,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('11','商品11',10,1,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('12','商品12',46,2,122,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('13','商品13',46,2,123,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('14','商品14',46,2,124,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('15','商品15',46,2,125,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('16','商品16',46,2,126,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('17','商品17',46,2,127,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product(product_id,product_name,category_id,root_category_id,sold_num,product_status,content,create_time,updated_time) values('18','商品18',46,2,128,1,'商品说明','2021-04-26 11:11:11','2021-04-26 11:11:11'); -- 添加商品图片 insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('9','5','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('10','6','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('11','7','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('12','8','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('13','9','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('14','10','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('15','11','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('16','12','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('17','13','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('18','14','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('19','15','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('20','16','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('21','17','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); insert into product_img(id,item_id,url,sort,is_main,created_time,updated_time) values('22','18','wwxb_1.png',1,1,'2021-04-26 11:11:11','2021-04-26 11:11:11'); 查询SQL -- 查询所有的一级分类 select * from category where category_level=1; -- 查询每个分类下销量前6的商品 select * from product where root_category_id=2 order by sold_num desc limit 0,6; -- 查询每个商品的图片 select * from product_img where item_id = 1; 实体类： @Data @NoArgsConstructor @AllArgsConstructor @ToString public class CategoryVO { private Integer categoryId; private String categoryName; private Integer categoryLevel; private Integer parentId; private String categoryIcon; private String categorySlogan; private String categoryPic; private String categoryBgColor; //实现首页的类别显示 private List&lt;CategoryVO&gt; categories; //实现首页分类商品推荐 private List&lt;ProductVO&gt; products; } 在Mapper接口中定义查询方法 CategoryMapper ProductMapper 映射配置 ProductMapper.xml CategoryMapper.xml 11.2.2 业务层实现11.2.3 控制层实现11.3 前端实现十二、商品详情展示—显示商品基本信息 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 12.1 流程分析 12.2 商品基础信息-接口实现 商品基本信息、商品套餐、商品图片 SQL -- 根据id查询商品基本信息 select * from product where product_id=3; -- 根据商品id查询当前商品的图片（√） select * from product_img where item_id=3; -- 根据商品id查询当前商品的套餐 select * from product_sku where product_id=3; 因为上述的三个查询都是单表查询，可以通过tkmapper完成，无需在Mapper接口定义新的方法 业务层实现 ProductService接口 ProductServiceImpl类实现 控制层实现 ProductController类 12.3 商品基础信息-前端显示十三、商品详情展示—显示商品参数信息13.1 接口实现 根据商品id查询商品参数信息 数据库操作直接只用tkMapper的默认方法实现 业务层实现 控制层实现 13.2 前端显示商品参数13.3 前端显示商品细节前端页面间URL传值 utils.js function getUrlParam(key){ var url = decodeURI( window.location.toString() ); var arr = url.split(\"?\"); if(arr.length&gt;1){ var params = arr[1].split(\"&amp;\"); for(var i=0; i&lt;params.length; i++){ var param = params[i]; //\"pid=101\" if(param.split(\"=\")[0] == key ){ return param.split(\"=\")[1]; } } } return null; } a.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"b.html?pid=101&amp;pname=咪咪虾条\"&gt;跳转到B页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; b.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is Page B... &lt;hr/&gt; &lt;script type=\"text/javascript\" src=\"js/utils.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var pid = getUrlParam(\"pid\"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十四、商品详情展示—显示商品评论信息 14.1 接口实现14.1.1 数据库实现 数据表分析及数据准备 SQL -- 根据ID查询商品的评价信息，关联查询评价用户的信息 select u.username,u.nickname,u.user_img,c.* from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =3; 实体类封装ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO { private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; } 在Mapper接口定义查询方法 @Repository public interface ProductCommentsMapper extends GeneralDAO&lt;ProductComments&gt; { public List&lt;ProductCommentsVO&gt; selectCommontsByProductId(String productId); } 映射配置： 14.1.2 业务层实现 创建ProductCommontsService接口定义方法 public interface ProductCommontsService { public ResultVO listCommontsByProductId(String productId); } 创建实现类ProductCommontsServiceImpl实现查询操作 @Service public class ProductCommontsServiceImpl implements ProductCommontsService { @Autowired private ProductCommentsMapper productCommentsMapper; @Override public ResultVO listCommontsByProductId(String productId) { List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", productCommentsVOS); return resultVO; } } 14.1.3 控制层实现 ProductController @ApiOperation(\"商品评论信息查询接口\") @GetMapping(\"/detail-commonts/{pid}\") public ResultVO getProductCommonts(@PathVariable(\"pid\") String pid){ return productCommontsService.listCommontsByProductId(pid); } 14.2 前端评论内容显示十五、商品详情展示—商品评论分页及统计信息15.1 流程分析 15.2 接口开发15.2.1 改造商品评论列表接口 分页查询 定义PageHelper @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; { //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; } 改造数据库操作 ProductCommentsMapper 接口 ProductCommentsMapper.xml映射配置 改造业务逻辑层 ProductCommontsService接口 ProductCommontsServiceImpl 改造控制层 ProductController 15.2.2 评价统计接口实现 数据库实现 统计当前商品的总记录数 统计当前商品的好评/中评/差评 业务层实现: ProductCommontsServiceImpl @Override public ResultVO getCommentsCountByProductId(String productId) { //1.查询当前商品评价的总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"productId\",productId); int total = productCommentsMapper.selectCountByExample(example); //2.查询好评评价数 criteria.andEqualTo(\"commType\",1); int goodTotal = productCommentsMapper.selectCountByExample(example); //3.查询好评评价数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(\"productId\",productId); criteria1.andEqualTo(\"commType\",0); int midTotal = productCommentsMapper.selectCountByExample(example1); //4.查询好评评价数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example2.createCriteria(); criteria2.andEqualTo(\"productId\",productId); criteria2.andEqualTo(\"commType\",-1); int badTotal = productCommentsMapper.selectCountByExample(example2); //5.计算好评率 double percent = (Double.parseDouble(goodTotal+\"\") / Double.parseDouble(total+\"\") )*100; String percentValue = (percent+\"\").substring(0,(percent+\"\").lastIndexOf(\".\")+3); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"total\",total); map.put(\"goodTotal\",goodTotal); map.put(\"midTotal\",midTotal); map.put(\"badTotal\",badTotal); map.put(\"percent\",percentValue); ResultVO success = new ResultVO(ResStatus.OK, \"success\", map); return success; } 15.3 前端实现15.3.1 商品评论的分页 引用elementUI分页组件 &lt;!-- 引入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- vue的引入必须在elementUI组件库引入之前 --&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 引用分页组件 &lt;!--分页 --&gt; &lt;el-pagination background layout=\"prev, pager, next\" :current-page=\"pageNum\" :page-size=\"limit\" :total=\"count\" @current-change=\"pager\"&gt; &lt;/el-pagination&gt; 监听分页组件的页码改变事件（点击上一页、下一页、页码都会导致页码改变） 分页组件的事件函数默认传递当前页码参数 pager:function(currentPage){ this.pageNum = currentPage; //请求下一页数据 var url3 = baseUrl+\"product/detail-commonts/\"+this.productId; axios.get(url3,{ params:{ pageNum:this.pageNum, limit:this.limit } }).then((res)=&gt;{ //获取到评论分页数据 var pageHelper = res.data.data; //当前页的评论列表 this.productCommonts = pageHelper.list; //总页数 this.pageCount = pageHelper.pageCount; //总记录数 this.count = pageHelper.count; }); } 15.3.2 商品评价统计十六、购物车—添加购物车（登陆状态）16.1 流程分析 16.2 接口实现16.2.1 修改购物车数据表结构 shopping_cart 数据表修改完成之后，对此表重新进行逆向工程 16.2.2 数据库实现 单表添加操作，可以直接使用tkMapper完成 16.2.3 业务层实现 ShoppingCartService接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); } 实现类 16.3 前端实现16.3.1 记录选择的套餐属性 在vue的data中定义 chooseSkuProps 为sku的属性添加点击事件 在methods中定义事件函数changeProp 添加套餐切换的监听事件： 16.3.2 套餐属性选中效果 在套餐属性标签上添加name属性 在属性的点击事件函数实现选中效果 16.3.3 修改商品数量 在vue的data中定义num存储商品数量（默认值为1） 为+，-添加点击事件监听 定义点击事件函数 16.3.4 提交购物车 十七、购物车—添加购物车（未登录状态）17.1 流程分析 17.2 功能实现17.2.1 定义新的状态码 ResStatus 登录认证拦截器 17.2.2 在详情页面判断如果用户未登录，则跳转到登录页面 introduction.html 17.2.3 登录页面接收回跳信息 login.html 17.2.4 回到详情页时接收参数 introduction.html 17.2.5 使用layui添加购物车成功/失败进行提示 引入layui layui.com &lt;!-- 引入 layui.css --&gt; &lt;link rel=\"stylesheet\" href=\"//unpkg.com/layui@2.6.5/dist/css/layui.css\"&gt; &lt;!-- 引入 layui.js --&gt; &lt;script src=\"//unpkg.com/layui@2.6.5/dist/layui.js\"&gt; 声明弹窗组件 当添加购物车成功或者失败的时候，进行提示： 十八、购物车—购物车列表18.1 流程分析 18.2 接口实现18.2.1 数据库实现 SQL -- 根据用户ID查询当前用户的购物车信息 select c.*, p.product_name,i.url from shopping_cart c INNER JOIN product p INNER JOIN product_img i ON c.product_id = p.product_id and i.item_id=p.product_id where user_id=6 and i.is_main=1; 实体类 在Mapper接口定义查询方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); } 映射配置 18.2.2 业务层实现 Service接口 Service实现类 18.2.3 控制层实现18.3 前端实现18.3.1 显示购物车列表18.3.2 显示购物车中商品价格十九、购物车-修改购物车数量19.1 流程分析19.2 接口实现 在Mapper接口定义修改方法 @Repository public interface ShoppingCartMapper extends GeneralDAO&lt;ShoppingCart&gt; { public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); public int updateCartnumByCartid(@Param(\"cartId\") int cartId, @Param(\"cartNum\") int cartNum); } 映射配置 &lt;update id=\"updateCartnumByCartid\"&gt; update shopping_cart set cart_num=#{cartNum} where cart_id=#{cartId} &lt;/update&gt; Service接口 public interface ShoppingCartService { public ResultVO addShoppingCart(ShoppingCart cart); public ResultVO listShoppingCartsByUserId(int userId); public ResultVO updateCartNum(int cartId,int cartNum); } Service实现类 @Service public class ShoppingCartServiceImpl implements ShoppingCartService { @Autowired private ShoppingCartMapper shoppingCartMapper; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); @Override public ResultVO updateCartNum(int cartId, int cartNum) { int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0){ return new ResultVO(ResStatus.OK,\"update success\",null); }else{ return new ResultVO(ResStatus.NO,\"update fail\",null); } } } 控制层实现 @PutMapping(\"/update/{cid}/{cnum}\") public ResultVO updateNum(@PathVariable(\"cid\") Integer cartId, @PathVariable(\"cnum\") Integer cartNum, @RequestHeader(\"token\") String token){ ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; } 19.3 前端实现 为按钮添加点击事件 定义changeNum事件函数 二十、购物车—结算、提交订单 在购物车列表中选择对应的的商品之后，点击提交生成订单的过程 20.1 流程图 20.2 接口实现20.2.1 收货地址列表接口 此操作的数据库实现可以通过tkmapper通用方法完成 service接口UserAddrService public interface UserAddrService { public ResultVO listAddrsByUid(int userId); } Service实现类 UserAddrServiceImpl @Service public class UserAddrServiceImpl implements UserAddrService { @Autowired private UserAddrMapper userAddrMapper; @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) { Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"userId\",userId); criteria.andEqualTo(\"status\",1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, \"success\", userAddrs); return resultVO; } } 控制器实现 @RestController @CrossOrigin @Api(value = \"提供收货地址相关接口\",tags = \"收货地址管理\") @RequestMapping(\"/useraddr\") public class UserAddrController { @Autowired private UserAddrService userAddrService; @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"int\",name = \"userId\", value = \"用户ID\",required = true) public ResultVO listAddr(Integer userId, @RequestHeader(\"token\") String token){ ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; } } 20.2.2 购物车记录列表接口 根据一个ID的集合，查询购物车记录，实现方式有两种： 动态sql &lt;select id=\"searchShoppingCartById\" resultMap=\"shopCartMap\"&gt; select * from shopping_cart where cart_id in &lt;foreach collection=\"list\" item=\"cid\" separator=\",\" open=\"(\" close=\")\"&gt; #{cid} &lt;/foreach&gt; &lt;/select&gt; tkMapper条件查询 criteria.andIn(“cartId”,ids); Mapper接口定义查询方法 映射配置(动态sql foreach) Service接口 Service实现类 控制器实现 @GetMapping(\"/listbycids\") @ApiImplicitParam(dataType = \"String\",name = \"cids\", value = \"选择的购物车记录id\",required = true) public ResultVO listByCids(String cids, @RequestHeader(\"token\")String token){ ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; } 20.2.3 保存订单20.3 前端实现20.3.1 选择购物车记录价格联动 列表前的复选框标签 渲染商品数量以及总价格 在vue示例的data中声明opts和totalPrice，并且监听opts选项的改变—选项一旦改变就计算总价格 20.3.2 点击“结算”跳转到订单添加页面 在购物车列表页面，选择购物车记录，点击“结算之后”将选择的购物车记录ID传递到order-add.html shopcart.html order-add.html 20.3.3 显示收货地址及订单商品20.3.4 订单确认页面选择地址二十一、订单提交及支付21.1 流程分析 21.2 订单添加接口实现21.2.1 数据库操作 根据收货地址ID，获取收货地址信息（tkMapper） 根据购物车ID，查询购物车详情（需要关联查询商品名称、sku名称、库存、商品图片、商品价格） 改造：ShoppingCartMapper中的selectShopcartByCids 保存订单（tkMapper） 修改库存（tkMapper） 保存商品快照（tkMapper） 21.2.2 业务层实现微信支付 为商家提供代理收款服务 1.微信支付业务-商户需要注册微信支付业务 商户编号：3454563 商户账号：23435 商户编号appID： werselfjldsjhtoieiurt0 商户密钥：sdfsdlkfjdslkjfFGFGDSRTG89 2. 微信支付业务-商户注册微信支付业务 支付订单，并不是用户提交的商品订单，而是商户向微信支付平台申请的支付链接 2.1导入微信支付Maven依赖 wxpay的maven依赖生成 &lt;!-- https://mvnrepository.com/artifact/com.github.wxpay/wxpay-sdk --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 2.2 创建微信支付配置类： 创建一类，实现WxPayConfig接口 重写三分方法，分别设置AppID\\商户ID\\商户密钥 package com.qfedu.fmmall.config; import com.github.wxpay.sdk.WXPayConfig; import java.io.InputStream; public class MyPayConfig implements WXPayConfig { //商户账号 @Override public String getAppID() { return \"wx632c8f211f8122c6\"; } //商户appID @Override public String getMchID() { return \"1497984412\"; } @Override public String getKey() { return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC\"; } //商户的密钥 @Override public InputStream getCertStream() { return null; } @Override public int getHttpConnectTimeoutMs() { return 0; } @Override public int getHttpReadTimeoutMs() { return 0; } } 2.2和微信的接口进行相关的参数设置和获取微信支付链接2.21创建自己的url,PayController类：package com.qfedu.fmmall.controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/pay\") public class PayController { @PostMapping(\"/success\") public void success(){ } } 2.22添加订单快照成功生成支付链接必须设置的配置参数： // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPay; import com.qfedu.fmmall.config.MyPayConfig; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultStatus; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @CrossOrigin @RequestMapping(\"/order\") @Api(value = \"提供订单相关的接口\",tags = \"订单管理\") public class OrderController { @Autowired private OrderService orderService; @PostMapping(\"/add/{cids}\") public ResultVO add(@PathVariable(\"cids\") List&lt;Integer&gt; cids, @RequestBody Orders orders){ ResultVO resultVO=null; // 测试用的OrderId try { Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, orders); String orderId=orderInfo.get(\"orderId\"); // 订单快照创建成功，申请支付链接 HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;(); // 设置当前订单信息 data.put(\"body\",orderInfo.get(\"productNames\")); //商品描述 data.put(\"out_trade_no\",orderId);//使用当前用户订单编号作为当前支付交易的交易编号 data.put(\"fee_type\",\"CNY\"); //支付币种 data.put(\"total_fee\", orders.getActualAmount()+\"\"); //支付金额 data.put(\"trade_type\",\"NATIVE\");//交易类型 // 必填选项 用于设置支付完成时的回调方法接口 data.put(\"notify_url\",\"/pay/success\"); WXPay wxPay=new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); // 把微信支付平台生成的链接获取到 orderInfo.put(\"payUrl\",resp.get(\"code_url\")); resultVO=new ResultVO(ResultStatus.OK,\"提交订单成功！\",orderInfo); System.out.println(resp); // code_url -&gt; weixin://wxpay/bizpayurl?pr=Iv5Fsq6zz } catch (SQLException e) { resultVO= new ResultVO(ResultStatus.NO,\"下单失败\",null); } catch (Exception e) { e.printStackTrace(); } return resultVO; } }","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2022-02-14T13:21:33.000Z","updated":"2022-02-15T16:22:51.997Z","comments":true,"path":"posts/computermanage/","link":"","permalink":"https://dahammer666.github.io/posts/computermanage/","excerpt":"","text":"一、Start一、计算机系统体系结构术语体系结构的三种用法 指令集体系结构（ISA） ​ 描述了程序员看到的计算机的抽象视图，并且定义了汇编语言和编程模型。之所以说它是抽象的，是因为它并没有考虑计算机的实现。 微体系结构（具体实现） ​ 描述了一种指令集体系结构的实现方式。微体系结构关注计算机的内部设计。 系统体系结构 ​ 关注包括处理器、存储器、总线和外设在内的整个系统。 计算机系统体系结构所涉及的内容 1.1 什么是计算机体系结构 计算机系统包括读取并执行程序的中央处理单元（Central processing unit,CPU），保存程序和数据的存储器，以及输入输出子系统，这些子系统会使CPU与显示器、打印机等外部设备之间的通信变得更加容易。 计算机中实际执行程序的部分叫做CPU，或者更简单地被称作处理器。微处理器则是在单个硅片上实现的CPU。围绕着微处理器构建的计算机被称作微机。 尽管CPU是计算机的核心，计算机的性能既取决于CPU，也取决于其他子系统的性能。如果不能高效进行数据传输，仅仅提高CPU的性能是毫无意义的。 简单通用计算机结构 1.1.1 简单通用计算机结构 信息（即程序和数据）保存在存储器中，为了实现不同的目标，计算机会使用不同类型的存储器，如Cache、主存、辅存等多个存储层次，大多数处理器都在CPU内集成了片上Cache。 Cache是存放常用数据的高速、专用存储器。主存中存放了大量的工作数据。辅存是指磁盘和CD-ROM，能够存储海量数据。 组成计算机的各个子系统通过总线连接在一起，数据通过总线从计算机中的一个位置传递到另一个位置。 可编程计算机接收两种类型的输入：要处理的数据，以及要如何处理输入数据的程序。程序不过是计算机所执行的完成给定任务的操作序列。 数字计算机的结构，可以被分为两部分：中央处理单元和存储器系统。CPU读程序并完成程序指定的操作。存储器系统保存两类信息：程序，程序处理或产生的数据。 寄存器是CPU内部用来存放数据的存储单元。 时钟提供了脉冲流，所有内部操作都在时钟脉冲的触发下进行。时钟频率是决定计算机速度的一个因素。 1.1.2 程序执行的过程 描述了程序的执行过程： 从存储器中读出一条Z=X+Y的指令，将其发送给解释单元，解释单元产生控制信号，驱动这条指令的执行。假定这个程序的功能是从存储器读出两个数据（X和Y），将它们相加，然后写回存储器。 要执行这个程序，CPU必须首先从存储器中取出一条指令，在CPU分析或解码这条指令后，从存储器中读出这条指令所需的所有数据。第一条指令，LOAD X，从存储器中读出变量X的值，并将它暂存在寄存器中。第二条指令，LOAD Y，从存储器中读出变量Y的值，并保存在另一个寄存器中。第三条指令，Z=X+Y，将两个寄存器的内容相加，并将结果保存在第三个寄存器中。第四条指令，STORE Z，将加法的结果写回存储单元Z。 1.1.3 计算机指令 尽管计算机能够执行上百种不同指令，但下面的**6条基本指令(汇编语言)**可以将所有计算机指令进行分类： MOV A, B 将B的值复制到ALOAD A, B 将存储单元B的值复制到寄存器A中STORE A, B 将寄存器B的值复制到存储单元A中ADD A, B A与B相加，结果保存到A中TEST A 测试A的值是否为0BEQ Z 若最后一次测试结果为TRUE，执行地址Z处的代码 ， 否则继续执行 1.2 体系结构和组成1.2.1 计算机体系结构 计算机体系结构含有结构（structure）的意思，描述了一些与计算机组成方式有关的内容。之所以定义计算机体系结构，是因为不同的用户会从完全不同的角度看待计算机。计算机体系结构通常被认为是程序员视角中的计算机。程序员所看到的是计算机的抽象视图，计算机的实际硬件和实现都被隐藏起来了。这个抽象视图现在通常被称作指令集体系结构（instruction setarchitecture，ISA）。 1.2.2 计算机组成 计算机组成表示其体系结构的具体实现。计算机组成是计算机体系结构的实例化（即将抽象变为具体） 本书用术语“体系结构”代表计算机的抽象指令集体系结构（它的指令集），用术语“组成”代表计算机的实际硬件实现。 1.2.3 寄存器 寄存器是用来存放一个单位的数据或字数据的存储单元。寄存器通常用它所保存数据的位数来描述，典型的有8位、16位、32位和64位。 寄存器与存储器中的字存储单元没有本质区别。二者的实际差别在于，寄存器位于CPU内，它的访问速度远远快于访问CPU外的存储器。 1.2.4 机器码&amp;汇编语言&amp;高级语言 计算机上执行的代码表示为二进制0和1组成的串，被称作机器码。每种计算机都只能执行一种特定的机器码。 人类可读的机器码（如ADD R0,R1）叫作汇编语言。 能够在类型完全不同的计算机上运行，与底层计算机体系结构几乎没有关系的代码叫做高级语言（如C或Java等）。在执行之前，高级语言程序必须先被编译为计算机的本地机器码。 1.2.5 时钟 绝大多数数字电子电路都带有一个时钟，用以生成连续的间隔固定的电脉冲流。之所以被称作时钟，是因为可用这些电脉冲来计时或确定计算机内所有事件的顺序。如，处理器可能会在每一个时钟脉冲到来时执行一条新指令。 1.2.6 RISC和CISCRISC（精简指令集计算机）体系结构（ARM） 设计策略：是使用少量的指令完成最少的简单操作 缺点：程序设计更难，复杂指令需要用简单指令模拟 应用：ARM处理器 CISC（复杂指令集计算机）体系结构 设计策略：是使用大量的指令，包括复杂指令 优点：程序设计更容易，因为每个简单的或复杂的任务都有一条对应的指令。程序员不需要写一大堆的指令去完成复杂的任务 缺点：指令集的复杂性使得CPU和控制单元电路非常复杂 应用：英特尔公司开发的奔腾系列CPU 1.3 计算机的发展 机械计算机 -&gt; 机电式计算机 -&gt; 早期的电子计算机 -&gt; 微机和PC革命 1.3.1 摩尔定律和进步的历程 摩尔定律 ​ 是卡沃-米德于1975年根据戈登-摩尔所观察到集成电路的集成度每18个月翻一番，摩尔定律是一个经验性的观察结果。 1.3.2 乱序执行 程序中的指令必须一条接一条按照在程序中的出现的顺序执行。 有时可以通过改变指令的执行顺序提高计算机的速度。图中，指令（4）和（5）可以在任何时候执行，但指令（3）必须在指令（1）和（2）结束后执行。 1.3.3 存储技术发展 覆盖着电容的旋转的磁鼓 -&gt; 阴极射线管 -&gt;铁氧体磁芯存储器 -&gt;磁盘 -&gt; 光存储器（DVD等） 1.3.4 多媒体计算机多媒体处理（处理和存储音频/视频数据）需要很大的存储容量以及完成大量简单重复操作的实时处理声音样本的图像像素的能力。 1.4 存储程序计算机1.4.1 最大游程问题描述 ​ 十进制数串23277366664792221，其中有一些值相同的数字连续出现（如连续的2个7,4个6和3个2），我们的问题十分简单：找出最大游程，即同一个数字连续出现的最大次数。 ​ 为了简化问题，假设数串长度大于3。我们将设计一个计算机来处理图中的数串，它每次读一个数，并计算最大游程。 解决方法： ​ 从数串的左边开始逐个检查数字，在任何一个位置，都会得到两个结果之一：要么这个数与前一个相同，序列还在增长；要么这个数与上一个不同，前一个序列结束，一个新的序列开始。 对于一个数字系统，当一个特定事件（如时钟脉冲）发生时，它将从一个状态转换为另外一个状态。 图中有两个状态，分别是“在同一序列中”和“不在同一序列中”，每当从数串中读出一个新元素，都会发生状态转换。 一、如图，列出一个接一个读入数串的数字后系统状态的转换情况，状态的改变会发生在序列的第二个数字或结束序列的那个数字上。 二、如表，将这些数字组织成更容易理解的形式。最上面一行是每个数字在数串S中的位置或地址，下一行是串S中这个数字的值。第三行第一个元素是？，因为上一个元素的值是未知的。第四行统计数串中每个元素所在序列的长度,数字本身长度为1，如果相同则+1 统计数串中最大序列长度 为了方便，通过下面的符号名说明问题： i 串的当前位置 New_Digit 刚从数串中读出的数字的值 Current_Run_Value 当前序列数值 Current_Run_Length 当前序列长度 Max_Run 目前为止的最大序列长度 | 使用伪代码描述问题的操作： 读出串的第一个数字，将其称为New_Digit 将Current_Run_Value的值置为New_Digit 将Current_Run_Length的值置为1 将Max_Run的值置为1 REPEAT 读出序列中下一个数字（即read New_Digit） IF 它的值与Current_Run_Value相同 THEN Current_Run_Length = Current_Run_Length + 1 ELSE { Current_Run_Length = 1 Current_Run_Value = New_Digit } IF Current_Run_Length &gt; Max_Run THEN Max_Run = Current_Run_Length UNTIL 读出了最后一个数字 1.4.2 存储器 如图，描述了程序怎样找出保存在一个假象存储器中的数串的最大序列长度。必须强调的是，这个程序是概念上的而不是实际的。该图叫作存储器映射，展示了信息在存储器中的存放位置，存储器中的每个位置要么保存指令，要么保存数据元素。 1.4.3 寄存器传输语言 由于使用文字描述计算机的操作很不方便，使用RTL可以更加容易地定义计算机内发生的操作。 区分存储单元的地址和它的内容非常重要。在RTL语言中，用方括号[ ]表示存储单元的内容，如 [15] = Max_Run 含义是：地址为15的存储单元保存了变量Max_Run的值 左箭头符号表示数据传送操作，如 [15]&lt;–[15] + 1 含义是：将地址为15的存储单元的值加1，并将结果写回地址为15的存储单元考虑下面3个RTL表达式：[20] = 5[20]&lt;–6[20]&lt;–[6] 1.4.4 存储系统 如图，描述了存储系统的组成 处理器将一个放在地址总线上的地址以及一个用于选择读操作或写操作（也被称为读或写周期）的控制信号发送给存储器。 在读周期中，存储器将数据放在数据总线上供CPU读取。 写周期中，放在数据总线上的数据被写入存储器。 信息进入或离开存储器的位置叫作端口。 1.4.5 存储程序的概念 下面的伪代码描述了存储程序计算机的基本操作： 存储程序计算机 程序计数器指向存储器中的第一条指令 REPEAT 从程序计数器所指的存储单元中读出指令 修改程序计数器，使之指向下一条指令 将从存储器中取出的指令解码 执行指令 FOREVEREnd 从存储器中取出每条指令都需要进行一次访存操作（即读存储器）。可以用下面的伪代码描述“执行指令”这一动作： ​ 执行指令​ IF 指令需要使用数据​ THEN 从存储器中读这个数​ END_IF​ 完成指令定义的操作​ IF 指令要将数据写回存储器​ THEN 将数据写回存储器​ END_IF​ End 上面的动作序列用C语言描述： 执行一条指令需要至少两次访存，第一次访存是读取指令，第二次访存要 么从存储器读出指令需要的数据，要么将它之前的指令产生的或修改过的 数据写回存储器。 1.4.6 指令格式 存储程序计算机的一种直观合理的指令格式可以用下面的形式表示： Operation表示要执行的指令的动作Address1、Address2和Address3分别是3个操作数在存储器中的位置。在这条指令中，操作数为数据的地址，而不是数据本身。 ADD P,Q,R是一条典型的三操作数指令，P、Q、R是三个存储单元地址的符号名。这个三操作数指令格式用RTL表示为： 如图，描述了一条指令的执行过程，一共需要4次访存（即一次取指令，两次取两个源操作数，一次保存结果） 如图，描述了指令的4个字段与CPU、存储器以及指令的执行方式之间的关系： 1.4.7 两地址指令 有些计算机实现了两地址指令，其格式为： Address2为源操作数，Address1既是源操作数也是目的操作数。 指令ADD P,Q的RTL定义为： 两地址指令会破坏它的一个操作数，也就是说，会用结果替换源操作数P，本书大部分章节约定两地址指令格式为： 在实际计算机中，一般不允许同一条指令中使用两个存储地址，大多数计算机都规定一个地址是存储器地址，另一个地址是寄存器。 1.4.8 单地址指令有些计算机实现单地址指令，其格式为： 指令中只提供了一个操作数地址，而指令却需要至少两个地址，处理器不得不使用一个不需要显示地址的第二操作数，第二个操作数来自CPU内一个叫累加器（accumulator）的寄存器。 如图，描述了一条单操作数指令执行过程中的信息流，操作结果将一直保存在寄存器中，直到另一条指令将它送入存储器。实现P = Q + R： 1.4.9 计算机分类可以按照计算机的指令处理数据的方式对计算机分类 存储器-存储器型：一条指令能够从存储器中读出源操作数，对数据完成某个操作，并将结果保存在存储器中 寄存器-存储器型：能够处理两个数据，其中一个位于存储器中，另一个位于寄存器中，结果要么被写回存储器，要么被写回寄存器，如Intel IA32 CPU体系结构 寄存器-寄存器型：只能对寄存器中的内容进行操作，这些计算机必须通过LOAD指令将数据读入寄存器并使用STORE指令将数据从寄存器送回存储器。由于LOAD 和STORE操作是仅有的存储器访问指令，这些计算机也被称为load/store 型计算机，如ARM和MIPS CPU体系结构 1.6 计算机系统概览1.6.1存储层次由于CPU与存储器的性能之间的差距不断加大，通过在使用数据之前将它们从存储器中取出来消除相对慢速的存储器的影响，以降低延迟。 如图，描述了经典的存储层次图，展示了计算机中存储部件的类型、速度以及在PC机中的典型容量： 寄存器：存放处理器的工作数据 Cache：缓存常用数据的快速存储器 (内存)DRAM：存放工作数据 硬盘：保存程序和数据， 注意，硬盘的容量是寄存器 的4000万倍，但速度却比寄存器 慢2000万倍！ 1.6.2 Cache高速缓存 经常被用到的数据保存在Cache中，Cache的访问时间比主存短得多。Cache保存主存中经常使用的数据的副本。Cache系统与计算机的地址总线和数据总线相连，监听CPU与存储器之间的事务。 只要Cache注意到CPU发出的地址与它保存的某个数据元素地址相同，就把这个数据发送个CPU，而不会去主存中取数据。 一级缓存（集成在CPU中）&amp;二级缓存&amp;三级缓存 1.6.3 DRAM 存放正在执行的程序的主存，是由一种叫作动态随机访问存储器（Dynamic Random Access Memory,DRAM）的易失性半导体存储器构成的立即存取存储器。 1.6.4 总线 总线将计算机的两个或多个功能单元连接在一起并允许它 们相互交换数据。总线还将计算机与外设连接在一起。 如图，描述了一个没有总线的假象系统的结构，节点之间的互连复杂并且凌乱，若要添加一个新单元，必须在新单元与它所连接的每个单元之间增加一条新连接： | 如图，展示了通过公共总线将所有单元连接在一起的好处，此时只有一条高速数据通路，每个单元通过一个接口与这条通路相连： || ———————————————————— || || 缺点：每次只有唯一一个设备能够与其它设备通信，因为这里只有一条信息通路。如果两个设备同时请求使用总线，它们不得不去竞争总线的控制权。用术语仲裁来描述多个设备竞争同一资源的过程。 | 总线术语 宽度 一般用并行数据通路的数量来定义总线的宽度。一条64位宽的总线一次能传送64位（8个字节）信息。 带宽 总线带宽是衡量信息在总线上的传输速率的一项指标。带宽的单位要么是B/s，要么b/s。在保持数据传输率不变的情况下增加总线宽度，可以提高带宽。 延迟 延迟是从发出数据传输请求到实际数据传输的时间间隔。总线延迟通常包括传输开始之前进行总线仲裁的时间。 多总线系统 | 现代计算机中有多条总线，包括片内总线、功能单元间（如CPU和存储器间）的总线以及总线间的总线，如图描述了一个多总线系统： （1）多总线运行并发操作（2）总线可能具有完全不同的特点和操作速度 || ———————————————————— || | 二、计算机算术2.1 数据是什么 数据是各种各样的信息，如数字、文本、计算机程序、音乐、图像、符号等等，实际上，信息可以是能够被计算机存储和处理的任何事物。 2.1.1 位与字节 计算机中存储和处理信息的最小单位是位（Binary digit比特，bit），一个比特的值可以是0或1。 数字计算机将信息以一组或一串比特（称作字）的形式保存在存储器中。如，串01011110表示一个8位的字。 计算机通过高低电压（高低电位）两个电压等级来存储0和1的状态。 计算机通常不会每次只对一个二进制位进行操作，而是对一组二进制位进行操作。8个二进制位为一个字节（byte），一些计算机制造商用术语“字”表示16位的值，长字表示32位的值，还有一些制造商用字表示32位的值，用半字表示16位的值。 2.1.2 位模式| 下图描述了如何用1位、2位、3位和4位得到一个二进制的值序列： || ———————————————————— || || 每当数字增加1位，路径的总数将翻一倍。一个n位的字将得到2n条不同路径或位模式。如，一个8位的字节将得到28=256个可能的值。 为了用二进制数表示任何一个拥有最多n个值的量，应找到一个使不等式n&lt;=2m成立的最小位数m。 | 2.1.2.1 位模式——信息表示 一个n位的二进制可以表示什么信息呢？ 答案是什么也表示不了。因为一个由二进制1和0组成的串没有任何内在含义。需要程序员赋予它何种含义。 一个二进制串可以表示的对象有： 指令字长为32位或更长的计算机用一个字来表示CPU能够完成的操作（8位或16位计算机用多个字表示一条指令）。指令的二进制编码与其功能之间的关系由计算机设计者决定。如，一台计算机上表示“A加B”的二进制序列可能与另一台计算机上的完全不同。 数量一个字或多个字都可以用来表示数量。数可以被表示为多种格式，如有符号、无符号二进制整数、二进制浮点数、整数复数等等。 字符 字符是一个叫作“字母表”的集合中元素。拉丁或罗马字母表中的字母、数字字符（A-Z，a-z，0-9）和*、-、+、？等符号都被分配了二进制值，因此可以在计算机内存储和处理。 下图为ASCII码表（美国信息交换标准码表）： ASCII码表用7位表示一个字符，一共可以表示2^7=128个不同的字符。其中96个字符是可打印字符。其余32个是不可打印字符，用于完成回车、退格、换行等特殊功能。 扩展的ASCII码表：8位的ISO 8859-1拉丁编码。将7位的ISO/ASCII字符集扩展为8位，可以得到两个128个字符的字符集，如果字符的最高位为0,**则其余7位代表128个标准ISO/ASCII字符中的一个，如果字符最高位为1**，其余7位将表示128个新字符中的任意一个。 图像、声音和视觉 数字计算机处理大量表示声音、静态图像和视频的数据。 组成照片的基本单位是像素，每个像素的大小可以是8位（单色）或24位（三基）。 视频作为一串静态图像依次传输，每秒发送60次。 声音通过对波形信号采样。 无损压缩和有损压缩。 2.2 数字 用来计数的数字（即1,2,3,4…）被称作自然数。我们用十进制计数，因为它有0~9共10个符号。并非所有数字都是自然数，还有负数、实数等 现代数字系统中，使用位置记数法表示十进制数，每个数位的值或权取决于它在数字中的位置。 2.2.1 位置记数法 按照位置记数法，一个n位的整数N的形式表示： 用小数点将整数部分和小数部分分开，可以对位置记数法进行扩展，使其能 表示实数。 一个用基数b的位置记数法表示的数的值被定义为： || | 采用位置记数法，一个数的数值等于它各位值的总和，而每一位的值则是该位的数值乘以它在数中的位置所对应的权。 如：十进制数1982 = 1 x 103 + 9 x 102 + 8 x 101 + 2 x 100二进制数10110.11 = 1x24 + 0x23 + 1x22 + 1x21 + 0x20 + 1x2-1 + 1x2-2 注意：十进制位置记数法不能精确表示所有小数，如1/3是0.3333333…33，二进制也是如此，如0.110 不能被精确转换为二进制形式。 2.3 二进制运算| 二进制算术运算规则与十进制基本相同，区别是基数不同。 下面列出了二进制加、减、乘法运算的规则： || ———————————————————— || || 两个位相加可能产生进位或借位，和十进制运算规则相同。 | 下面是4个8位二进制数相加的例子： 当两个二进制数相减时，会从左侧借一位，如： 下面描述了011010012（乘数）与010010012（被乘数）相乘的过程，两个n位 字相乘将产生一个2n位的积： 但是计算机并没有按照这种方式进行计算。 2.4 有符号整数 负数可以用多种不同的方式表示，计算机设计者选择了3种方法：符号及值表示法、二进制补码表示法、移码表示法，每种方法都有各自的优缺点。 2.4.1 符号及值表示法| 一个n位字可以表示从0~2n-1共2n个可能的值。如，一个8位的字可以表示0,1，…，254,255。表示负数的方法是用它的最高位表示符号，通常符号位为0表示正数，符号位为1表示负数。 下面两个8位有符号二进制00001101和10001101的值为： || ———————————————————— || | n位有符号的表示范围为-(2n-1-1) ~ +(2n-1-1)。一个8位有符号数的表示-127（11111111）~ +127（01111111）之间的整数。 有人反对该系统的一个原因是它有两个值都表示0：00000000 = +0 和 10000000 = -0 符号及值表示法没有被用于整数算术运算中，因为它的加、减法运行需要分别用加法器和减法器实现。符号及值表示法用于浮点算术运算中。 2.4.2 二进制补码运算 微处理器用二进制补码系统表示有符号整数，它可以将减法运算转换为对减数的补码的加法运算。 2.4.2.1 补码算术运算 一个数与它的补码之和是一个常数。如，一个一位十进制数与它的补码之和总是9。2的补码是7，因为2+7=9。在n位二进制算术中，数P的补码为Q且P+Q=2n。 在二进制算术中，求一个数的补码的方法是将其各位取反并加1。如：01100101的补码为10011010+1=10011011。 一个n位二进制数N的二进制补码定义为2n-N。如果N=5=00000101（8位二进制数），则N的补码为28-00000101=100000000-00000101=11111011 下面说明了8位二进制数的补码运算过程，将4个数+5、-5、+7、-7转换为补码： 将7与5的补码相加： 结果为9位二进制数100000010。如果忽略最左边一位（进位位），结果为000000102=+2，正是希望得到的结果。 将-7加5： 结果为11111110（进位位为0）。也是希望得到的结果-2，即28-2=100000000-00000010=11111110 n位二进制算术运算Z=X-Y，用X加上Y的补码完成运算：Y的补码为2n-Y，则Z=X+(2n-Y)=2n+(X-Y)。我们得到了需要的结果，X-Y，以及位于最左边的一个并不需要的进位（即2n），而这个进位被丢弃了。 一个数两次求补码得到该数本身。如-5=28-00000101=11111011。即-x=2n-x且-(-x)=2n-(2n-x)=x。 考虑下面加法实例： 2.4.2.2 求补运算 求补运算——为什么是取反加1 一个n位的二进制数N的补码，被定义为2n-N，则 如，8位（n=8）时有： 表达式11111111-N的值很容易计算，对N的第i位ni，若ni=0，则1-0=1，若ni=1，则1-1=0。显然： 所以计算N的补码就是将N的每一位取反加1。 下面的5位二进制数有： 这种求补码的方法的优点在于它很适合硬件实现。 2.4.2.3 补码的特点 1）补码是一个真正的互补系统，因为+X+(-X)=02）补码0被表示为00…0，是唯一的3）补码的最高位为符号位。如果符号位为0，则该数为正，符号位为1，则该数为负4）n位二进制补码数的表示范围为-2n-12n-1-1。对于n=8，补码范围为-1281275）补码加法和减法使用同样的硬件完成，因为补码减法由被减数的补码实现 2.4.2.4 运算溢出 N位二进制补码的表示范围为-2n-1~2n-1-1。 5位有符号二进制补码范围为-16~+15，考虑下面例子： 如果两个负数相加且结果小于-16，会超出5位二进制补码的范围，如： 如果操作数A和B的符号位相同，但结果的符号位与它们不同，则发生溢出。 2.5乘除法简介 除了加减法，计算机还必须实现乘法和除法。这两个操作比加减法复杂得多，所需的完成时间也长得多（或需要更复杂的硬件）。这里仅介绍乘法和除法的基本知识。 2.5.1 移位运算 首先介绍二进制补码的算术移位运算。 进行移位运算时，一个数的所有位都会向左或向右移动一位，如将00101100左移一位，变为01011000，右移一位，变为00010110。有些计算机每次可以移动多位。 二进制补码正数左移一位等价于该数乘2。如，十进制数39的二进制位00100111，左移一位得到01001110，对应于十进制数78。 下图描述了算术移位的过程： a）算术左移：最低位补0，最高位被复制到进位标志中，如11000101左移一位得到10001010b）算术右移：最高位补符号位，所有位右移一位。最低位复制到进位标志中。如00100101右移一位得到00010010。11100101右移一位得到11110010。 二进制数右移一位相当于它除以2。如00001100（即1210）右移一位得到00000110（即610），注意00001101（即1310）右移一位得到00000110（即610），因为移出的最低位被丢弃了。 考虑负数右移，11100010（即-30），右移一位得到11110001（即-15）。 2.5.2 无符号二进制乘法 计算机从乘数的最低位开始，每次检查一位，判断它是否为0，如果乘数的当前位为1则写下被乘数，若该位为0则写下n个0。接下来检查乘数的下一位，这时应从上一位数的左边一位开始写下被乘数或0。被写下的这一组数叫作部分积。得到所有的部分积后，加到一起，得到乘法结果： 乘法结果100000102 = 13010是一个8位二进制数。两个二进制数相乘得到一个2n位的积。 但是计算机并没有实现上面的算法，这种算法要求计算机存储n个部分积，然后将它们同时相加。更好的做法是每得到一个部分积就做一次加法。 下面给出了一个计算两个n位无符号二进制数相乘的算法：步骤a：将计数器的值置为n步骤b：将2n位的部分积寄存器清零步骤c：检查乘数的最右位（即最低位），将被乘数与部分积的最低位n位相加步骤d：将部分积右移一位步骤e：将乘数右移一位（乘数的最右位被丢弃）步骤f：将计数器的值减1，重复步骤c直到n个周期后计数器的值变为0。部分积寄存器的内容就是乘积结果。 2.5.3 快速乘法 通过移位和加法实现的乘法速度很慢，实际的计算机采用了多种方法加快乘法运算的速度。 有些程序员使用移位和加法等速度相对较快的操作避免使用乘法。考虑P乘以10和P乘以9的两个例子： 10P= 2x(2x2xP+P) ，即将P左移2次，加上P，再将和左移一次 9P= 2x2x2xP + P，即将P左移3次，加上P得到结果 乘法运算也可以借助查找表（look-up table）实现，这种方法将两个数相乘所有可能的积都保存在一个只读存储器内。这样只需简单的用X和Y的值找到表中的对应项就可以得到X和Y的乘积。如，两个8位二进制乘法需要一个16位地址、216项的查找表，每项记录一个16位的积。 缺点：太占空间了。 2.5.4 除法 除法是通过被除数不断地减去除数直到结果为0或小于除数来实现的。减去除数的次数称作商，最后一次减法的差称作余数。 被除数/除数 = 商 + 余数/除数 下面描述了575除以25的过程： 将被除数的下一个数字5移到7的后面，并比较除数和75，由于75正好是25的整数倍，因此在商的下一位上写下3： 因为已经处理到被除数的最后一位且75正好是测试的整数倍。除法结束，商为23，余数为0。 考虑用无符号二进制除法完成同样的例子： 被除数的前5位比除数小，因此商的最高位为0并将除数与被除数的前6位比较 ​ 被除数的前6位中有一个除数，减法后得到新的部分被除数为001010（1111），将被除数的下一位移下来 新的部分被除数小于除数，因此商的下一位为0，后续除法过程如下： 除法结果商为10111，余数为0。 2.5.4.1 恢复余数除法 刚刚讨论的除法方法，用计算机实现，需要修改的就是除数与部分被除数的比较方法，计算机减去并检测结果的符号位。如果减法的结果为正，则商1，如果结果为负，则商0并将部分被除数与除数相加，将其恢复为原先的值。 恢复余数除法算法：1）将除数的最高位与被除数的最高位对齐2）从部分被除数中减去除数，得到新的部分被除数3）如果新的部分被除数为负数，则商0并用新的部分被除数加上除数，恢复原先的部分被除数4）如果新的部分被除数为正，则商15）判断除法是否结束，如果除数的最低位与部分被除数的最低位对齐，则除法结束，最后的部分被除数就是余数。否则，执行第6步6）将除数右移一位，从第2步继续执行 下图描述了该算法的流程图： 按照流程图计算 011001112除以10012， 即十进制数103除以9， 结果为商11余4， 下表列出了除法的过程： 2.5.4.2 不恢复余数除法 不恢复余数除法与恢复余数除法基本相同，唯一区别在于取消了恢复余数的操作。 在恢复余数除法中，在部分被除数与除数相加恢复部分被除数之后的一个周期，部分被除数将减去除数的二分之一。每个将除数右移的操作等价于将除数除以2。当前周期恢复部分被除数以及下个周期减去除数一半的操作等价于部分被除数加上除数的一半。即D – D/2 = +D/2，D为除数。 | 下图给出了不恢复余数除法的流程图： 部分被除数减去除数之后，将检测新的部分被除数的符号位。若为负，则商左移1位，商的最低位补0，并将部分被除数加上除数的二分之一。若为正，则商左移1位，商的最低位补1，并将部分被除数减去除数的二分之一。 || ———————————————————— || || 下表列出了不恢复余数除法的过程： || || | 2.6 浮点数 浮点数即实数，实数是所有有理数和无理数的集合。 之所以叫作浮点数，是因为小数点在数中的位置并不是固定的。一个浮点数值分为两部分存储 ：数值以及小数点在数值中的位置。 计算机中的浮点运算的计算结果一般是不确定的，一块芯片上的浮点计算结果也许与另一块芯片上的不同。 科学计数法：来表示很大或很小的数。十进制浮点数可以被表示为：尾数x10指数，如1.2345x1020二进制浮点数可以被表示为：尾数x2指数，如1.0111x25IEEE 754浮点数标准提供3种浮点数表示：32位单精度浮点数、64位双精度浮点数、128位四精度浮点数 1. 规格化浮点数 IEEE 754浮点数的尾数总是规格化的，其范围为1.000…0x2e到1.111…1x2e，e为指数。规格化浮点数的最高位总是1，规格化使尾数的所有位都是有效的，因而尾数精度最高。如： 0.10…x2e规格化为1.10…x2e-1 10.1…2e规格化为1.01…x2e+1 尾数规格化充分利用了可用的最大精度。如，一个8位非规格化的尾数0.0000101只能有4位有效位，而规格化后的8位尾数1.0100011则有8位有效位。 2. 偏置指数 IEEE 754浮点数的尾数被表示为符号及值的形式，即用一个符号位表示它是正数还是负数。它的指数则用偏置方式表示，即给真正的指数加上一个常数。 假定所用的指数为8位，偏置值为127。如果一个数的指数为0，则被保存为0 + 127=127。如果指数为-2，则被保存为-2 + 127 = 125。 实数1010.1111规格化的结果为+1.010111x2^3，指数为+3，将被保存为3+127=130，即13010用二进制表示为10000010。 这种用偏置表示指数的方法优点在于，最小的负指数被表示为0，如果不采用这种方法，0的浮点表示为0.0…0x2最小负指数。采用偏置指数，0就可以用尾数0和指数0表示： 2.6.1 IEEE浮点数 一个32位IEEE 754单精度浮点数可以被表示为下面的二进制串： S EEEEEEEE 1.MMMMMMMMMMMMMMMMMMMMMMM S为符号位，指明这个数是正数还是负数E为8位偏置指数，指出了小数点的位置M为23位尾数 下图描述了32位浮点数的结构： S位为符号位，决定了数的符号，若S=0，则为正数，若S=1，则为负数。指数E将浮点数的尾数扩大或缩小2^E倍，并且偏置值为127。如浮点数+1.11001…0x2^12的指数为12+127=139(10)=10001011(2) 。 IEEE浮点数的尾数总是规格化的，其值范围在1.0000..00~1.1111..11，除非这个浮点数是0，此时尾数为0.000..00。 由于尾数总是规格化的，且最高位总是为1，因此将尾数存入存储器时没有必要保存最高位的1。所以，一个非0的IEEE 754浮点数可被定义为： S：符号位 E：偏置量为B的指数 F：尾数的小数部分（实际的尾数为1.F，有个隐含的1） 浮点数0被表示为S=0，E=0，M=0（即浮点数0用全0表示） 考虑下面的例子：将一个32位IEEE单精度浮点数X=11000001100110011000000000000000解压为一个符号位、一个偏置指数和一个尾数。 解压这3个字段得到：S = 1，E=10000011，F=00110011000000000000000实际的尾数为1. 00110011000000000000000，因此这个数为： -1. 00110011000000000000000 x 2^(10000011 – 01111111 ) = -1.00110011000000000000000 x 2^4 = -10011.0011 2.6.1.1 IEEE浮点数格式 ANSI/IEEE 745-1985标准定义了基本的和扩展的浮点数格式，以及一组数量有限的算术运算的规则（加、减、乘、除、平方根、求余和比较）。 非数（Not a Number，NaN）是IEEE 754标准提供的一个专门符号，代表IEEE 754标准格式所不能表示的数。 下图，IEEE 754标准定义了3种浮点数格式： 在32位IEEE 754单精度浮点数格式中，最大指数Emax为+127，最小指数Emin为-126，而不是+128~-127。Emin-1（即-127）用来表示浮点0，Emax+1用来表示正/负无穷大或NaN数。 下图，描述了IEEE单精度浮点数格式，指数E=0和E=255等特例分别被用于表示浮点0、非规格化小数、正或负无穷大、以及NaN： 2.6.1.2 十进制数转换为二进制浮点数的实例 将十进制数4100.12510转换为符合IEEE 754标准的32位单精度二进制浮点数？ 步骤：1）将4100.125转换为二进制定点数，整数部分4100(10)=1000000000100(2)，小数部分0.12510=0.0012，则4100.125(10)=1000000000100.001(2)2）将1000000000100.0012规格化为1.000000000100001 x 2(12)，则： 符号位S为0，该数为正数 指数为12 + 127 = 139(10) = 100010112尾数为0000000001000010000000（起始位1被省略，尾数扩展为23位）因此结果为0100010110000000001000010000000 2.6.1.3 二进制浮点数转换为十进制 将二进制浮点数11000100011011000000000000000000转换为十进制？ 步骤：1）分析得到符号位S =1，偏置指数E=10001000，尾数F=11011000000000000000000 2）偏置指数100010002减去127得到实际指数 100010002-01111111(2)=000001112=7(10)，则：这个数为：-1.11011000000000000000000(2) x 2^7 = -11101100(2) = -236(10) 2.6.2 IEEE浮点数的特点 1）浮点数接近0时的特点，下图描述了一个指数为2位，尾数为2位的浮点数系统。浮点数0表示为00 000，下一个规格化的正数表示为00 100（即2-bx 1.00，b为偏置常量）： 浮点数0附近有一块禁止区，其中的浮点数都是非规格化的，因此无法被表示为IEEE标准格式。这个数的指数和起始位都是0的区域，也可用来表示浮点数。但是这些数都是非规格化的，其精度比规格化数的进度低，会导致渐进式下溢。 2）IEEE标准规定，缺省的舍入技术应该向最近的值舍入3）IEEE标准规定了4种比较结果，分别是等于、小于、大于和无序（unordered），无序用于一个操作数是NaN数的情景4）IEEE标准规定了5种异常： a)操作数不合法：当程序员使用一些不合法的操作数。如NaN数、与无穷大数 相加或相减时、求负数的平方根等 b)除数为0 c)上溢：当结果比最大浮点数还大时。处理上溢的方法有终止计算和饱和运算（用最 大值作为结果）等 d)下溢：当结果比最小浮点数还小时。也就是说，结果小于2Emin。下溢可以通过将 最小浮点数设为0或用一个小于2Emin的非规格化数表示最小浮点数等方式处理 e)结果不准确：当某个操作产生舍入错误时 2.7 浮点运算 浮点数不能直接相加。 下面以一个简单的8位尾数和一个未对齐的指数为例说明浮点运算，A=1.0101001x2^4，B=1.1001100x2^3。若要计算两个数的乘积，应将尾数相乘，指数相加： 浮点数的加法，笔算时，将A与B的小数点对齐： 由于浮点操作数已被表示为规格化形式，计算机在进行浮点加法时面临以下问题： 为了对齐指数，计算机必须执行下面步骤：第1步，找出指数较小的数第2步，使两个数的指数相同第3步，尾数相加（或相减）第4步，如果有必要，将结果规格化 因为B的指数比A小，将B转为0.110011x2^4，将A与非规格化的B相加： 对结果规格化，得到1.00001111x2^5 下图，给出了浮点加法运算的流程： 注意：1）因为指数有时与尾数位于同一个字中，在加法过程开始之前必须将它们分离开（减压缩） 2）如果两个指数的差大于p+1，p为尾数的位数，较小的数由于太小而无法影响较大的数，结果实际就等于较大的数。如，1.1010x2^60+1.01x2^-12的结果为1.1010x2^60，因为指数之差为72 3）结果规格化时检查指数范围，以分别检测指数下溢或上溢。指数下溢会导致结果为0，而指数上溢会造成错误。 1. 舍入和截断误差 浮点运算可能引起尾数位数的相加，需要保持尾数位数不变的方法。最简单的技术叫作截断。 如，将0.1101101截断为4位尾数的结果为0.1101。截断会产生诱导误差（即误差是由施加在数上的操作计算所引起的），诱导误差是偏置的，因为截断后的数总比截断前小。 舍入是一种更好的减少数的位数的技术。如果丢弃的位的值大于剩余数最低位的一半，将剩余数的最低位加1。 考虑两个数在小数点后第4位上舍入的例子： 下图描述了舍入机制： 1）最简单的舍入机制是截断或向0舍入。2）“向最近的数舍入”方法会选择距离该数最近的那个浮点数作为结果。3）“向正或负无穷大舍入”方法会选择正或负无穷大方向上最近的有效浮点数作为结果。当要舍入的数位于两个连续浮点数的正中时，IEEE舍入机制选择最低位为0的点（即向偶数舍入）。 2.8 浮点运算和程序员 整数操作时精确、可重复的，浮点数操作是不精确的。 考虑表达式z = x^2-y^2，x、y、z都是实数。可以将表达式视作x^2-y^2或(x+y)(x-y)计算，整数运算得到相同结果，但浮点数运算可能得到不同结果。 IEEE要求加、减、乘和除运算结果能够精确计算，并用向偶数舍入的方法将结果舍入为最近的浮点数。 2.8.1浮点运算中的误差传播2.8.2生成数学函数 sin(x) —-&gt;泰勒级数 二、指令集体系结构三、体系结构与组成 计算机的指令集体系结构（ISA）从汇编语言程序员的角度描述了计算机，并强调了计算机的功能，而不是它的内部组成或实现。ISA说明了计算机能做什么，而计算机组成则说明了它是如何做的。 3.1 存储程序计算机 （1）ARM这一类处理器采用了存储程序体系结构，它将程序和数据放在同一个存储空间内，采用取指-执行模式执行，即按照顺序从内存读取指令、译码、执行。 （2）寄存器是位于CPU内部的存储单元，类似于内存中的存储单元。寄存器使用名字而不是地址来访问，如r0，r1，……，r15（ARM的命名），或是AX，BX，CX，DX，SP，BP，SI（Intel命名），或是D0，D1，……，D7（Freesacle的命名）。 （3）计算机指令的操作码可以使用很少的几位来引用寄存器，指令中用来选择寄存器的字段一般为3~5位，具体数值取决于计算机中程序可见寄存器的个数。 （4）CPU中的寄存器有几个功能，一些寄存器是高速暂存寄存器，用于保存数据或数据单元的地址（即指针）。另外一些事特殊功能寄存器，如对一个循环的次数进行计数的循环计数器，有的用来记录处理器的状态。CPU中最重要的寄存器是程序计数器（PC），它记录了要执行的下一条指令的地址。 （5）计算机指令有多种格式，通用计算机提供了以下3种指令格式： LDR 寄存器目的,存储单元源 STR 寄存器源,存储单元目的 Operation 寄存器目的,寄存器源1,寄存器源2 如： LDR r1,1234 ​ LDR指令把数据从存储器复制到寄存器，将地址为1234的存储单元中 的数据 读到寄存器r1中 ​ STR r2,2000 ​ STR指令把数据从寄存器传输到存储器，将寄存器r2的值写入地址为 2000的存 储单元 ​ ADD r1,r2,r3 ​ 将寄存器r2和r3中的内容相加，把结果写入寄存器r1，因此，r2和r3 的内容保 持不变 下图，描述了存储程序计算机的功能图： 下图，给出了虚拟的 存储程序计算机的结构： 图中寄存器定义如下：MAR： 存储器地址寄存器，保存了读或写操作正在访问的存储单元的地址 MBR： 存储器数据寄存器，保存了刚从存储器中读出的数据，或将要写入存储器的数据 PC： 程序计数器，保存了要执行的下一条指令的地址 IR： 指令寄存器，存放最近从存储器中读出的指令，也就是当前正在执行的指令 r0-r7： 寄存器文件，包括8个通用目的寄存器r0，r1，…，r7，用于存放临时数据 下述RTL表明了下图中的处理器如何读取并 执行LDR r1,1234的： 1. 寄存器的可见性 寄存器有3种类型：通用寄存器，用来保存计算过程产生的临时数据。ARM有16个通用寄存器，r0,r1….,r15。寄存器r14和r15是通用寄存器，程序员可以访问这两个寄存器，然而，r14与r15又在ARM体系结构中扮演着特殊角色。 特殊功能寄存器，用于特定功能。如，PC指向要执行的下一条执行指令。其他特殊功能寄存器还有状态寄存器、栈指针寄存器以及CPU标识寄存器等。 不可见寄存器，不属于处理器体系结构的一部分，不能被程序员直接使用。如，指令寄存器IR和内存地址寄存器MAR等，这些都是实现计算机所必需的，但又不属于ISA的一部分。 为什么程序计数器要加4 计算机存储器按照字节编址，各个字节存储单元依次命名为0，1，2…。但是32位微处理器使用32位指令和32位字数据。 因此每一次取指后PC必须加4，因为4字节x8位/字节=32位=1指令字。 3.1.1 扩展处理器：常量处理 LDR r1,1234，这里的“1234”是指地址为1234的存储单元的内容。假设要将数值1234载入寄存器r1中，这样的数字叫作立即操作数。立即数是一个在运算中可以直接使用的数，与存储单元的值完全不同，需要用哈希符号**(#)前缀**来声明。如： 汇编指令 RTL表示 LDR r1,200 [r1]&lt;- [200] LDR r1,#200 [r1]&lt;-200 ADD r0,r1,#25 | 下图描述了实现立即数操作所需的新数据路径： || ———————————————————— || | 2. 一些常用指令 类ARM指令： LDR r0,address STR r0,address ADD r0,r1,r2 SUB r0,r1,r2 ；r0=r2-r1 BPL target ; 如果前一个操作结果大于等于0，则跳转到 target处 BEQ target ; 如果前一个操作结果为0，则跳转到target处 B target ; 无条件跳转到地址为target处 3.1.2 扩展处理器：流控制 流控制是指任意能够改变程序中指令顺序执行的动作，它是指计算机非顺序执行指令的能力。 流控制是指转移到程序中特定位置的分支和跳转指令、子程序/过程调用，返回、中断以及操作系统调用。 流控制的典型例子就是条件行为，它允许处理器在两个可能的动作序列中选择一个执行。 | 下图显示了计算机实现条件控制所需的信息通路： || ———————————————————— || | 下述代码段描述了一个条件分支的行为： SUBS r5，r5，#1 ; r5减1 BEQ onZero ; 如果r5为0则跳到标号onZero处执行 notZero ADD r1，r2，r3 ; 否则继续执行 . . onZero SUB r1, r2, r3 ; 分支的转移目的地伪代码表示： if zero then r1 = r2 – r3 else r1 = r2 + r3 3. 条件码寄存器（Condition Code Register，CCR） ALU的信息将被写入条件码寄存器（Condition Code Register，CCR），它保存了各种用于测试的条件（如，零、负、正）。当ALU执行一个操作时，它会更新CCR中的零位、借位位、负位以及溢出位。 3.1.2扩展处理器： 流控制 下图说明了ALU运算的结果如何 被反馈给程序计数器PC， 以选择实现控制转移的指令： 从使用PC中的地址到存储器地址中取出条件分支指令开始。分支指令读出CCR的内容，其内容由上一条指令的结果决定。在执行时，条件分支指令将完成以下两个动作中的一个： 1）如果CCR中的测试位为false，则处理器从[PC]+4处取出下一条指令2）如果CCR中的测试位为true，则PC从IR的操作数字段载入新的地址，并跳转到新地址处执行 （1）状态信息计算机执行一个操作时，将状态或条件信息保存在CCR中，处理器记录下结果是否为0（Z），结果的二进制形式是否为负（N），是否产生进位位（C），是否算术溢出（V）。 考虑下述例子中8位加法对CCR中位的影响： 更新CCR还是不更新CCR？CCR中的位会在每次操作后被更新，这一说法并不完全准确。不同处理器的情况完全不同。Intel IA32和Fresscale 68K那样的CISC处理器会在每次操作后自动更新状态标志，而ARM那样的RISC处理器则需要程序员来强制更新状态标志。ARM处理器，需要在指令中添加后缀“S”（如SUBS、ADDS）来完成。如CMP（比较）和TST（测试），会自动更新状态标志位，不需要添加后缀“S”。 （2）分支指令例子例1：如何使用条件分支指令BEQ address来实现高级语言结构？首先处理器用IR中BEQ指令的操作码字段选出CCR中的一位进行测试（如Z、N或C位），如果被测试的位为1，则PC载入一个新地址（即分支目标地址），否则PC不变。 ​ 汇编语言表示：​ BEQ address ; 如果Z标志位为1，则跳转到address处​​ RTL表示：​ IF [Z] = 1​ THEN [PC] &lt;- RTL表示： 下图说明了上述代码是如何在虚拟计算机上执行的，它考虑了两种情形：情形1：P = 12，Q = 9，分支转移成功，控制转移到分支目标地址情形2：P = 12，Q = 14，分支转移不成功，控制转移到PC + 4 例3：在循环中使用条件分支来计算1+2+3+…+20 LDR r0,#1 ; 把1放入寄存器r0中 LDR r1,#0 ; 把0放入寄存器r1中Next ADD r1,r1,r0 ; 重复：当前计数值与部分和相加 ADD r0,r0,#1 ; 计数值加1 CMP r0,#21 ; 20个数是否都已加完 BNE Next ; 直到：完成20次迭代 STOP ; 若完成，则停止 3.2 ISA的组成 ISA的3个组成部分：寄存器集、寻址方式和指令格式 3.2.1 寄存器 片内的一个指针寄存器保存了存储器中寄存器的地址。 寄存器对于提高计算机性能和实际指令集设计是很有必要的。 设计一条ADD P=Q+ R的计算机指令，P、Q、R都是存储地址。假设操作码为16位（ADD部分），地址空间为32位，则指令长度为16 + 32 +32 +32 = 112位，如下图： 典型的真实计算机的指令长度为16位或32位，所以112位的指令长度是不可行的。 实际计算机用寄存器实现片上存储，寄存器的功能与存储单元一样，唯一的区别在于访问的便捷性和响应时间。仅需很少的指令就可以指定一个片上寄存器。如，某计算机的操作码为8位，带有8个片上寄存器（用3位就可以访问r0-r7中一个），就能用8 + 3+3+3=17位实现指令ADD P = Q+ R。如图：某计算机有3个5位操作数地址字段，可以寻址32个寄存器，32位指令字中余下的17位用于指令操作码和额外的控制字段 3.2.2 寻址方式概述 指令对数据进行操作，并且必须将数据移动到其被处理的地方。指定数据的方式统称为“寻址方式”。 3种基本寻址方式为： 1）立即数寻址 2）直接寻址 3）间接寻址 4. 立即数寻址 最简单的寻址方式，其操作数是指令的一部分。 如操作P= Q+5，这里的5就是立即数，它没有被保存在存储单元或寄存器中，而是指令的组成部分。 ARM处理器使用前缀#指定立即操作数，如ADD r1,r2,#5完成了操作[r1] &lt;-[r2]+5 5.直接寻址 也称作绝对寻址。把操作数地址用作指令的一部分。如指令ADD P,Q,R表示将存储单元Q的内容与存储单元R的内容相加，并将结果保存在存储单元P中。 直接寻址在CISC计算机上得到广泛使用，如Intel IA32或68K系列，Load/store型计算机，如ARM，没有实现直接寻址。 6.间接寻址 更严格地说，叫作寄存器间接寻址。在寄存器间接寻址中，指令给出了包含操作数地址的寄存器的地址。 获得一个操作数需要3次访问：读指令，读含有操作数地址的寄存器，以及最后读出实际的操作数。 含有操作数地址的寄存器称作指针寄存器。Load/store型计算机（如ARM），使用这种寻址方式访问存储器操作数。 如，ARM指令LDR r1,[r2]表示将寄存器r2所指的存储单元的内容加载到寄存器r1中。 以下分别是ARM、Intel IA32和Freescale 68K的汇编语言语句： LDR r1,[r2] ; 将寄存器r2所指存储单元的内容复制到寄存器r1中 MOV ax,[bx] ; 将寄存器bx所指存储单元的内容复制到寄存器ax中 MOVE (A5),D2 ; 将寄存器A5所指存储单元的内容复制到寄存器D2中 寄存器间接寻址有许多变种，最常用的格式是带偏移量的寄存器间接寻址，其中操作数的地址由寄存器内容加上常量或偏移量指定。 典型格式为： LDR r2,[r3,#8] ; 把寄存器r3+8所指存储单元的内容复制到寄存器r2中 MOV ax,[12,bx] ; 把寄存器bx+12所指存储单元的内容复制到寄存器ax中 MOVE (16,A5),D2 ; 把寄存器A5+16所指存储单元的内容复制到寄存器D2中 如图，描述了这些寻址方式的处理过程：、 7. 存储器与寄存器寻址 寄存器与存储单元之间没有本质区别，其区别主要体现在它们的相对访问速度以及指定一个寄存器和一个存储单元所需的地址位数上。 由此推出，这些计算机不支持存储器-存储器型寻址方式 3.2.4 操作码与指令 计算机体系结构设计中最重要的一个因素是每条指令中操作数地址的数量。 如，实现了指令ADD r1,r2,r3的指令集是三地址计算机，而实现了ADD r1,r2指令的计算机是双地址计算机。在此主要介绍三地址、双地址、单地址、零地址的计算机。 考虑下面例子，指令带有0~3个操作数，操作数P、Q、R是存储单元或寄存器 ​ 操作数 指令 作用​ 3个 ADD P,Q,R Q与R相加，结果存放在P中​ 2个 ADD P,Q Q与P相加，结果存放在P中​ 1个 ADD P P与累加器相加，结果存放在累加器中​ 0个 ADD 从栈顶弹出两个数相加，结果放在栈顶 204Page","categories":[],"tags":[]},{"title":"Jwt","slug":"Jwt","date":"2022-02-04T08:53:53.000Z","updated":"2022-02-04T09:05:34.753Z","comments":true,"path":"posts/jwt/","link":"","permalink":"https://dahammer666.github.io/posts/jwt/","excerpt":"","text":"六、设计及实现—用户管理6.1 实现流程 6.2 后端接口开发6.2.1 完成DAO操作 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = \"User对象\",description = \"用户/买家信息\") public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDAO { //用户注册 public int insert(User user); //根据用户名查询用户信息 public User query(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qfedu.fmmall.dao.UserDAO\"&gt; &lt;insert id=\"insertUser\"&gt; insert into users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{userRegtime},#{userModtime}) &lt;/insert&gt; &lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"password\" property=\"password\"/&gt; &lt;result column=\"nickname\" property=\"nickname\"/&gt; &lt;result column=\"realname\" property=\"realname\"/&gt; &lt;result column=\"user_img\" property=\"userImg\"/&gt; &lt;result column=\"user_mobile\" property=\"userMobile\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_sex\" property=\"userSex\"/&gt; &lt;result column=\"user_birth\" property=\"userBirth\"/&gt; &lt;result column=\"user_regtime\" property=\"userRegtime\"/&gt; &lt;result column=\"user_modtime\" property=\"userModtime\"/&gt; &lt;/resultMap&gt; &lt;select id=\"queryUserByName\" resultMap=\"userMap\"&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username=#{name} &lt;/select&gt; &lt;/mapper&gt; 6.2.2 完成Service业务 创建service接口 public interface UserService { //用户注册 public ResultVO userResgit(String name, String pwd); //用户登录 public ResultVO checkLogin(String name, String pwd); } 创建service接口实现类，完成业务实现 @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Transactional public ResultVO userResgit(String name, String pwd) { synchronized (this) { //1.根据用户查询，这个用户是否已经被注册 User user = userDAO.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDAO.insertUser(user); if (i &gt; 0) { return new ResultVO(10000, \"注册成功！\", null); } else { return new ResultVO(10002, \"注册失败！\", null); } } else { return new ResultVO(10001, \"用户名已经被注册！\", null); } } } @Override public ResultVO checkLogin(String name, String pwd) { User user = userDAO.queryUserByName(name); if(user == null){ return new ResultVO(10001,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(user.getPassword())){ return new ResultVO(10000,\"登录成功！\",user); }else{ return new ResultVO(10001,\"登录失败，密码错误！\",null); } } } } 6.2.3 完成Controller提供接口 创建controller，调用service 添加接口注解 @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"string\",name = \"username\", value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"string\",name = \"password\", value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ ResultVO resultVO = userService.userResgit(username, password); return resultVO; } } 6.2.4 接口测试 基于swagger进行测试 6.3 前端跨域访问6.3.1 跨域访问概念 什么时跨域访问？ AJAX 跨域访问是用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面 6.3.2 如何解决跨域访问？ 前端使用JSONP设置 后端使用@CrossOrigin — 就是设置响应头允许跨域 6.4 前端页面之间的传值6.4.1 cookie 工具方法封装： var operator = \"=\"; function getCookieValue(keyStr){ var value = null; var s = window.document.cookie; var arr = s.split(\"; \"); for(var i=0; i&lt;arr.length; i++){ var str = arr[i]; var k = str.split(operator)[0]; var v = str.split(operator)[1]; if(k == keyStr){ value = v; break; } } return value; } function setCookieValue(key,value){ document.cookie = key+operator+value; } A页面 setCookieValue(\"username\",userInfo.username); setCookieValue(\"userimg\",userInfo.userImg); B页面 var name = getCookieValue(\"username\"); var img = getCookieValue(\"userimg\"); 6.4.2 localStorage A页面 localStorage.setItem(\"user\",JSON.stringify(userInfo)); B页面 var jsonStr = localStorage.getItem(\"user\"); var userInfo = eval(\"(\"+jsonStr+\")\"); //移出localStorage键值对 localStorage.removeItem(\"user\"); 七、前后端分离用户认证-JWT7.1 基于session实现单体项目用户认证 在单体项目中如何保证受限资源在用户未登录的情况下不允许访问？ 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 基于token实现前后端分离用户认证 由于在前后端分离项目开发中，前后端之间是通过异步交互完成数据访问的，请求是无状态的，因此不能基于session实现用户的认证。 7.3 基于token的用户认证的实现7.3.1 登录认证接口生成token// UserController @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ ResultVO resultVO = userService.checkLogin(name, pwd); return resultVO; } // UserServiceImpl public ResultVO checkLogin(String name, String pwd) { Example example = new Example(Users.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"username\", name); List&lt;Users&gt; users = usersMapper.selectByExample(example); if(users.size() == 0){ return new ResultVO(ResStatus.NO,\"登录失败，用户名不存在！\",null); }else{ String md5Pwd = MD5Utils.md5(pwd); if(md5Pwd.equals(users.get(0).getPassword())){ //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"QIANfeng6666\"); return new ResultVO(ResStatus.OK,token,users.get(0)); }else{ return new ResultVO(ResStatus.NO,\"登录失败，密码错误！\",null); } } } 7.3.2 登录页面接收到token存储到cookie// login.html doSubmit:function(){ if(vm.isRight){ var url = baseUrl+\"user/login\"; axios.get(url,{ params:{ username:vm.username, password:vm.password } }).then((res)=&gt;{ var vo = res.data; if(vo.code == 10000){ //如果登录成功，就把token存储到cookie setCookieValue(\"token\",vo.msg); window.location.href = \"index.html\"; }else{ vm.tips = \"登录失败，账号或密码错误！\"; } }); }else{ vm.tips = \"请正确输入帐号和密码！\"; } } 7.3.3 购物车页面加载时访问购物车列表接口 获取token 携带token访问接口 &lt;script type=\"text/javascript\"&gt; var baseUrl = \"http://localhost:8080/\"; var vm = new Vue({ el:\"#container\", data:{ token:\"\" }, created:function(){ //当进入到购物车页面时，就要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method:\"get\", url:baseUrl+\"shopcart/list\", params:{ token:this.token } }).then(function(res){ console.log(res); }); } }); &lt;/script&gt; 7.3.4 在购物车列表接口校验token@GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\", value = \"授权令牌\",required = true) public ResultVO listCarts(String token){ //1.获取token //2.校验token if(token == null){ return new ResultVO(ResStatus.NO,\"请先登录\",null); }else{ String decode = Base64Utils.decode(token); if(decode.endsWith(\"QIANfeng6666\")){ //token校验成功 return new ResultVO(ResStatus.OK,\"success\",null); }else{ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); } } } 7.4 JWT 如果按照上述规则生成token： 1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） 7.4.1 JWT简介 JWT： Json Web Token 官网：https://jwt.io jwt的结构 7.4.2 生成JWT 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成token String token = builder.setSubject(name) //主题，就是token中携带的数据 .setIssuedAt(new Date()) //设置token的生成时间 .setId(users.get(0).getUserId() + \"\") //设置用户id为token id .setClaims(map) //map中可以存放用户的角色权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置过期时间 .signWith(SignatureAlgorithm.HS256, \"QIANfeng6666\") //设置加密方式和加密密码 .compact(); 7.4.3 JWT校验 如果token正确则正常解析，如果token不正确或者过期，则通过抛出的异常进行识别 try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"QIANfeng6666\"); //解析token的SigningKey必须和生成token时设置密码一致 //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); //获取token中用户数据 String subject = body.getSubject(); //获取生成token设置的subject String v1 = body.get(\"key1\", String.class); //获取生成token时存储的Claims的map中的值 return new ResultVO(ResStatus.OK,\"success\",null); }catch (ExpiredJwtException e){ return new ResultVO(ResStatus.NO,\"登录过期，请重新登录！\",null); }catch (UnsupportedJwtException e){ return new ResultVO(ResStatus.NO,\"Tonken不合法，请自重！\",null); }catch (Exception e){ return new ResultVO(ResStatus.NO,\"请重新登录！\",null); } 7.4.4 拦截器校验Token 创建拦截器 @Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 配置拦截器 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/user/**\"); } } 7.5 请求头传递token 前端但凡访问受限资源，都必须携带token发送请求；token可以通过请求行(params)、请求头（header）以及请求体（data）传递，但是习惯性使用header传递 7.5.1 axios通过请求头传值axios({ method:\"get\", url:baseUrl+\"shopcart/list\", headers:{ token:this.token } }).then(function(res){ console.log(res); }); 7.5.2 在拦截器中放行options请求@Component public class CheckTokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //放行options请求 String method = request.getMethod(); if(\"OPTIONS\".equalsIgnoreCase(method)){ return true; } String token = request.getHeader(\"token\"); System.out.println(\"-------------\"+token); if(token == null){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); //提示请先登录 doResponse(response,resultVO); }else{ try { //验证token JwtParser parser = Jwts.parser(); //解析token的SigningKey必须和生成token时设置密码一致 parser.setSigningKey(\"QIANfeng6666\"); //如果token正确（密码正确，有效期内）则正常执行，否则抛出异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); return true; }catch (ExpiredJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"登录过期，请重新登录！\", null); doResponse(response,resultVO); }catch (UnsupportedJwtException e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"Token不合法，请自重！\", null); doResponse(response,resultVO); }catch (Exception e){ ResultVO resultVO = new ResultVO(ResStatus.NO, \"请先登录！\", null); doResponse(response,resultVO); } } return false; } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } }","categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"}],"tags":[]},{"title":"Test","slug":"Test","date":"2022-01-29T07:03:58.000Z","updated":"2022-01-29T14:12:36.958Z","comments":true,"path":"posts/784dd132/","link":"","permalink":"https://dahammer666.github.io/posts/784dd132/","excerpt":"","text":"1 2","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2022-01-29T04:02:19.000Z","updated":"2022-01-29T14:24:08.165Z","comments":true,"path":"posts/c0add594/","link":"","permalink":"https://dahammer666.github.io/posts/c0add594/","excerpt":"","text":"一、VUE简介 项目结构经历的三个阶段 后端MVC：它是单体结构，流程控制是由后端控制器来完成的 前端MVC：前后端分离开发，后端只负责接收响应请求 MVVM：前端请求后端接口，后端返回数据，前端接收数据，并将接收的数据的数据设置“VM”，HTML从vm中取值。 M model 数据模型，指的是从后端接口返回的数据 (前端发送请求，后端接收数据) V view 视图（HTML） VM ViewModel（js） 视图模型，数据模型与视图之间的桥梁，后端返回的model转换前端所需的vm，视图层可以直接从vm中提取数据。 MVC MVVM 二、 vue的入门使用 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 2.1 vue的引入 离线引用：下载vue的js文件，添加到前端项目，在网页中通过script标签引用vue.js文件 CDN引用： &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 2.2 入门案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; 从vm中获取的数据为：{{str}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str:\"从前有座山\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 三、 vue的语法3.1 基本类型数据和字符串{{code}} {{str}} ------------------------- data:{ code:10, str:\"test\" } 3.2 对象类型数据{{stu.stuNum}} {{stu.stuName}} ----------------------------- data{ stu:{ stuNum:\"100001\", stuName:\"张三\", stuGender:\"M\", stuAge:20 } } 3.4 循环 v-for&lt;table border=\"1\" cellspacing=\"0\" width=\"400\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"s,index in stus\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;label v-if=\"s.stuGender == 'M'\"&gt;男&lt;/label&gt; &lt;label v-if=\"s.stuGender == 'F'\"&gt;女&lt;/label&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --------------------------------------------------------------------- data:{ stus:[ { stuNum:\"100001\", stuName:\"张大三\", stuGender:\"M\", stuAge:23 }, { stuNum:\"100002\", stuName:\"张中三\", stuGender:\"M\", stuAge:22 }, { stuNum:\"100003\", stuName:\"张小三\", stuGender:\"F\", stuAge:20 } ] } 3.5 v-bind绑定标签属性 v-bind: 可简写为 : &lt;input type=\"text\" v-bind:value=\"str\"/&gt; &lt;img :src=\"stu.stuImg\"/&gt; ------------------------------------ data{ str:\"从前有座山\", stu:{ stuImg:\"img/01.jpg\" } } 3.6 表单标签的双向绑定 v-model 只能使用在表单输入标签 v-model:value 可以简写为 v-model &lt;input type=\"text\" v-model:value=\"str\"/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; ------------------------------------ data{ str:\"从前有座山\" } 四、vue实例 每个使用vue进行数据渲染的网页文档都需要创建一个Vue实例 —— ViewModel 4.1 Vue实例的生命周期 vue实例生命周期——vue实例从创建到销毁的过程 创建vue实例（初始化data、加载el） 数据挂载（将vue实例data中的数据渲染到网页HTML标签） 重新渲染（当vue的data数据发生变化，会重新渲染到HTML标签） 销毁实例 4.2 钩子函数 为了便于开发者在vue实例生命周期的不同阶段进行特定的操作，vue在生命周期四个阶段的前后分别提供了一个函数，这个函数无需开发者调用，当vue实例到达生命周期的指定阶段会自动调用对应的函数。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;label v-once&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;label&gt;{{str}}&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, beforeCreate:function(){ //1.data初始化之前执行，不能操作data }, created:function(){ //2.data初始化之后执行，模板加载之前，可以修改/获取data中的值 console.log(this.str); //this.str = \"山里有座庙\"; }, beforeMount:function(){ //3.模板加载之后，数据初始渲染（挂载）之前，可以修改/获取data中的值 //this.str = \"庙里有口井\"; }, mounted:function(){ //4.数据初始渲染（挂载）之后，可以对data中的变量进行修改，但是不会影响v-once的渲染 //this.str = \"井里有只蛙\"; }, beforeUpdate:function(){ //5.数据渲染之后，当data中的数据发生变化触发重新渲染，渲染之前执行此函数 // data数据被修改之后，重新渲染到页面之前 console.log(\"-----\"+this.str); this.str = \"从前有座山2\"; }, updated:function(){ //6.data数据被修改之后，重新渲染到页面之后 //this.str = \"从前有座山3\"; }, beforeDestroy:function(){ //7.实例销毁之前 }, destroyed:function(){ //8.实例销毁之后 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 五、计算属性和侦听器5.1 计算属性 data中的属性可以通过声明获得，也可以通过在computed通过计算获得 特性：计算属性所依赖的属性值发生变化会影响计算属性的值同时发生变化 示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\" }, computed:{ str3:function(){ return this.str1+this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.2 侦听器 侦听器，就是data中属性的监听器，当data中的属性值发生变化就会触发侦听器函数的执行 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"str1\"/&gt;&lt;br/&gt; &lt;input type=\"text\" v-model=\"str2\"/&gt;&lt;br/&gt; {{str3}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ str1:\"千锋\", str2:\"武汉\", str3:\"千锋武汉\" }, watch:{ str1:function(){ this.str3 = this.str1 +this.str2; }, str1(){ } str2:function(){ this.str3 = this.str1 +this.str2; } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 六、class与style绑定 我们可以使用mustache语法将vue中data的数据绑定到HTML标签及标签的属性，如何将data中的值绑定到标签的class及style属性呢？ 6.1 class绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .mystyle1{ width: 200px; height: 100px; background: orange; } .mystyle3{ width: 200px; height: 100px; background: black; } .my-style2{ border-radius: 10px; } &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--如果b1为true就加载 mystyle1；如果b2为true，则加载my-style2--&gt; &lt;div :class=\"{mystyle1:b1,'my-style2':b2}\"&gt;&lt;/div&gt; &lt;!--为class属性加载多个样式名 --&gt; &lt;div :class=\"[chooseStyle1,chooseStyle2]\"&gt;&lt;/div&gt; &lt;!--如果b3为true，则class='mystyle3'; 否则class='mystyle1' 如果在三目运算中使用样式名则需加单引号，不加单引号则表示从data变量中获取样式名--&gt; &lt;div :class=\"[b3 ? 'mystyle3' : 'mystyle1']\"&gt;&lt;/div&gt; &lt;div :class=\"[b3 ? chooseStyle3 : chooseStyle1]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ b1:true, b2:true, b3:false, chooseStyle1:\"mystyle1\", chooseStyle2:\"my-style2\", chooseStyle3:\"mystyle3\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6.2 style绑定&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--当使用v-bind绑定内联样式时： 1. 使用{}定义style样式，才能获取data中的值，{}要遵循JSON格式 2. {}中不在使用style样式属性名“font-size”,而要使用对应的js属性名 border-style-width --- borderStyleWidth --&gt; &lt;div v-bind:style=\"{color: colorname,fontSize: fontsize+'px' }\"&gt;WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的字符串--&gt; &lt;div v-bind:style=\"mystyle1\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--我们可以直接为style属性绑定一个data中定义好的内联样式的对象--&gt; &lt;div v-bind:style=\"mystyle2\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;!--可以在同一个style上通过数组引用多个内联样式的对象--&gt; &lt;div v-bind:style=\"[mystyle2,mystyle3]\"&gt;千锋Java-WH2010&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ colorname:\"green\", fontsize:30, mystyle1:\"color:orange;font-size:45px\", mystyle2:{ color:\"blue\", fontSize:\"40px\" }, mystyle3:{ textShadow:\"orange 3px 3px 5px\" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 七、条件与列表渲染7.1 条件渲染7.1.1 v-if 在html标签可以添加v-if指令指定一个条件，如果条件成立则显示此HTML标签，如果不成立则不显示当前标签； 条件可以是一个表达式也可以是一个具体的bool类型值 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;h3 v-if=\"b\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:2, b:false } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.1.2 v-else&lt;div id=\"container\"&gt; &lt;!--v-else标签需要紧跟在v-if的标签之后，中间不能有其他标签--&gt; &lt;h3 v-if=\"code == 1\"&gt;从前有座山&lt;/h3&gt; &lt;h3 v-else&gt;山里有座庙&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:1 } }); &lt;/script&gt; 7.1.3 v-else-if&lt;div id=\"container\"&gt; &lt;h3 v-if=\"code &gt;= 90\"&gt;优秀&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 80\"&gt;良好&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 70\"&gt;中等&lt;/h3&gt; &lt;h3 v-else-if=\"code &gt;= 60\"&gt;及格&lt;/h3&gt; &lt;h3 v-else&gt;不想理你&lt;/h3&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ code:85 } }); &lt;/script&gt; 7.1.4 v-show 从功能上将v-show和v-if作用是相同的，渲染过程有区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.2 列表渲染 将集合数据以表格、列表的形式显示 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"c in categories\"&gt; &lt;a :href=\"'query?cid='+c.cid\"&gt;{{c.cname}}&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;照片&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;template v-for=\"s,index in stus\"&gt; &lt;tr :id=\"'tr'+s.stuNum\"&gt; &lt;td&gt;{{s.stuNum}}&lt;/td&gt; &lt;td&gt; &lt;img height=\"30\" :src=\"s.stuImg\"/&gt; &lt;/td&gt; &lt;td&gt;{{s.stuName}}&lt;/td&gt; &lt;td&gt; &lt;!--{{s.stuGender=='M'?'男':'女'}}--&gt; &lt;img v-if=\"s.stuGender=='M'\" src=\"img/m.bmp\"&gt; &lt;img v-else src=\"img/f.bmp\"&gt; &lt;/td&gt; &lt;td&gt;{{s.stuAge}}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-danger btn-xs\" :href=\"'stu/delete?cid='+s.stuNum\"&gt;删除&lt;/a&gt; &lt;a class=\"btn btn-success btn-xs\" :href=\"'stu/update?cid='+s.stuNum\"&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/table&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ categories:[ { cid:1, cname:\"华为\" }, { cid:2, cname:\"小米\" }, { cid:3, cname:\"OPPO\" }, { cid:4, cname:\"VIVO\" } ], stus:[ { stuNum:\"10010\", stuImg:\"img/01.jpg\", stuName:\"Tom\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10011\", stuImg:\"img/02.jpg\", stuName:\"LiLei\", stuGender:\"M\", stuAge:20 }, { stuNum:\"10012\", stuImg:\"img/03.jpg\", stuName:\"Lucy\", stuGender:\"F\", stuAge:20 }, { stuNum:\"10013\", stuImg:\"img/04.jpg\", stuName:\"Polly\", stuGender:\"F\", stuAge:20 } ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 八、事件处理 在使用vue进行数据渲染时，如果使用原生js事件绑定(例如onclick)，如果需要获取vue实例中的数据并传参则需要通过拼接来完成 vue提供了v-on指令用于绑定各种事件（v-on:click），简化了从vue取值的过程，但是触发的方法需要定义在vue实例的 methods中 &lt;button type=\"button\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{}, methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; v-on:clicl可以缩写为`@click 8.1 使用JS函数传值&lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName)\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname){ console.log(\"----delete:\"+snum+\" \"+sname) } } }); &lt;/script&gt; 8.2 使用dataset对象传值&lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doUpdate\" :data-snum=\"s.stuNum\" :data-sname=\"s.stuName\" :data-simg=\"s.stuImg\"&gt;修改&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doUpdate:function(event){ //如果v-on绑定的js函数没有参数，调用的时候可以省略()，同时可以给js函数一个event参数(事件对象) // 1. event 表示触发当前函数的事件 // 2. event.srcElement 表示发生事件的元素---修改按钮 // 3. event.srcElement.dataset 表示按钮上绑定的数据集（data-开头的属性） console.log(\"-----update\") var stu = event.srcElement.dataset; } } }); &lt;/script&gt; 8.3 混合使用 $event &lt;button type=\"button\" class=\"btn btn-danger btn-xs\" v-on:click=\"doDelete(s.stuNum,s.stuName,$event)\":data-simg=\"s.stuImg\"&gt;删除&lt;/button&gt; &lt;script&gt; var vm = new Vue({ el:\"#container\", data:{}; methods:{ doDelete:function(snum,sname,event){ console.log(\"----delete:\"+snum+\" \"+sname) console.log(event.srcElement.dataset); } } }); &lt;/script&gt; 8.4 事件修饰符 当使用v-on进行事件绑定的时候，可以添加特定后缀，设置事件触发的特性 8.4.1 事件修饰符使用示例&lt;button type=\"submit\" @click.prevent=\"事件函数\"&gt;测试&lt;/button&gt; 8.4.2 事件修饰符.prevent 消除元素的默认事件 &lt;div id=\"container\"&gt; &lt;form action=\"https://www.baidu.com\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-xs\" @click.prevent=\"test\"&gt;测试&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ test:function(){ console.log(\"---test\"); } } }); &lt;/script&gt; .stop 阻止事件冒泡（阻止子标签向上冒泡） .self 设置只能自己触发事件（子标签不能触发） &lt;div id=\"container\"&gt; &lt;div style=\"width: 200px; height: 200px; background: red;\" @click.self=\"method1\"&gt; &lt;div style=\"width: 150px; height: 150px; background: green;\" @click=\"method2\"&gt; &lt;button type=\"button\" @click.stop=\"method3\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ }, methods:{ method1:function(){ alert(\"1\"); }, method2:function(){ alert(\"2\"); }, method3:function(){ alert(\"3\"); } } }); &lt;/script&gt; .once 限定事件只触发一次 8.4.3 按键修饰符 按键修饰符就是针对键盘事件的修饰符，限定哪个按键会触发事件 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了以上vue提供按钮的别名之外，我们还可以根据键盘为按键自定义别名 键盘码 示例： &lt;div id=\"container\"&gt; &lt;!--2.使用自定义的按键别名aaa作为修饰符--&gt; &lt;input type=\"text\" @keyup.aaa=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //1.为按键J定于别名为 aaa Vue.config.keyCodes.aaa =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; 8.4.3 系统修饰符 组合键 示例 ctrl+j触发事件 &lt;div id=\"container\"&gt; &lt;input type=\"text\" @keyup.ctrl.j=\"method4\"/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.keyCodes.j =74; var vm = new Vue({ el:\"#container\", data:{}, methods:{ method4:function(){ alert(\"4\"); } } }); &lt;/script&gt; .ctrl .alt .shift .meta windows键 九、表单输入绑定 表单输入绑定，即双向绑定：就是能够将vue实例的data数据渲染到表单输入视图（input\\textarea\\select），也能够将输入视图的数据同步更新到vue实例的data中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--文本输入框、密码输入框--&gt; &lt;input type=\"text\" v-model=\"text\"/&gt;&lt;br/&gt; &lt;input type=\"password\" v-model=\"pwd\"/&gt;&lt;br/&gt; &lt;!--单选按钮--&gt; &lt;input type=\"radio\" v-model=\"opt1\" value=\"A\"/&gt;A 3 &lt;input type=\"radio\" v-model=\"opt1\" value=\"B\"/&gt;B 4 &lt;input type=\"radio\" v-model=\"opt1\" value=\"C\"/&gt;C 5 &lt;input type=\"radio\" v-model=\"opt1\" value=\"D\"/&gt;D 6 &lt;br/&gt; &lt;!--复选框，绑定的是一个数组--&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"篮球\"/&gt;篮球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"足球\"/&gt;足球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"羽毛球\"/&gt;羽毛球 &lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"opt2\" value=\"乒乓球\"/&gt;乒乓球&lt;br/&gt; &lt;!--下拉菜单select：绑定一个字符串--&gt; &lt;select v-model=\"city\"&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;!--下拉菜单select：如果有multiple表示可多选，需要绑定一个数组--&gt; &lt;select v-model=\"cities\" multiple&gt; &lt;option value=\"BJ\"&gt;北京&lt;/option&gt; &lt;option value=\"SH\"&gt;上海&lt;/option&gt; &lt;option value=\"GZ\"&gt;广州&lt;/option&gt; &lt;option value=\"SZ\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;测试&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ text:\"aaa\", pwd:\"111111\", opt1:\"C\", opt2:[\"篮球\",\"羽毛球\"], city:\"SZ\", cities:[\"BJ\",\"SZ\"] }, methods:{ doSearch:function(){ alert(vm.cities); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 十、vue使用案例10.1 接口说明 接口名称 功能描述 根据关键字搜索音乐信息 请求URL http://47.96.11.185:9999/music/search 请求方式 GET | POST 请求参数 s string [必须] 搜索关键字limit int [可选] 返回的搜索结果的条数，默认为10type int [可选] 搜索类型(1单曲 10歌单)，默认为1offset int [可选] 搜索结果的偏移 返回结果 10.2 如何部署jar文件java -jar music-1.0.0.jar 10.3 案例目标请大家根据以上接口实现搜索和列表显示功能 10.4 案例实现10.4.1 音乐搜索10.4.2 音乐播放在music.html中定义音频播放器(定义在vue的容器之外) &lt;audio controls style=\"width:100%\" src=\"\" id=\"player\"&gt;&lt;/audio&gt; 给播放按钮绑定点击事件触发的函数doPlay &lt;button type=\"button\" class=\"btn btn-success btn-xs\" @click=\"doPlay\" :data-mid=\"song.id\"&gt;播放&lt;/button&gt; 在doPlay中执行播放 &lt;script type=\"text/javascript\"&gt; var player = document.getElementById(\"player\"); var vm = new Vue({ el:\"#container\", data:{ keyword:\"张韶涵\", songs:[], currentid:0 }, methods:{ doSearch:function(){ console.log(vm.keyword); $.get(\"http://localhost:9999/music/search\",{s:vm.keyword,limit:15,offset:0},function(res){ console.log(res); if(res.code==200){ //获取此关键词搜索的总记录数 var count = res.result.songCount; //获取音乐集合 var arr = res.result.songs; vm.songs = arr; }else{ vm.songs = data; } },\"json\"); }, doPlay:function(event){ vm.currentid = event.srcElement.dataset.mid; //网易云音乐播放地址： http://music.163.com/song/media/outer/url?id=songId player.src = \"http://music.163.com/song/media/outer/url?id=\"+vm.currentid; player.play(); } } }); &lt;/script&gt; 10.4.3 播放暂停切换 十一、组件11.1 组件介绍及示例 组件，就是将通用的HTML模块进行封装——可复用 11.1.1 组件注册 将通用的HTML模块封装注册到vue中 Vue.component(\"header-bar\",{ }); 11.1.2 组件引用 定义组件需要依赖vue.js，在引用自定义组件的js文件之前要先引用vue.js 组件的引用必须在vue实例el指定的容器中 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.2 组件注册11.2.1 自定义组件的结构 data 定义组件的模板渲染的数据 template 组件的HTML模块（HTML标签\\css样式） methods 定义组件中的标签事件绑定的JS函数 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { title:\"Java2010电商平台\" }; }, template:`&lt;div style=\"width: 100%; height: 80px; background: lightyellow;\"&gt; &lt;table width=\"100%\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" height=\"80\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label style=\"color: deepskyblue;font-size:32px; font-family: 华文行楷; margin-left: 30px;\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"test\"&gt;组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, methods:{ test:function(){ alert(\"组件中定义的函数\"); } } }); 11.2.2 组件的封装 将模版中的css样式提出取来，单独定义到css文件存储在css目录 将模版中的图片存在在img目录 将定义组件的js文件和vue的文件存放到js目录 vue组件封装的目录结构 11.2.3 组件的复用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\" }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.3 组件通信 vue实例本身就是一个组件（模板就是el指定容器 ,data就是组件数据,methods就是组件的事件函数）在vue实例指定的el容器中引用的组件称为子组件 ,当前vue实例就是父组件 11.3.1 父传子 vue实例引用组件的时候，传递数据到引用的组件中 示意图 11.3.2 子传父 通过子组件的按钮“调用”父组件的函数，通过函数传值 调用流程示意图 11.4 组件插槽 当我们自定义vue组件时，允许组件中的部分内容在调用组件时进行定义——插槽 11.4.1 插槽的使用在自定义组件时通过slot标签在组件的模版中定义插槽 Vue.component(\"header-bar\",{ data:function(){ //组件中的data是通过函数返回的对象 return { str2:\"子组件中的数据\" }; }, template:`&lt;div class=\"divStyle\"&gt; &lt;table class=\"tableStyle\"&gt; &lt;tr&gt; &lt;td width=\"200\" align=\"right\" valign=\"middle\"&gt; &lt;img src=\"img/logo.png\" class=\"logoImg\"&gt; &lt;/td&gt; &lt;td&gt; &lt;label class=\"titleStyle\"&gt; {{title}} &lt;/label&gt; &lt;/td&gt; &lt;td&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"childMethod\"&gt;子组件中的按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;`, props:[\"title\"], methods:{ childMethod:function(){ this.$emit(\"my-event\",this.str2); } } }); 在父组件中调用此组件时，指定插槽填充的模版 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"css/my-components.css\" /&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;header-bar :title=\"sss\"&gt; &lt;!--组件标签包含的HTML默认为填充到插槽的模版--&gt; &lt;input/&gt;&lt;button&gt;搜索&lt;/button&gt; &lt;/header-bar&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/my-components.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ sss:\"自定义标题\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11.4.2 具名插槽 当组件中的插槽数量&gt;1时，需要给组件中的slot标签添加name属性指定插槽的名字 定义组件： Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"] }); 引用组件 template &lt;div id=\"container\"&gt; &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;!--定义一个模版，填充到组件的name=s1的 插槽--&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--定义一个模版，填充到组件的name=s2的 插槽--&gt; &lt;template slot=\"s2\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; &lt;/div&gt; 11.4.3 插槽作用域 定义组件时，将组件中的数据绑定到slot标签 Vue.component(\"page-frame\",{ template:`&lt;div&gt; &lt;div id=\"header\" style=\"width:100%; height:100px;background:pink\"&gt; &lt;slot name=\"s1\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div style=\"width:100%; height:580px\"&gt; &lt;slot name=\"s2\" v-bind:musics=\"songs\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div id=\"footer\" style=\"width:100%; height:40px;background:lightgray\"&gt;{{cr}}&lt;/div&gt; &lt;/div&gt;`, props:[\"title\",\"cr\"], data:function(){ return { songs:[ {},{} ] }; } }); 引用组件时，在填充插槽的模版上使用slot-scopt属性获取插槽绑定的值 &lt;page-frame title=\"标题\" cr=\"千锋武汉\"&gt; &lt;template slot=\"s1\"&gt; &lt;input type=\"text\" placeholder=\"歌曲名、歌手\" /&gt; &lt;button type=\"button\" @click=\"doSearch\"&gt;搜索&lt;/button&gt; &lt;/template&gt; &lt;!--在使用模版填充组件插槽时，可以使用slot-scope属性获取组件插槽绑定的数据的集合 --&gt; &lt;template slot=\"s2\" slot-scope=\"res\"&gt; &lt;table class=\"table table-bordered table-condensed\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;歌曲ID&lt;/th&gt; &lt;th&gt;歌曲名&lt;/th&gt; &lt;th&gt;歌手&lt;/th&gt; &lt;th&gt;专辑&lt;/th&gt; &lt;th&gt;时长&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"song,index in res.musics\"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{song.id}}&lt;/td&gt; &lt;td&gt; {{song.name}} &lt;/td&gt; &lt;td&gt; &lt;span v-for=\"artist in song.artists\"&gt; &amp;nbsp;{{artist.name}} &lt;/span&gt; &lt;/td&gt; &lt;td&gt;{{song.album.name}}&lt;/td&gt; &lt;td width=\"8%\"&gt; {{ Math.floor( Math.round(song.duration/1000)/60) &lt; 10 ? '0'+Math.floor( Math.round(song.duration/1000)/60) : Math.floor( Math.round(song.duration/1000)/60) }} : {{ Math.round(song.duration/1000)%60 &lt;10 ? '0'+( Math.round(song.duration/1000)%60 ) : Math.round(song.duration/1000)%60 }} &lt;/td&gt; &lt;td width=\"10%\"&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;播放&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/template&gt; &lt;/page-frame&gt; 十二、axios12.1 axios介绍 vue可以实现数据的渲染，但是如何获取数据呢？ vue本身不具备通信能力，通常结合axios—一个专注于异步通信的js框架来使用 axios 数据通信 vue 数据渲染 12.2 axios入门使用 原生ajax — 实现步骤复杂 jQuery 笨重 axios 简洁、高效，对RESTful支持良好 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/axios.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 // axios.get(url).then(fn); // axios.get(url,{}).then(fn) axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12.3 axios异步请求方法 axios提供了多种异步请求方法，实现对RESTful风格的支持 12.3.1 get请求 axios.get(url).then(fn); axios.get(url,{}).then(fn) //使用axios的get请求传递参数，需要将参数设置在params下 axios.get(\"http://localhost:9999/music/detail\",{ params:{ id:\"25640392\" } }) .then(function(res){ console.log(res); }); 12.3.2 post请求 axios.post(url,{}).then(fn) axios.post(\"http://localhost:9999/music/search\",{s:\"阿刁\"}) .then(function(res){ console.log(res); }); 12.3.3 自定义请求 自定义请求：自定义请求方式、请求参数、请求头、请求体（post） axios({ url:\"http://localhost:9999/music/search\", method:\"post\", params:{ //设置请求行传值 s:\"成都\", limit:15 }, headers:{ //设置请求头 }, data:{ //设置请求体（post/put） } }).then(function(res){ console.log(res) }); 12.3.4 其他 delete put option 12.4 并发请求&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test1\"&gt;测试1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", methods:{ test1:function(){ //发送异步请求 axios.all([listMusics(),getMusicDetail()]).then(axios.spread(function (r1, r2) { // 两个请求现在都执行完成 console.log(r1); console.log(r2); })); } } }); function listMusics() { return axios.get('http://localhost:9999/music/search?s=成都'); } function getMusicDetail() { return axios.get('http://localhost:9999/music/detail?id=25640392'); } &lt;/script&gt; 12.5 箭头函数12.5.1 axios回调函数的参数res res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 12.5.2 箭头函数&lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#container\", data:{ song:{ } }, methods:{ test1:function(){ //发送异步请求 axios.get(\"http://localhost:9999/music/detail?id=25640392\").then( (res)=&gt;{ // res并不是接口返回的数据，而是表示一个响应对象；res.data才表示接口响应的数据 if(res.data.code == 200){ this.song = res.data.songs[0]; } }); } } }); &lt;/script&gt; 十三、路由 router router是由vue官方提供的用于实现组件跳转的插件 13.1 路由插件的引用13.3.1 离线&lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; 13.3.2 在线CDN&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 13.2 路由使用案例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{padding: 0px;margin: 0px;} ul{list-style: none;} ul li{display: inline; float: left; margin-left: 15px; margin-bottom: 15px;} ul li a{text-decoration: none; color: white; font-size: 18px; font-weight: bold;} ul li a:hover{color: yellow;} &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/vue-router.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div style=\"width: 100%; height: 70px; background: #00BFFF;\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo.png\" height=\"70\" style=\"margin-left:100px;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/b\"&gt;Java&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/c\"&gt;HTML5&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/d\"&gt;Python&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div style=\"width: 100%; height: 680px; background: lemonchiffon;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // vue的路由旨在为单页面应用开发提供便捷 //1.定义链接跳转的模板（组件） const t1 = {template:`&lt;p&gt;index&lt;/p&gt;`}; const t2 = {template:`&lt;p&gt;Java&lt;/p&gt;`}; const t3 = {template:`&lt;p&gt;HTML5&lt;/p&gt;`}; const t4 = {template:`&lt;p&gt;PYTHON&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a\",component:t1}, {path:\"/b\",component:t2}, {path:\"/c\",component:t3}, {path:\"/d\",component:t4} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 13.3 动态路由匹配13.3.1 通配符 *可以匹配任意路径 例如： /user-* 匹配所有以user-开头的任意路径 /* 匹配所有路径 const myrouter = new VueRouter({ routes:[ {path:\"/user-*\",component:...}, {path:\"/*\",component:...} ] }); 注意如果使用通配符定义路径，需要注意路由声明的顺序 13.3.2 路由参数 /a/:id 可以匹配 /a/开头的路径 &lt;div id=\"container\"&gt; &lt;li&gt;&lt;router-link to=\"/a/101\"&gt;首页&lt;/router-link&gt;&lt;/li&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = {template:`&lt;p&gt;index:{{$route.params.id}}&lt;/p&gt;`}; const myrouter = new VueRouter({ routes:[ {path:\"/a/:id\",component:t1} ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.3.3 优先级如果一个路径匹配了多个路由，则按照路由的配置顺序：路由定义的越早优先级就越高。 13.4 嵌套路由 在一级路由的组件中显示二级路由 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/a/c1\"&gt;首页-c1&lt;/router-link&gt; &lt;router-link to=\"/a/c2\"&gt;首页-c2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;hr/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\" }; const t2 = {template:`&lt;div&gt;t2&lt;/div&gt;`}; const t3 = {template:`&lt;div&gt;t3&lt;/div&gt;`}; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1, children:[ { path:\"c1\", component:t2 }, { path:\"c2\", component:t3 } ] } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.5 编程式导航13.5.1 push()&lt;div id=\"container\"&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter, methods:{ test:function(){ //js代码实现路由跳转：编程式导航 myrouter.push(\"/a\"); } } }); &lt;/script&gt; 13.5.2 push()参数//1.字符串 myrouter.push(\"/a\"); //2.对象 myrouter.push({path:\"/a\"}); //3.命名的路由 name参数指的是定义路由时指定的名字 myrouter.push({name:\"r1\",params:{id:101}}); //4.URL传值，相当于/a?id=101 myrouter.push({path:\"/a\",query:{id:101}}); 13.5.3 replace() 功能与push一致，区别在于replace()不会向history添加新的浏览记录 13.5.4 go() 参数为一个整数，表示在浏览器历史记录中前后/后退多少步 相当于window.history.go(-1)的作用 13.6 命名路由 命名路由：在定义路由的时候可以给路由指定name，我们在进行路由导航时可以通过路由的名字导航 &lt;div id=\"container\"&gt; &lt;input type=\"text\" v-model=\"rname\"/&gt; &lt;router-link :to=\"{name:rname}\"&gt;t1&lt;/router-link&gt; &lt;button type=\"button\" @click=\"test\"&gt;按钮1&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t1&lt;/div&gt;\" }; const t2 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t2&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", name:\"r2\", component:t2 } ] }); var vm = new Vue({ el:\"#container\", data:{ rname:\"r1\" }, router:myrouter, methods:{ test:function(){ myrouter.push({name:vm.rname}); } } }); &lt;/script&gt; 13.7 命名路由视图&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;t1&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;t2&lt;/router-link&gt; &lt;!--路由视图--&gt; &lt;!--如果在HTML中有一个以上的路由视图router-view，需要给router-view指定name，在路由中使用components映射多个组件根据name设置组件与router-view绑定关系--&gt; &lt;router-view name=\"v1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"v2\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t11 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;t11&lt;/div&gt;\" }; const t12 = { template:\"&lt;div style='width:400px; height:200px; background:pink'&gt;t12&lt;/div&gt;\" }; const t21 = { template:\"&lt;div style='width:400px; height:200px; border:red 1px solid'&gt;t21&lt;/div&gt;\" }; const t22 = { template:\"&lt;div style='width:400px; height:200px; background:yellow'&gt;t22&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", components:{ v1:t11, v2:t12 } }, { path:\"/b\", components:{ v1:t21, v2:t22 } } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.8 重定向和别名13.8.1 重定向访问/b，重定向到/a &lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/b\"&gt;路径B&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", component:t1 }, { path:\"/b\", redirect:\"/a\" } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 根据路由命名重定向 const myrouter = new VueRouter({ routes:[ { path:\"/a\", name:\"r1\", component:t1 }, { path:\"/b\", //redirect:\"/a\" //根据路由路径重定向 redirect:{name:\"r1\"} //根据路由命名重定向 } ] }); 13.8.2 路由别名&lt;div id=\"container\"&gt; &lt;router-link to=\"/a\"&gt;路径A&lt;/router-link&gt; &lt;router-link to=\"/wahaha\"&gt;路径wahaha（别名）&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:\"&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt;index&lt;/div&gt;\" }; const myrouter = new VueRouter({ routes:[ { path:\"/a\", alias:\"/wahaha\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 13.9 路由组件传参可以通过/url/:attr方式实现通过路由传值给组件 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/101\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{$route.params.id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt; 通过props传参 &lt;div id=\"container\"&gt; &lt;router-link to=\"/a/102\"&gt;路径A&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const t1 = { props:[\"id\"], template:`&lt;div style='width:400px; height:200px; border:blue 1px solid'&gt; index：{{id}} &lt;/div&gt;` }; const myrouter = new VueRouter({ routes:[ { path:\"/a/:id\", props:true, component:t1 } ] }); var vm = new Vue({ el:\"#container\", router:myrouter }); &lt;/script&gt;","categories":[],"tags":[]},{"title":"测试博客","slug":"测试博客","date":"2022-01-27T09:55:34.000Z","updated":"2022-02-04T09:02:00.036Z","comments":true,"path":"posts/d9407122/","link":"","permalink":"https://dahammer666.github.io/posts/d9407122/","excerpt":"","text":"TT title: 博客与博主comments: truetoc: truecover: https://s4.ax1x.com/2022/01/28/7x30g0.pngcategories: 生活tags: 想法abbrlink: 1date: 2021-5-27 21:00:00 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true 安装插件: npm install https://github.com/CodeFalling/hexo-asset-image -- save 运行hexo n \"XXXXXX\", 生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。 添加图片: 在想添加的位置写入![](图片名字.图片格式),例如![](1.png)。图片的路径和你写入的路径一致。 hexo-abbrlink导致图片不能显示 在安装了hexo-abbrlink后博客图片无法正常显示（用的是hexo-asset-image） 之前_config.yml中配置如下 permalink: archives/:abbrlink.html 在hexo g后时观察到，文章中的连接被重定向的位置，与图片在public中的文件位置不相符解决：根据参考重写_config.yml permalink: posts/:abbrlink/ 删除文件命令行 rm -rf xxx （xxx - 文件名）","categories":[{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}],"categories":[{"name":"shop","slug":"shop","permalink":"https://dahammer666.github.io/categories/shop/"},{"name":"杂记","slug":"杂记","permalink":"https://dahammer666.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"GG","slug":"GG","permalink":"https://dahammer666.github.io/tags/GG/"}]}